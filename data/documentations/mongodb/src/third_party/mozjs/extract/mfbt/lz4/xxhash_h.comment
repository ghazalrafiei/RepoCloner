['text':'
 * xxHash - Extremely Fast Hash algorithm
 * Header File
 * Copyright (C) 2012-2020 Yann Collet
 *
 * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following disclaimer
 *      in the documentation and/or other materials provided with the
 *      distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * You can contact the author at:
 *   - xxHash homepage: https://www.xxhash.com
 *   - xxHash source repository: https://github.com/Cyan4973/xxHash
 ','line_number':1,'multiline':True]
['text':' TODO: update ','line_number':36,'multiline':True]
['text':' Notice extracted from xxHash homepage:

xxHash is an extremely fast hash algorithm, running at RAM speed limits.
It also successfully passes all tests from the SMHasher suite.

Comparison (single thread, Windows Seven 32 bits, using SMHasher on a Core 2 Duo @3GHz)

Name            Speed       Q.Score   Author
xxHash          5.4 GB/s     10
CrapWow         3.2 GB/s      2       Andrew
MumurHash 3a    2.7 GB/s     10       Austin Appleby
SpookyHash      2.0 GB/s     10       Bob Jenkins
SBox            1.4 GB/s      9       Bret Mulvey
Lookup3         1.2 GB/s      9       Bob Jenkins
SuperFastHash   1.2 GB/s      1       Paul Hsieh
CityHash64      1.05 GB/s    10       Pike & Alakuijala
FNV             0.55 GB/s     5       Fowler, Noll, Vo
CRC32           0.43 GB/s     9
MD5-32          0.33 GB/s    10       Ronald L. Rivest
SHA1-32         0.28 GB/s    10

Q.Score is a measure of quality of the hash function.
It depends on successfully passing SMHasher test set.
10 is a perfect score.

Note: SMHasher's CRC32 implementation is not the fastest one.
Other speed-oriented implementations can be faster,
especially in combination with PCLMUL instruction:
https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html?showComment=1552696407071#c3490092340461170735

A 64-bit version, named XXH64, is available since r35.
It offers much better speed, but for 64-bit applications only.
Name     Speed on 64 bits    Speed on 32 bits
XXH64       13.8 GB/s            1.9 GB/s
XXH32        6.8 GB/s            6.0 GB/s
','line_number':37,'multiline':True]
['text':' ****************************
 *  INLINE mode
 *****************************','line_number':78,'multiline':True]
['text':'!
 * XXH_INLINE_ALL (and XXH_PRIVATE_API)
 * Use these build macros to inline xxhash into the target unit.
 * Inlining improves performance on small inputs, especially when the length is
 * expressed as a compile-time constant:
 *
 *      https://fastcompression.blogspot.com/2018/03/xxhash-for-small-keys-impressive-power.html
 *
 * It also keeps xxHash symbols private to the unit, so they are not exported.
 *
 * Usage:
 *     #define XXH_INLINE_ALL
 *     #include "xxhash.h"
 *
 * Do not compile and link xxhash.o as a separate object, as it is not useful.
 ','line_number':81,'multiline':True]
['text':' this section should be traversed only once ','line_number':99,'multiline':True]
['text':' give access to the advanced API, required to compile implementations ','line_number':101,'multiline':True]
['text':' avoid macro redef ','line_number':102,'multiline':True]
['text':' make all functions private ','line_number':104,'multiline':True]
['text':' C99 ','line_number':108,'multiline':True]
['text':' note: this version may generate warnings for unused static functions ','line_number':113,'multiline':True]
['text':'
    * This part deals with the special case where a unit wants to inline xxHash,
    * but "xxhash.h" has previously been included without XXH_INLINE_ALL, such
    * as part of some previously included *.h header file.
    * Without further action, the new include would just be ignored,
    * and functions would effectively _not_ be inlined (silent failure).
    * The following macros solve this situation by prefixing all inlined names,
    * avoiding naming collision with previous inclusions.
    ','line_number':117,'multiline':True]
['text':'
      * Note: Alternative: #undef all symbols (it's a pretty large list).
      * Without #error: it compiles, but functions are actually not inlined.
      ','line_number':128,'multiline':True]
['text':'
    * Some identifiers (enums, type names) are not symbols, but they must
    * still be renamed to avoid redeclaration.
    * Alternative solution: do not redeclare them.
    * However, this requires some #ifdefs, and is a more dispersed action.
    * Meanwhile, renaming can be achieved in a single block
    ','line_number':134,'multiline':True]
['text':' Ensure the header is parsed again, even if it was previously included ','line_number':155,'multiline':True]
['text':' XXH_INLINE_ALL || XXH_PRIVATE_API ','line_number':158,'multiline':True]
['text':' ****************************************************************
 *  Stable API
 ****************************************************************','line_number':162,'multiline':True]
['text':' specific declaration modes for Windows ','line_number':168,'multiline':True]
['text':' do nothing ','line_number':177,'multiline':True]
['text':'!
 * XXH_NAMESPACE, aka Namespace Emulation:
 *
 * If you want to include _and expose_ xxHash functions from within your own
 * library, but also want to avoid symbol collisions with other libraries which
 * may also include xxHash, you can use XXH_NAMESPACE to automatically prefix
 * any public symbol from xxhash library with the value of XXH_NAMESPACE
 * (therefore, avoid empty or numeric values).
 *
 * Note that no change is required within the calling program as long as it
 * includes `xxhash.h`: Regular symbol names will be automatically translated
 * by this header.
 ','line_number':181,'multiline':True]
['text':' XXH32 ','line_number':198,'multiline':True]
['text':' XXH64 ','line_number':208,'multiline':True]
['text':' XXH3_64bits ','line_number':218,'multiline':True]
['text':' XXH3_128bits ','line_number':231,'multiline':True]
['text':' *************************************
*  Version
**************************************','line_number':248,'multiline':True]
['text':' ****************************
*  Definitions
*****************************','line_number':258,'multiline':True]
['text':' size_t ','line_number':261,'multiline':True]
['text':'-**********************************************************************
*  32-bit hash
***********************************************************************','line_number':265,'multiline':True]
['text':' C99 ','line_number':270,'multiline':True]
['text':'!
 * XXH32():
 *  Calculate the 32-bit hash of sequence "length" bytes stored at memory address "input".
 *  The memory between input & input+length must be valid (allocated and read-accessible).
 *  "seed" can be used to alter the result predictably.
 *  Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark): 5.4 GB/s
 *
 * Note: XXH3 provides competitive speed for both 32-bit and 64-bit systems,
 * and offers true 64/128 bit hash results. It provides a superior level of
 * dispersion, and greatly reduces the risks of collisions.
 ','line_number':286,'multiline':True]
['text':'******   Streaming   ******','line_number':299,'multiline':True]
['text':'
 * Streaming functions generate the xxHash value from an incrememtal input.
 * This method is slower than single-call functions, due to state management.
 * For small inputs, prefer `XXH32()` and `XXH64()`, which are better optimized.
 *
 * An XXH state must first be allocated using `XXH*_createState()`.
 *
 * Start a new hash by initializing the state with a seed using `XXH*_reset()`.
 *
 * Then, feed the hash state by calling `XXH*_update()` as many times as necessary.
 *
 * The function returns an error code, with 0 meaning OK, and any other value
 * meaning there is an error.
 *
 * Finally, a hash value can be produced anytime, by using `XXH*_digest()`.
 * This function returns the nn-bits hash as an int or long long.
 *
 * It's still possible to continue inserting input into the hash state after a
 * digest, and generate new hash values later on by invoking `XXH*_digest()`.
 *
 * When done, release the state using `XXH*_freeState()`.
 ','line_number':301,'multiline':True]
['text':' incomplete type ','line_number':324,'multiline':True]
['text':'******   Canonical representation   ******','line_number':333,'multiline':True]
['text':'
 * The default return values from XXH functions are unsigned 32 and 64 bit
 * integers.
 * This the simplest and fastest format for further post-processing.
 *
 * However, this leaves open the question of what is the order on the byte level,
 * since little and big endian conventions will store the same number differently.
 *
 * The canonical representation settles this issue by mandating big-endian
 * convention, the same convention as human-readable numbers (large digits first).
 *
 * When writing hash values to storage, sending them over a network, or printing
 * them, it's highly recommended to use the canonical representation to ensure
 * portability across a wider range of systems, present and future.
 *
 * The following functions allow transformation of hash values to and from
 * canonical format.
 ','line_number':335,'multiline':True]
['text':'-**********************************************************************
*  64-bit hash
***********************************************************************','line_number':360,'multiline':True]
['text':' C99 ','line_number':365,'multiline':True]
['text':' the following type must have a width of 64-bit ','line_number':369,'multiline':True]
['text':'!
 * XXH64():
 * Returns the 64-bit hash of sequence of length @length stored at memory
 * address @input.
 * @seed can be used to alter the result predictably.
 *
 * This function usually runs faster on 64-bit systems, but slower on 32-bit
 * systems (see benchmark).
 *
 * Note: XXH3 provides competitive speed for both 32-bit and 64-bit systems,
 * and offers true 64/128 bit hash results. It provides a superior level of
 * dispersion, and greatly reduces the risks of collisions.
 ','line_number':373,'multiline':True]
['text':'******   Streaming   ******','line_number':388,'multiline':True]
['text':' incomplete type ','line_number':389,'multiline':True]
['text':'******   Canonical representation   ******','line_number':398,'multiline':True]
['text':'-**********************************************************************
*  XXH3 64-bit variant
***********************************************************************','line_number':404,'multiline':True]
['text':' ************************************************************************
 * XXH3 is a new hash algorithm featuring:
 *  - Improved speed for both small and large inputs
 *  - True 64-bit and 128-bit outputs
 *  - SIMD acceleration
 *  - Improved 32-bit viability
 *
 * Speed analysis methodology is explained here:
 *
 *    https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html
 *
 * In general, expect XXH3 to run about ~2x faster on large inputs and >3x
 * faster on small ones compared to XXH64, though exact differences depend on
 * the platform.
 *
 * The algorithm is portable: Like XXH32 and XXH64, it generates the same hash
 * on all platforms.
 *
 * It benefits greatly from SIMD and 64-bit arithmetic, but does not require it.
 *
 * Almost all 32-bit and 64-bit targets that can run XXH32 smoothly can run
 * XXH3 at competitive speeds, even if XXH64 runs slowly. Further details are
 * explained in the implementation.
 *
 * Optimized implementations are provided for AVX512, AVX2, SSE2, NEON, POWER8,
 * ZVector and scalar targets. This can be controlled with the XXH_VECTOR macro.
 *
 * XXH3 offers 2 variants, _64bits and _128bits.
 * When only 64 bits are needed, prefer calling the _64bits variant, as it
 * reduces the amount of mixing, resulting in faster speed on small inputs.
 *
 * It's also generally simpler to manipulate a scalar return type than a struct.
 *
 * The 128-bit version adds additional strength, but it is slightly slower.
 *
 * The XXH3 algorithm is still in development.
 * The results it produces may still change in future versions.
 *
 * Results produced by v0.7.x are not comparable with results from v0.7.y.
 * However, the API is completely stable, and it can safely be used for
 * ephemeral data (local sessions).
 *
 * Avoid storing values in long-term storage until the algorithm is finalized.
 * XXH3's return values will be officially finalized upon reaching v0.8.0.
 *
 * After which, return values of XXH3 and XXH128 will no longer change in
 * future versions.
 *
 * The API supports one-shot hashing, streaming mode, and custom secrets.
 ','line_number':408,'multiline':True]
['text':' XXH3_64bits():
 * default 64-bit variant, using default secret and default seed of 0.
 * It's the fastest variant. ','line_number':459,'multiline':True]
['text':'
 * XXH3_64bits_withSeed():
 * This variant generates a custom secret on the fly
 * based on default secret altered using the `seed` value.
 * While this operation is decently fast, note that it's not completely free.
 * Note: seed==0 produces the same results as XXH3_64bits().
 ','line_number':464,'multiline':True]
['text':'
 * XXH3_64bits_withSecret():
 * It's possible to provide any blob of bytes as a "secret" to generate the hash.
 * This makes it more difficult for an external actor to prepare an intentional collision.
 * The main condition is that secretSize *must* be large enough (>= XXH3_SECRET_SIZE_MIN).
 * However, the quality of produced hash values depends on secret's entropy.
 * Technically, the secret must look like a bunch of random bytes.
 * Avoid "trivial" or structured data such as repeated sequences or a text document.
 * Whenever unsure about the "randomness" of the blob of bytes,
 * consider relabelling it as a "custom seed" instead,
 * and employ "XXH3_generateSecret()" (see below)
 * to generate a high entropy secret derived from the custom seed.
 ','line_number':473,'multiline':True]
['text':'******   Streaming   ******','line_number':490,'multiline':True]
['text':'
 * Streaming requires state maintenance.
 * This operation costs memory and CPU.
 * As a consequence, streaming is slower than one-shot hashing.
 * For better performance, prefer one-shot functions whenever applicable.
 ','line_number':491,'multiline':True]
['text':'
 * XXH3_64bits_reset():
 * Initialize with default parameters.
 * digest will be equivalent to `XXH3_64bits()`.
 ','line_number':502,'multiline':True]
['text':'
 * XXH3_64bits_reset_withSeed():
 * Generate a custom secret from `seed`, and store it into `statePtr`.
 * digest will be equivalent to `XXH3_64bits_withSeed()`.
 ','line_number':508,'multiline':True]
['text':'
 * XXH3_64bits_reset_withSecret():
 * `secret` is referenced, it _must outlive_ the hash streaming session.
 * Similar to one-shot API, `secretSize` must be >= `XXH3_SECRET_SIZE_MIN`,
 * and the quality of produced hash values depends on secret's entropy
 * (secret's content should look like a bunch of random bytes).
 * When in doubt about the randomness of a candidate `secret`,
 * consider employing `XXH3_generateSecret()` instead (see below).
 ','line_number':514,'multiline':True]
['text':' note : canonical representation of XXH3 is the same as XXH64
 * since they both produce XXH64_hash_t values ','line_number':528,'multiline':True]
['text':'-**********************************************************************
*  XXH3 128-bit variant
***********************************************************************','line_number':532,'multiline':True]
['text':'******   Streaming   ******','line_number':545,'multiline':True]
['text':'
 * Streaming requires state maintenance.
 * This operation costs memory and CPU.
 * As a consequence, streaming is slower than one-shot hashing.
 * For better performance, prefer one-shot functions whenever applicable.
 *
 * XXH3_128bits uses the same XXH3_state_t as XXH3_64bits().
 * Use already declared XXH3_createState() and XXH3_freeState().
 *
 * All reset and streaming functions have same meaning as their 64-bit counterpart.
 ','line_number':546,'multiline':True]
['text':' Following helper functions make it possible to compare XXH128_hast_t values.
 * Since XXH128_hash_t is a structure, this capability is not offered by the language.
 * Note: For better performance, these functions can be inlined using XXH_INLINE_ALL ','line_number':565,'multiline':True]
['text':'!
 * XXH128_isEqual():
 * Return: 1 if `h1` and `h2` are equal, 0 if they are not.
 ','line_number':569,'multiline':True]
['text':'!
 * XXH128_cmp():
 *
 * This comparator is compatible with stdlib's `qsort()`/`bsearch()`.
 *
 * return: >0 if *h128_1  > *h128_2
 *         =0 if *h128_1 == *h128_2
 *         <0 if *h128_1  < *h128_2
 ','line_number':575,'multiline':True]
['text':'******   Canonical representation   ******','line_number':587,'multiline':True]
['text':' XXH_NO_LONG_LONG ','line_number':593,'multiline':True]
['text':' XXHASH_H_5627135585666179 ','line_number':595,'multiline':True]
['text':' ****************************************************************************
 * This section contains declarations which are not guaranteed to remain stable.
 * They may change in future versions, becoming incompatible with a different
 * version of the library.
 * These declarations should only be used with static linking.
 * Never use them in association with dynamic linking!
 ***************************************************************************** ','line_number':601,'multiline':True]
['text':'
 * These definitions are only present to allow static allocation
 * of XXH states, on stack or in a struct, for example.
 * Never **ever** access their members directly.
 ','line_number':609,'multiline':True]
['text':' never read nor write, might be removed in a future version ','line_number':624,'multiline':True]
['text':' typedef'd to XXH32_state_t ','line_number':625,'multiline':True]
['text':' defined when there is no 64-bit support ','line_number':628,'multiline':True]
['text':' required for padding anyway ','line_number':638,'multiline':True]
['text':' never read nor write, might be removed in a future version ','line_number':639,'multiline':True]
['text':' typedef'd to XXH64_state_t ','line_number':640,'multiline':True]
['text':' C11+ ','line_number':642,'multiline':True]
['text':' disabled ','line_number':650,'multiline':True]
['text':' Old GCC versions only accept the attribute after the type in structures. ','line_number':653,'multiline':True]
['text':' C11+ ','line_number':654,'multiline':True]
['text':' used to store a custom secret generated from a seed ','line_number':665,'multiline':True]
['text':' reference to external secret;
                                     * if == NULL, use .customSecret instead ','line_number':676,'multiline':True]
['text':' note: there may be some padding at the end due to alignment on 64 bytes ','line_number':678,'multiline':True]
['text':' typedef'd to XXH3_state_t ','line_number':679,'multiline':True]
['text':' When the XXH3_state_t structure is merely emplaced on stack,
 * it should be initialized with XXH3_INITSTATE() or a memset()
 * in case its first reset uses XXH3_NNbits_reset_withSeed().
 * This init can be omitted if the first reset uses default or _withSecret mode.
 * This operation isn't necessary when the state is created with XXH3_createState().
 * Note that this doesn't prepare the state for a streaming operation,
 * it's still necessary to use XXH3_NNbits_reset*() afterwards.
 ','line_number':683,'multiline':True]
['text':' ===   Experimental API   === ','line_number':694,'multiline':True]
['text':' Symbols defined below must be considered tied to a specific library version. ','line_number':695,'multiline':True]
['text':'
 * XXH3_generateSecret():
 *
 * Derive a high-entropy secret from any user-defined content, named customSeed.
 * The generated secret can be used in combination with `*_withSecret()` functions.
 * The `_withSecret()` variants are useful to provide a higher level of protection than 64-bit seed,
 * as it becomes much more difficult for an external actor to guess how to impact the calculation logic.
 *
 * The function accepts as input a custom seed of any length and any content,
 * and derives from it a high-entropy secret of length XXH3_SECRET_DEFAULT_SIZE
 * into an already allocated buffer secretBuffer.
 * The generated secret is _always_ XXH_SECRET_DEFAULT_SIZE bytes long.
 *
 * The generated secret can then be used with any `*_withSecret()` variant.
 * Functions `XXH3_128bits_withSecret()`, `XXH3_64bits_withSecret()`,
 * `XXH3_128bits_reset_withSecret()` and `XXH3_64bits_reset_withSecret()`
 * are part of this list. They all accept a `secret` parameter
 * which must be very long for implementation reasons (>= XXH3_SECRET_SIZE_MIN)
 * _and_ feature very high entropy (consist of random-looking bytes).
 * These conditions can be a high bar to meet, so
 * this function can be used to generate a secret of proper quality.
 *
 * customSeed can be anything. It can have any size, even small ones,
 * and its content can be anything, even stupidly "low entropy" source such as a bunch of zeroes.
 * The resulting `secret` will nonetheless provide all expected qualities.
 *
 * Supplying NULL as the customSeed copies the default secret into `secretBuffer`.
 * When customSeedSize > 0, supplying NULL as customSeed is undefined behavior.
 ','line_number':697,'multiline':True]
['text':' simple short-cut to pre-selected XXH3_128bits variant ','line_number':729,'multiline':True]
['text':' XXH_NO_LONG_LONG ','line_number':733,'multiline':True]
['text':' defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742) ','line_number':740,'multiline':True]
['text':' ======================================================================== ','line_number':743,'multiline':True]
['text':' ======================================================================== ','line_number':744,'multiline':True]
['text':' ======================================================================== ','line_number':745,'multiline':True]
['text':'-**********************************************************************
 * xxHash implementation
 *-**********************************************************************
 * xxHash's implementation used to be hosted inside xxhash.c.
 *
 * However, inlining requires implementation to be visible to the compiler,
 * hence be included alongside the header.
 * Previously, implementation was hosted inside xxhash.c,
 * which was then #included when inlining was activated.
 * This construction created issues with a few build and install systems,
 * as it required xxhash.c to be stored in /include directory.
 *
 * xxHash implementation is now directly integrated within xxhash.h.
 * As a consequence, xxhash.c is no longer needed in /include.
 *
 * xxhash.c is still available and is still useful.
 * In a "normal" setup, when xxhash is not inlined,
 * xxhash.h only exposes the prototypes and public symbols,
 * while xxhash.c can be built into an object file xxhash.o
 * which can then be linked into the final binary.
 ***********************************************************************','line_number':748,'multiline':True]
['text':' *************************************
*  Tuning parameters
**************************************','line_number':774,'multiline':True]
['text':'!
 * XXH_FORCE_MEMORY_ACCESS:
 * By default, access to unaligned memory is controlled by `memcpy()`, which is
 * safe and portable.
 *
 * Unfortunately, on some target/compiler combinations, the generated assembly
 * is sub-optimal.
 *
 * The below switch allow selection of a different access method
 * in the search for improved performance.
 * Method 0 (default):
 *     Use `memcpy()`. Safe and portable. Default.
 * Method 1:
 *     `__attribute__((packed))` statement. It depends on compiler extensions
 *     and is therefore not portable.
 *     This method is safe if your compiler supports it, and *generally* as
 *     fast or faster than `memcpy`.
 * Method 2:
 *     Direct access via cast. This method doesn't depend on the compiler but
 *     violates the C standard.
 *     It can generate buggy code on targets which do not support unaligned
 *     memory accesses.
 *     But in some circumstances, it's the only known way to get the most
 *     performance (example: GCC + ARMv6)
 * Method 3:
 *     Byteshift. This can generate the best code on old compilers which don't
 *     inline small `memcpy()` calls, and it might also be faster on big-endian
 *     systems which lack a native byteswap instruction.
 * See https://stackoverflow.com/a/32095106/646947 for details.
 * Prefer these methods in priority order (0 > 1 > 2 > 3)
 ','line_number':777,'multiline':True]
['text':' can be defined externally, on command line for example ','line_number':808,'multiline':True]
['text':'!
 * XXH_ACCEPT_NULL_INPUT_POINTER:
 * If the input pointer is NULL, xxHash's default behavior is to dereference it,
 * triggering a segfault.
 * When this macro is enabled, xxHash actively checks the input for a null pointer.
 * If it is, the result for null input pointers is the same as a zero-length input.
 ','line_number':817,'multiline':True]
['text':' can be defined externally ','line_number':824,'multiline':True]
['text':'!
 * XXH_FORCE_ALIGN_CHECK:
 * This is an important performance trick
 * for architectures without decent unaligned memory access performance.
 * It checks for input alignment, and when conditions are met,
 * uses a "fast path" employing direct 32-bit/64-bit read,
 * resulting in _dramatically faster_ read speed.
 *
 * The check costs one initial branch per hash, which is generally negligible, but not zero.
 * Moreover, it's not useful to generate binary for an additional code path
 * if memory access uses same instruction for both aligned and unaligned adresses.
 *
 * In these cases, the alignment check can be removed by setting this macro to 0.
 * Then the code will always use unaligned memory access.
 * Align check is automatically disabled on x86, x64 & arm64,
 * which are platforms known to offer good unaligned memory accesses performance.
 *
 * This option does not affect XXH3 (only XXH32 and XXH64).
 ','line_number':828,'multiline':True]
['text':' can be defined externally ','line_number':847,'multiline':True]
['text':' visual ','line_number':849,'multiline':True]
['text':'!
 * XXH_NO_INLINE_HINTS:
 *
 * By default, xxHash tries to force the compiler to inline almost all internal
 * functions.
 *
 * This can usually improve performance due to reduced jumping and improved
 * constant folding, but significantly increases the size of the binary which
 * might not be favorable.
 *
 * Additionally, sometimes the forced inlining can be detrimental to performance,
 * depending on the architecture.
 *
 * XXH_NO_INLINE_HINTS marks all internal functions as static, giving the
 * compiler full control on whether to inline or not.
 *
 * When not optimizing (-O0), optimizing for size (-Os, -Oz), or using
 * -fno-inline with GCC or Clang, this will automatically be defined.
 ','line_number':856,'multiline':True]
['text':' -Os, -Oz ','line_number':876,'multiline':True]
['text':' -O0, -fno-inline ','line_number':877,'multiline':True]
['text':'!
 * XXH_REROLL:
 * Whether to reroll XXH32_finalize, and XXH64_finalize,
 * instead of using an unrolled jump table/if statement loop.
 *
 * This is automatically defined on -Os/-Oz on GCC and Clang.
 ','line_number':884,'multiline':True]
['text':' *************************************
*  Includes & Memory related functions
**************************************','line_number':900,'multiline':True]
['text':'!
 * Modify the local functions below should you wish to use
 * different memory routines for malloc() and free()
 ','line_number':903,'multiline':True]
['text':'! and for memcpy() ','line_number':912,'multiline':True]
['text':' ULLONG_MAX ','line_number':919,'multiline':True]
['text':' *************************************
*  Compiler Specific Options
**************************************','line_number':922,'multiline':True]
['text':' Visual Studio warning fix ','line_number':925,'multiline':True]
['text':' disable: C4127: conditional expression is constant ','line_number':926,'multiline':True]
['text':' disable inlining hints ','line_number':929,'multiline':True]
['text':' enable inlining hints ','line_number':936,'multiline':True]
['text':' Visual Studio ','line_number':937,'multiline':True]
['text':' C99 ','line_number':944,'multiline':True]
['text':' *************************************
*  Debug
**************************************','line_number':954,'multiline':True]
['text':'
 * XXH_DEBUGLEVEL is expected to be defined externally, typically via the
 * compiler's command line options. The value must be a number.
 ','line_number':957,'multiline':True]
['text':' backwards compat ','line_number':962,'multiline':True]
['text':' note: can still be disabled with NDEBUG ','line_number':970,'multiline':True]
['text':' note: use after variable declarations ','line_number':976,'multiline':True]
['text':' *************************************
*  Basic Types
**************************************','line_number':980,'multiline':True]
['text':' C99 ','line_number':985,'multiline':True]
['text':' ***   Memory access   *** ','line_number':999,'multiline':True]
['text':'
 * Manual byteshift. Best for old compilers which don't inline memcpy.
 * We actually directly use XXH_readLE32 and XXH_readBE32.
 ','line_number':1002,'multiline':True]
['text':'
 * Force direct memory access. Only works on CPU which support unaligned memory
 * access in hardware.
 ','line_number':1008,'multiline':True]
['text':'
 * __pack instructions are safer but compiler specific, hence potentially
 * problematic for some compilers.
 *
 * Currently only defined for GCC and ICC.
 ','line_number':1016,'multiline':True]
['text':'
 * Portable and safe solution. Generally efficient.
 * see: https://stackoverflow.com/a/32095106/646947
 ','line_number':1033,'multiline':True]
['text':' XXH_FORCE_DIRECT_MEMORY_ACCESS ','line_number':1044,'multiline':True]
['text':' ***   Endianess   *** ','line_number':1047,'multiline':True]
['text':'!
 * XXH_CPU_LITTLE_ENDIAN:
 * Defined to 1 if the target is little endian, or 0 if it is big endian.
 * It can be defined externally, for example on the compiler command line.
 *
 * If it is not defined, a runtime check (which is usually constant folded)
 * is used instead.
 ','line_number':1050,'multiline':True]
['text':'
 * Try to detect endianness automatically, to avoid the nonstandard behavior
 * in `XXH_isLittleEndian()`
 ','line_number':1059,'multiline':True]
['text':' Windows is always little endian ','line_number':1063,'multiline':True]
['text':'
 * runtime test, presumed to simplify to a constant by compiler
 ','line_number':1071,'multiline':True]
['text':'
     * Portable and well-defined behavior.
     * Don't use static: it is detrimental to performance.
     ','line_number':1076,'multiline':True]
['text':' ****************************************
*  Compiler-specific Functions and Macros
*****************************************','line_number':1090,'multiline':True]
['text':' Note: although _rotl exists for minGW (GCC under windows), performance seems poor ','line_number':1105,'multiline':True]
['text':' Visual Studio ','line_number':1114,'multiline':True]
['text':' ***************************
*  Memory reads
****************************','line_number':1129,'multiline':True]
['text':'
 * XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load.
 *
 * This is ideal for older compilers which don't inline memcpy.
 ','line_number':1134,'multiline':True]
['text':' *************************************
*  Misc
**************************************','line_number':1182,'multiline':True]
['text':' *******************************************************************
*  32-bit hash functions
********************************************************************','line_number':1188,'multiline':True]
['text':' 0b10011110001101110111100110110001 ','line_number':1191,'multiline':True]
['text':' 0b10000101111010111100101001110111 ','line_number':1192,'multiline':True]
['text':' 0b11000010101100101010111000111101 ','line_number':1193,'multiline':True]
['text':' 0b00100111110101001110101100101111 ','line_number':1194,'multiline':True]
['text':' 0b00010110010101100110011110110001 ','line_number':1195,'multiline':True]
['text':'
     * UGLY HACK:
     * This inline assembly hack forces acc into a normal register. This is the
     * only thing that prevents GCC and Clang from autovectorizing the XXH32
     * loop (pragmas and attributes don't work for some resason) without globally
     * disabling SSE4.1.
     *
     * The reason we want to avoid vectorization is because despite working on
     * 4 integers at a time, there are multiple factors slowing XXH32 down on
     * SSE4:
     * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on
     *   newer chips!) making it slightly slower to multiply four integers at
     *   once compared to four integers independently. Even when pmulld was
     *   fastest, Sandy/Ivy Bridge, it is still not worth it to go into SSE
     *   just to multiply unless doing a long operation.
     *
     * - Four instructions are required to rotate,
     *      movqda tmp,  v // not required with VEX encoding
     *      pslld  tmp, 13 // tmp <<= 13
     *      psrld  v,   19 // x >>= 19
     *      por    v,  tmp // x |= tmp
     *   compared to one for scalar:
     *      roll   v, 13    // reliably fast across the board
     *      shldl  v, v, 13 // Sandy Bridge and later prefer this for some reason
     *
     * - Instruction level parallelism is actually more beneficial here because
     *   the SIMD actually serializes this operation: While v1 is rotating, v2
     *   can load data, while v3 can multiply. SSE forces them to operate
     *   together.
     *
     * How this hack works:
     * __asm__(""       // Declare an assembly block but don't declare any instructions
     *          :       // However, as an Input/Output Operand,
     *          "+r"    // constrain a read/write operand (+) as a general purpose register (r).
     *          (acc)   // and set acc as the operand
     * );
     *
     * Because of the 'r', the compiler has promised that seed will be in a
     * general purpose register and the '+' says that it will be 'read/write',
     * so it has to assume it has changed. It is like volatile without all the
     * loads and stores.
     *
     * Since the argument has to be in a normal register (not an SSE register),
     * each time XXH32_round is called, it is impossible to vectorize.
     ','line_number':1211,'multiline':True]
['text':' mix all bits ','line_number':1261,'multiline':True]
['text':' Compact rerolled version ','line_number':1288,'multiline':True]
['text':' or switch(bEnd - p) ','line_number':1301,'multiline':True]
['text':' fallthrough ','line_number':1303,'multiline':True]
['text':' fallthrough ','line_number':1305,'multiline':True]
['text':' fallthrough ','line_number':1310,'multiline':True]
['text':' fallthrough ','line_number':1312,'multiline':True]
['text':' fallthrough ','line_number':1318,'multiline':True]
['text':' fallthrough ','line_number':1320,'multiline':True]
['text':' fallthrough ','line_number':1327,'multiline':True]
['text':' fallthrough ','line_number':1329,'multiline':True]
['text':' fallthrough ','line_number':1331,'multiline':True]
['text':' fallthrough ','line_number':1333,'multiline':True]
['text':' fallthrough ','line_number':1335,'multiline':True]
['text':' fallthrough ','line_number':1337,'multiline':True]
['text':' reaching this point is deemed impossible ','line_number':1341,'multiline':True]
['text':' Simple version, good for code maintenance, but unfortunately slow for small inputs ','line_number':1395,'multiline':True]
['text':' Input is 4-bytes aligned, leverage the speed benefit ','line_number':1404,'multiline':True]
['text':'******   Hash streaming   ******','line_number':1414,'multiline':True]
['text':' using a local state to memcpy() in order to avoid strict-aliasing warnings ','line_number':1433,'multiline':True]
['text':' do not write into reserved, planned to be removed in a future version ','line_number':1439,'multiline':True]
['text':' fill in tmp buffer ','line_number':1461,'multiline':True]
['text':' some data left from previous update ','line_number':1467,'multiline':True]
['text':' == seed ','line_number':1519,'multiline':True]
['text':'******   Canonical representation   ******','line_number':1528,'multiline':True]
['text':'
 * The default return values from XXH functions are unsigned 32 and 64 bit
 * integers.
 *
 * The canonical representation uses big endian convention, the same convention
 * as human-readable numbers (large digits first).
 *
 * This way, hash values can be written into a file or buffer, remaining
 * comparable across different systems.
 *
 * The following functions allow transformation of hash values to and from their
 * canonical format.
 ','line_number':1530,'multiline':True]
['text':' *******************************************************************
*  64-bit hash functions
********************************************************************','line_number':1558,'multiline':True]
['text':'******   Memory access   ******','line_number':1562,'multiline':True]
['text':'!
 * XXH_REROLL_XXH64:
 * Whether to reroll the XXH64_finalize() loop.
 *
 * Just like XXH32, we can unroll the XXH64_finalize() loop. This can be a
 * performance gain on 64-bit hosts, as only one jump is required.
 *
 * However, on 32-bit hosts, because arithmetic needs to be done with two 32-bit
 * registers, and 64-bit arithmetic needs to be simulated, it isn't beneficial
 * to unroll. The code becomes ridiculously large (the largest function in the
 * binary on i386!), and rerolling it saves anywhere from 3kB to 20kB. It is
 * also slightly faster because it fits into cache better and is more likely
 * to be inlined by the compiler.
 *
 * If XXH_REROLL is defined, this is ignored and the loop is always rerolled.
 ','line_number':1570,'multiline':True]
['text':' ILP32 is often defined on 32-bit GCC family ','line_number':1587,'multiline':True]
['text':' x86-64 ','line_number':1588,'multiline':True]
['text':' aarch64 ','line_number':1589,'multiline':True]
['text':' ppc64 ','line_number':1590,'multiline':True]
['text':' mips64 ','line_number':1591,'multiline':True]
['text':' check limits ','line_number':1592,'multiline':True]
['text':' !defined(XXH_REROLL_XXH64) ','line_number':1597,'multiline':True]
['text':'
 * Manual byteshift. Best for old compilers which don't inline memcpy.
 * We actually directly use XXH_readLE64 and XXH_readBE64.
 ','line_number':1600,'multiline':True]
['text':' Force direct memory access. Only works on CPU which support unaligned memory access in hardware ','line_number':1606,'multiline':True]
['text':'
 * __pack instructions are safer, but compiler specific, hence potentially
 * problematic for some compilers.
 *
 * Currently only defined for GCC and ICC.
 ','line_number':1611,'multiline':True]
['text':'
 * Portable and safe solution. Generally efficient.
 * see: https://stackoverflow.com/a/32095106/646947
 ','line_number':1628,'multiline':True]
['text':' XXH_FORCE_DIRECT_MEMORY_ACCESS ','line_number':1639,'multiline':True]
['text':' Visual Studio ','line_number':1641,'multiline':True]
['text':' XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load. ','line_number':1660,'multiline':True]
['text':'******   xxh64   ******','line_number':1711,'multiline':True]
['text':' 0b1001111000110111011110011011000110000101111010111100101010000111 ','line_number':1713,'multiline':True]
['text':' 0b1100001010110010101011100011110100100111110101001110101101001111 ','line_number':1714,'multiline':True]
['text':' 0b0001011001010110011001111011000110011110001101110111100111111001 ','line_number':1715,'multiline':True]
['text':' 0b1000010111101011110010100111011111000010101100101010111001100011 ','line_number':1716,'multiline':True]
['text':' 0b0010011111010100111010110010111100010110010101100110011111000101 ','line_number':1717,'multiline':True]
['text':' Rerolled version for 32-bit targets is faster and much smaller. ','line_number':1777,'multiline':True]
['text':' fallthrough ','line_number':1796,'multiline':True]
['text':' fallthrough ','line_number':1798,'multiline':True]
['text':' fallthrough ','line_number':1803,'multiline':True]
['text':' fallthrough ','line_number':1805,'multiline':True]
['text':' fallthrough ','line_number':1807,'multiline':True]
['text':' fallthrough ','line_number':1812,'multiline':True]
['text':' fallthrough ','line_number':1814,'multiline':True]
['text':' fallthrough ','line_number':1820,'multiline':True]
['text':' fallthrough ','line_number':1822,'multiline':True]
['text':' fallthrough ','line_number':1824,'multiline':True]
['text':' fallthrough ','line_number':1830,'multiline':True]
['text':' fallthrough ','line_number':1832,'multiline':True]
['text':' fallthrough ','line_number':1839,'multiline':True]
['text':' fallthrough ','line_number':1841,'multiline':True]
['text':' fallthrough ','line_number':1843,'multiline':True]
['text':' fallthrough ','line_number':1850,'multiline':True]
['text':' fallthrough ','line_number':1852,'multiline':True]
['text':' fallthrough ','line_number':1860,'multiline':True]
['text':' fallthrough ','line_number':1862,'multiline':True]
['text':' fallthrough ','line_number':1864,'multiline':True]
['text':' fallthrough ','line_number':1866,'multiline':True]
['text':' fallthrough ','line_number':1868,'multiline':True]
['text':' fallthrough ','line_number':1870,'multiline':True]
['text':' fallthrough ','line_number':1872,'multiline':True]
['text':' impossible to reach ','line_number':1876,'multiline':True]
['text':' unreachable, but some compilers complain without it ','line_number':1878,'multiline':True]
['text':' Simple version, good for code maintenance, but unfortunately slow for small inputs ','line_number':1937,'multiline':True]
['text':' Input is aligned, let's leverage the speed advantage ','line_number':1946,'multiline':True]
['text':'******   Hash Streaming   ******','line_number':1955,'multiline':True]
['text':' use a local state to memcpy() in order to avoid strict-aliasing warnings ','line_number':1974,'multiline':True]
['text':' do not write into reserved64, might be removed in a future version ','line_number':1980,'multiline':True]
['text':' fill in tmp buffer ','line_number':2000,'multiline':True]
['text':' tmp buffer is full ','line_number':2006,'multiline':True]
['text':'seed','line_number':2062,'multiline':True]
['text':'****** Canonical representation   ******','line_number':2071,'multiline':True]
['text':' *********************************************************************
*  XXH3
*  New generation hash designed for speed on small keys and vectorization
************************************************************************ ','line_number':2087,'multiline':True]
['text':' ===   Compiler specifics   === ','line_number':2092,'multiline':True]
['text':' >= C99 ','line_number':2094,'multiline':True]
['text':' Note: it might be useful to define __restrict or __restrict__ for some C++ compilers ','line_number':2097,'multiline':True]
['text':' disable ','line_number':2098,'multiline':True]
['text':' circumvent a clang bug ','line_number':2117,'multiline':True]
['text':'
 * One goal of XXH3 is to make it fast on both 32-bit and 64-bit, while
 * remaining a true 64-bit/128-bit hash function.
 *
 * This is done by prioritizing a subset of 64-bit operations that can be
 * emulated without too many steps on the average 32-bit machine.
 *
 * For example, these two lines seem similar, and run equally fast on 64-bit:
 *
 *   xxh_u64 x;
 *   x ^= (x >> 47); // good
 *   x ^= (x >> 13); // bad
 *
 * However, to a 32-bit machine, there is a major difference.
 *
 * x ^= (x >> 47) looks like this:
 *
 *   x.lo ^= (x.hi >> (47 - 32));
 *
 * while x ^= (x >> 13) looks like this:
 *
 *   // note: funnel shifts are not usually cheap.
 *   x.lo ^= (x.lo >> 13) | (x.hi << (32 - 13));
 *   x.hi ^= (x.hi >> 13);
 *
 * The first one is significantly faster than the second, simply because the
 * shift is larger than 32. This means:
 *  - All the bits we need are in the upper 32 bits, so we can ignore the lower
 *    32 bits in the shift.
 *  - The shift result will always fit in the lower 32 bits, and therefore,
 *    we can ignore the upper 32 bits in the xor.
 *
 * Thanks to this optimization, XXH3 only requires these features to be efficient:
 *
 *  - Usable unaligned access
 *  - A 32-bit or 64-bit ALU
 *      - If 32-bit, a decent ADC instruction
 *  - A 32 or 64-bit multiply with a 64-bit result
 *  - For the 128-bit variant, a decent byteswap helps short inputs.
 *
 * The first two are already required by XXH32, and almost all 32-bit and 64-bit
 * platforms which can run XXH32 can run XXH3 efficiently.
 *
 * Thumb-1, the classic 16-bit only subset of ARM's instruction set, is one
 * notable exception.
 *
 * First of all, Thumb-1 lacks support for the UMULL instruction which
 * performs the important long multiply. This means numerous __aeabi_lmul
 * calls.
 *
 * Second of all, the 8 functional registers are just not enough.
 * Setup for __aeabi_lmul, byteshift loads, pointers, and all arithmetic need
 * Lo registers, and this shuffling results in thousands more MOVs than A32.
 *
 * A32 and T32 don't have this limitation. They can access all 14 registers,
 * do a 32->64 multiply with UMULL, and the flexible operand allowing free
 * shifts is helpful, too.
 *
 * Therefore, we do a quick sanity check.
 *
 * If compiling Thumb-1 for a target which supports ARM instructions, we will
 * emit a warning, as it is not a "sane" platform to compile for.
 *
 * Usually, if this happens, it is because of an accident and you probably need
 * to specify -march, as you likely meant to compile for a newer architecture.
 *
 * Credit: large sections of the vectorial and asm source code paths
 *         have been contributed by @easyaspi314
 ','line_number':2125,'multiline':True]
['text':' ==========================================
 * Vectorization detection
 * ========================================== ','line_number':2198,'multiline':True]
['text':' Portable scalar version ','line_number':2201,'multiline':True]
['text':' SSE2 for Pentium 4 and all x86_64 ','line_number':2202,'multiline':True]
['text':' AVX2 for Haswell and Bulldozer ','line_number':2203,'multiline':True]
['text':' AVX512 for Skylake and Icelake ','line_number':2204,'multiline':True]
['text':' NEON for most ARMv7-A and all AArch64 ','line_number':2205,'multiline':True]
['text':' VSX and ZVector for POWER8/z13 ','line_number':2206,'multiline':True]
['text':' can be defined on command line ','line_number':2208,'multiline':True]
['text':' msvc support maybe later ','line_number':2215,'multiline':True]
['text':' We only support little endian NEON ','line_number':2217,'multiline':True]
['text':' TODO: IBM XL ','line_number':2222,'multiline':True]
['text':'
 * Controls the alignment of the accumulator,
 * for compatibility with aligned vector loads, which are usually faster.
 ','line_number':2229,'multiline':True]
['text':' for compatibility with avx512 ','line_number':2235,'multiline':True]
['text':' scalar ','line_number':2236,'multiline':True]
['text':' sse2 ','line_number':2238,'multiline':True]
['text':' avx2 ','line_number':2240,'multiline':True]
['text':' neon ','line_number':2242,'multiline':True]
['text':' vsx ','line_number':2244,'multiline':True]
['text':' avx512 ','line_number':2246,'multiline':True]
['text':'
 * UGLY HACK:
 * GCC usually generates the best code with -O3 for xxHash.
 *
 * However, when targeting AVX2, it is overzealous in its unrolling resulting
 * in code roughly 3/4 the speed of Clang.
 *
 * There are other issues, such as GCC splitting _mm256_loadu_si256 into
 * _mm_loadu_si128 + _mm256_inserti128_si256. This is an optimization which
 * only applies to Sandy and Ivy Bridge... which don't even support AVX2.
 *
 * That is why when compiling the AVX2 version, it is recommended to use either
 *   -O2 -mavx2 -march=haswell
 * or
 *   -O2 -mavx2 -mno-avx256-split-unaligned-load
 * for decent performance, or to use Clang instead.
 *
 * Fortunately, we can control the first one with a pragma that forces GCC into
 * -O2, but the other one we can't control without "failed to inline always
 * inline function due to target mismatch" warnings.
 ','line_number':2258,'multiline':True]
['text':' AVX2 ','line_number':2279,'multiline':True]
['text':' GCC, not Clang ','line_number':2280,'multiline':True]
['text':' respect -O0 and -Os ','line_number':2281,'multiline':True]
['text':'
 * NEON's setup for vmlal_u32 is a little more complicated than it is on
 * SSE2, AVX2, and VSX.
 *
 * While PMULUDQ and VMULEUW both perform a mask, VMLAL.U32 performs an upcast.
 *
 * To do the same operation, the 128-bit 'Q' register needs to be split into
 * two 64-bit 'D' registers, performing this operation::
 *
 *   [                a                 |                 b                ]
 *            |              '---------. .--------'                |
 *            |                         x                          |
 *            |              .---------' '--------.                |
 *   [ a & 0xFFFFFFFF | b & 0xFFFFFFFF ],[    a >> 32     |     b >> 32    ]
 *
 * Due to significant changes in aarch64, the fastest method for aarch64 is
 * completely different than the fastest method for ARMv7-A.
 *
 * ARMv7-A treats D registers as unions overlaying Q registers, so modifying
 * D11 will modify the high half of Q5. This is similar to how modifying AH
 * will only affect bits 8-15 of AX on x86.
 *
 * VZIP takes two registers, and puts even lanes in one register and odd lanes
 * in the other.
 *
 * On ARMv7-A, this strangely modifies both parameters in place instead of
 * taking the usual 3-operand form.
 *
 * Therefore, if we want to do this, we can simply use a D-form VZIP.32 on the
 * lower and upper halves of the Q register to end up with the high and low
 * halves where we want - all in one instruction.
 *
 *   vzip.32   d10, d11       @ d10 = { d10[0], d11[0] }; d11 = { d10[1], d11[1] }
 *
 * Unfortunately we need inline assembly for this: Instructions modifying two
 * registers at once is not possible in GCC or Clang's IR, and they have to
 * create a copy.
 *
 * aarch64 requires a different approach.
 *
 * In order to make it easier to write a decent compiler for aarch64, many
 * quirks were removed, such as conditional execution.
 *
 * NEON was also affected by this.
 *
 * aarch64 cannot access the high bits of a Q-form register, and writes to a
 * D-form register zero the high bits, similar to how writes to W-form scalar
 * registers (or DWORD registers on x86_64) work.
 *
 * The formerly free vget_high intrinsics now require a vext (with a few
 * exceptions)
 *
 * Additionally, VZIP was replaced by ZIP1 and ZIP2, which are the equivalent
 * of PUNPCKL* and PUNPCKH* in SSE, respectively, in order to only modify one
 * operand.
 *
 * The equivalent of the VZIP.32 on the lower and upper halves would be this
 * mess:
 *
 *   ext     v2.4s, v0.4s, v0.4s, #2 // v2 = { v0[2], v0[3], v0[0], v0[1] }
 *   zip1    v1.2s, v0.2s, v2.2s     // v1 = { v0[0], v2[0] }
 *   zip2    v0.2s, v0.2s, v1.2s     // v0 = { v0[1], v2[1] }
 *
 * Instead, we use a literal downcast, vmovn_u64 (XTN), and vshrn_n_u64 (SHRN):
 *
 *   shrn    v1.2s, v0.2d, #32  // v1 = (uint32x2_t)(v0 >> 32);
 *   xtn     v0.2s, v0.2d       // v0 = (uint32x2_t)(v0 & 0xFFFFFFFF);
 *
 * This is available on ARMv7-A, but is less efficient than a single VZIP.32.
 ','line_number':2288,'multiline':True]
['text':'
 * Function-like macro:
 * void XXH_SPLIT_IN_PLACE(uint64x2_t &in, uint32x2_t &outLo, uint32x2_t &outHi)
 * {
 *     outLo = (uint32x2_t)(in & 0xFFFFFFFF);
 *     outHi = (uint32x2_t)(in >> 32);
 *     in = UNDEFINED;
 * }
 ','line_number':2359,'multiline':True]
['text':' define to disable ','line_number':2368,'multiline':True]
['text':' Undocumented GCC/Clang operand modifier: %e0 = lower D half, %f0 = upper D half ','line_number':2373,'multiline':True]
['text':' https://github.com/gcc-mirror/gcc/blob/38cf91e5/gcc/config/arm/arm.c#L22486 ','line_number':2374,'multiline':True]
['text':' https://github.com/llvm-mirror/llvm/blob/2c4ca683/lib/Target/ARM/ARMAsmPrinter.cpp#L399 ','line_number':2375,'multiline':True]
['text':' XXH_VECTOR == XXH_NEON ','line_number':2387,'multiline':True]
['text':'
 * VSX and Z Vector helpers.
 *
 * This is very messy, and any pull requests to clean this up are welcome.
 *
 * There are a lot of problems with supporting VSX and s390x, due to
 * inconsistent intrinsics, spotty coverage, and multiple endiannesses.
 ','line_number':2389,'multiline':True]
['text':' gcc's altivec.h can have the unwanted consequence to unconditionally
 * #define bool, vector, and pixel keywords,
 * with bad consequences for programs already using these keywords for other purposes.
 * The paragraph defining these macros is skipped when __APPLE_ALTIVEC__ is defined.
 * __APPLE_ALTIVEC__ is _generally_ defined automatically by the compiler,
 * but it seems that, in some cases, it isn't.
 * Force the build macro to be defined, so that keywords are not altered.
 ','line_number':2401,'multiline':True]
['text':' !defined(XXH_VSX_BE) ','line_number':2429,'multiline':True]
['text':' A wrapper for POWER9's vec_revb. ','line_number':2432,'multiline':True]
['text':' XXH_VSX_BE ','line_number':2443,'multiline':True]
['text':'
 * Performs an unaligned load and byte swaps it on big endian.
 ','line_number':2445,'multiline':True]
['text':'
 * vec_mulo and vec_mule are very problematic intrinsics on PowerPC
 *
 * These intrinsics weren't added until GCC 8, despite existing for a while,
 * and they are endian dependent. Also, their meaning swap depending on version.
 * ','line_number':2458,'multiline':True]
['text':' s390x is always big endian, no issue on this platform ','line_number':2465,'multiline':True]
['text':' Clang has a better way to control this, we can just use the builtin which doesn't swap. ','line_number':2469,'multiline':True]
['text':' gcc needs inline assembly ','line_number':2473,'multiline':True]
['text':' Adapted from https://github.com/google/highwayhash/blob/master/highwayhash/hh_vsx.h. ','line_number':2474,'multiline':True]
['text':' XXH_vec_mulo, XXH_vec_mule ','line_number':2487,'multiline':True]
['text':' XXH_VECTOR == XXH_VSX ','line_number':2488,'multiline':True]
['text':' prefetch
 * can be disabled, by declaring XXH_NO_PREFETCH build macro ','line_number':2491,'multiline':True]
['text':' disabled ','line_number':2494,'multiline':True]
['text':' _mm_prefetch() is not defined outside of x86/x64 ','line_number':2496,'multiline':True]
['text':' https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx ','line_number':2497,'multiline':True]
['text':' rw==read ','line_number':2500,'multiline':True]
['text':' locality ','line_number':2500,'multiline':True]
['text':' disabled ','line_number':2502,'multiline':True]
['text':' XXH_NO_PREFETCH ','line_number':2504,'multiline':True]
['text':' ==========================================
 * XXH3 default settings
 * ========================================== ','line_number':2507,'multiline':True]
['text':' minimum XXH3_SECRET_SIZE_MIN ','line_number':2511,'multiline':True]
['text':' Pseudorandom secret taken directly from FARSH ','line_number':2517,'multiline':True]
['text':'
 * Calculates a 32-bit to 64-bit long multiply.
 *
 * Wraps __emulu on MSVC x86 because it tends to call __allmul when it doesn't
 * need to (but it shouldn't need to anyways, it is about 7 instructions to do
 * a 64x64 multiply...). Since we know that this will _always_ emit MULL, we
 * use that instead of the normal method.
 *
 * If you are compiling for platforms like Thumb-1 and don't have a better option,
 * you may also want to write your own long multiply routine here.
 *
 * XXH_FORCE_INLINE xxh_u64 XXH_mult32to64(xxh_u64 x, xxh_u64 y)
 * {
 *    return (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF);
 * }
 ','line_number':2538,'multiline':True]
['text':'
 * Downcast + upcast is usually better than masking on older compilers like
 * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.
 *
 * The other method, (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF), will AND both operands
 * and perform a full 64x64 multiply -- entirely redundant on 32-bit.
 ','line_number':2558,'multiline':True]
['text':'
 * Calculates a 64->128-bit long multiply.
 *
 * Uses __uint128_t and _umul128 if available, otherwise uses a scalar version.
 ','line_number':2568,'multiline':True]
['text':'
     * GCC/Clang __uint128_t method.
     *
     * On most 64-bit targets, GCC and Clang define a __uint128_t type.
     * This is usually the best way as it usually uses a native long 64-bit
     * multiply, such as MULQ on x86_64 or MUL + UMULH on aarch64.
     *
     * Usually.
     *
     * Despite being a 32-bit platform, Clang (and emscripten) define this type
     * despite not having the arithmetic for it. This results in a laggy
     * compiler builtin call which calculates a full 128-bit multiply.
     * In that case it is best to use the portable one.
     * https://github.com/Cyan4973/xxHash/issues/211#issuecomment-515575677
     ','line_number':2576,'multiline':True]
['text':'
     * MSVC for x64's _umul128 method.
     *
     * xxh_u64 _umul128(xxh_u64 Multiplier, xxh_u64 Multiplicand, xxh_u64 *HighProduct);
     *
     * This compiles to single operand MUL on x64.
     ','line_number':2601,'multiline':True]
['text':'
     * Portable scalar method. Optimized for 32-bit and 64-bit ALUs.
     *
     * This is a fast and simple grade school multiply, which is shown below
     * with base 10 arithmetic instead of base 0x100000000.
     *
     *           9 3 // D2 lhs = 93
     *         x 7 5 // D2 rhs = 75
     *     ----------
     *           1 5 // D2 lo_lo = (93 % 10) * (75 % 10) = 15
     *         4 5 | // D2 hi_lo = (93 / 10) * (75 % 10) = 45
     *         2 1 | // D2 lo_hi = (93 % 10) * (75 / 10) = 21
     *     + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10) = 63
     *     ---------
     *         2 7 | // D2 cross = (15 / 10) + (45 % 10) + 21 = 27
     *     + 6 7 | | // D2 upper = (27 / 10) + (45 / 10) + 63 = 67
     *     ---------
     *       6 9 7 5 // D4 res = (27 * 10) + (15 % 10) + (67 * 100) = 6975
     *
     * The reasons for adding the products like this are:
     *  1. It avoids manual carry tracking. Just like how
     *     (9 * 9) + 9 + 9 = 99, the same applies with this for UINT64_MAX.
     *     This avoids a lot of complexity.
     *
     *  2. It hints for, and on Clang, compiles to, the powerful UMAAL
     *     instruction available in ARM's Digital Signal Processing extension
     *     in 32-bit ARMv6 and later, which is shown below:
     *
     *         void UMAAL(xxh_u32 *RdLo, xxh_u32 *RdHi, xxh_u32 Rn, xxh_u32 Rm)
     *         {
     *             xxh_u64 product = (xxh_u64)*RdLo * (xxh_u64)*RdHi + Rn + Rm;
     *             *RdLo = (xxh_u32)(product & 0xFFFFFFFF);
     *             *RdHi = (xxh_u32)(product >> 32);
     *         }
     *
     *     This instruction was designed for efficient long multiplication, and
     *     allows this to be calculated in only 4 instructions at speeds
     *     comparable to some 64-bit ALUs.
     *
     *  3. It isn't terrible on other platforms. Usually this will be a couple
     *     of 32-bit ADD/ADCs.
     ','line_number':2621,'multiline':True]
['text':' First calculate all of the cross products. ','line_number':2664,'multiline':True]
['text':' Now add the products together. These will never overflow. ','line_number':2670,'multiline':True]
['text':'
 * Does a 64-bit to 128-bit multiply, then XOR folds it.
 *
 * The reason for the separate function is to prevent passing too many structs
 * around by value. This will hopefully inline the multiply, but we don't force it.
 ','line_number':2682,'multiline':True]
['text':' Seems to produce slightly better code on GCC for some reason. ','line_number':2695,'multiline':True]
['text':'
 * This is a fast avalanche stage,
 * suitable when input bits are already partially mixed
 ','line_number':2702,'multiline':True]
['text':'
 * This is a stronger avalanche,
 * inspired by Pelle Evensen's rrmxmx
 * preferable when input has not been previously mixed
 ','line_number':2714,'multiline':True]
['text':' this mix is inspired by Pelle Evensen's rrmxmx ','line_number':2721,'multiline':True]
['text':' ==========================================
 * Short keys
 * ==========================================
 * One of the shortcomings of XXH32 and XXH64 was that their performance was
 * sub-optimal on short lengths. It used an iterative algorithm which strongly
 * favored lengths that were a multiple of 4 or 8.
 *
 * Instead of iterating over individual inputs, we use a set of single shot
 * functions which piece together a range of lengths and operate in constant time.
 *
 * Additionally, the number of multiplies has been significantly reduced. This
 * reduces latency, especially when emulating 64-bit multiplies on 32-bit.
 *
 * Depending on the platform, this may or may not be faster than XXH32, but it
 * is almost guaranteed to be faster than XXH64.
 ','line_number':2730,'multiline':True]
['text':'
 * At very short lengths, there isn't enough input to fully hide secrets, or use
 * the entire secret.
 *
 * There is also only a limited amount of mixing we can do before significantly
 * impacting performance.
 *
 * Therefore, we use different sections of the secret and always mix two secret
 * samples with an XOR. This should have no effect on performance on the
 * seedless or withSeed variants because everything _should_ be constant folded
 * by modern compilers.
 *
 * The XOR mixing hides individual parts of the secret and increases entropy.
 *
 * This adds an extra layer of strength for custom secrets.
 ','line_number':2747,'multiline':True]
['text':'
     * len = 1: combined = { input[0], 0x01, input[0], input[0] }
     * len = 2: combined = { input[1], 0x02, input[0], input[1] }
     * len = 3: combined = { input[2], 0x03, input[0], input[1] }
     ','line_number':2769,'multiline':True]
['text':'
 * DISCLAIMER: There are known *seed-dependent* multicollisions here due to
 * multiplication by zero, affecting hashes of lengths 17 to 240.
 *
 * However, they are very unlikely.
 *
 * Keep this in mind when using the unseeded XXH3_64bits() variant: As with all
 * unseeded non-cryptographic hashes, it does not attempt to defend itself
 * against specially crafted inputs, only random inputs.
 *
 * Compared to classic UMAC where a 1 in 2^31 chance of 4 consecutive bytes
 * cancelling out the secret is taken an arbitrary number of times (addressed
 * in XXH3_accumulate_512), this collision is very unlikely with random inputs
 * and/or proper seeding:
 *
 * This only has a 1 in 2^63 chance of 8 consecutive bytes cancelling out, in a
 * function that is only called up to 16 times per hash with up to 240 bytes of
 * input.
 *
 * This is not too bad for a non-cryptographic hash function, especially with
 * only 64 bit outputs.
 *
 * The 128-bit variant (which trades some speed for strength) is NOT affected
 * by this, although it is always a good idea to use a proper seed if you care
 * about strength.
 ','line_number':2829,'multiline':True]
['text':' GCC, not Clang ','line_number':2858,'multiline':True]
['text':' x86 + SSE2 ','line_number':2859,'multiline':True]
['text':' Define to disable like XXH32 hack ','line_number':2860,'multiline':True]
['text':'
     * UGLY HACK:
     * GCC for x86 tends to autovectorize the 128-bit multiply, resulting in
     * slower code.
     *
     * By forcing seed64 into a register, we disrupt the cost model and
     * cause it to scalarize. See `XXH32_round()`
     *
     * FIXME: Clang's output is still _much_ faster -- On an AMD Ryzen 3600,
     * XXH3_64bits @ len=240 runs at 4.6 GB/s with Clang 9, but 3.3 GB/s on
     * GCC 9.2, despite both emitting scalar code.
     *
     * GCC generates much better scalar code than Clang for the rest of XXH3,
     * which is why finding a more optimal codepath is an interest.
     ','line_number':2861,'multiline':True]
['text':' For mid range keys, XXH3 uses a Mum-hash variant. ','line_number':2887,'multiline':True]
['text':' Clang ','line_number':2937,'multiline':True]
['text':' NEON ','line_number':2938,'multiline':True]
['text':' Define to disable ','line_number':2939,'multiline':True]
['text':'
         * UGLY HACK:
         * Clang for ARMv7-A tries to vectorize this loop, similar to GCC x86.
         * In everywhere else, it uses scalar code.
         *
         * For 64->128-bit multiplies, even if the NEON was 100% optimal, it
         * would still be slower than UMAAL (see XXH_mult64to128).
         *
         * Unfortunately, Clang doesn't handle the long multiplies properly and
         * converts them to the nonexistent "vmulq_u64" intrinsic, which is then
         * scalarized into an ugly mess of VMOV.32 instructions.
         *
         * This mess is difficult to avoid without turning autovectorization
         * off completely, but they are usually relatively minor and/or not
         * worth it to fix.
         *
         * This loop is the easiest to fix, as unlike XXH32, this pragma
         * _actually works_ because it is a loop vectorization instead of an
         * SLP vectorization.
         ','line_number':2940,'multiline':True]
['text':' last bytes ','line_number':2965,'multiline':True]
['text':' =======     Long Keys     ======= ','line_number':2972,'multiline':True]
['text':' nb of secret bytes consumed at each accumulation ','line_number':2975,'multiline':True]
['text':' Several intrinsic functions below are supposed to accept __int64 as argument,
 * as documented in https://software.intel.com/sites/landingpage/IntrinsicsGuide/ .
 * However, several environments do not define __int64 type,
 * requiring a workaround.
 ','line_number':2989,'multiline':True]
['text':' C99 ','line_number':2996,'multiline':True]
['text':' the following type must have a width of 64-bit ','line_number':2999,'multiline':True]
['text':'
 * XXH3_accumulate_512 is the tightest loop for long inputs, and it is the most optimized.
 *
 * It is a hardened version of UMAC, based off of FARSH's implementation.
 *
 * This was chosen because it adapts quite well to 32-bit, 64-bit, and SIMD
 * implementations, and it is ridiculously fast.
 *
 * We harden it by mixing the original input to the accumulators as well as the product.
 *
 * This means that in the (relatively likely) case of a multiply by zero, the
 * original input is preserved.
 *
 * On 128-bit inputs, we swap 64-bit pairs when we add the input to improve
 * cross-pollination, as otherwise the upper and lower halves would be
 * essentially independent.
 *
 * This doesn't matter on 64-bit hashes since they all get merged together in
 * the end, so we skip the extra step.
 *
 * Both XXH3_64bits and XXH3_128bits use this subroutine.
 ','line_number':3003,'multiline':True]
['text':' disable attribute target ','line_number':3029,'multiline':True]
['text':' data_vec    = input[0]; ','line_number':3042,'multiline':True]
['text':' key_vec     = secret[0]; ','line_number':3044,'multiline':True]
['text':' data_key    = data_vec ^ key_vec; ','line_number':3046,'multiline':True]
['text':' data_key_lo = data_key >> 32; ','line_number':3048,'multiline':True]
['text':' product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); ','line_number':3050,'multiline':True]
['text':' xacc[0] += swap(data_vec); ','line_number':3052,'multiline':True]
['text':' xacc[0] += product; ','line_number':3055,'multiline':True]
['text':'
 * XXH3_scrambleAcc: Scrambles the accumulators to improve mixing.
 *
 * Multiplication isn't perfect, as explained by Google in HighwayHash:
 *
 *  // Multiplication mixes/scrambles bytes 0-7 of the 64-bit result to
 *  // varying degrees. In descending order of goodness, bytes
 *  // 3 4 2 5 1 6 0 7 have quality 228 224 164 160 100 96 36 32.
 *  // As expected, the upper and lower bytes are much worse.
 *
 * Source: https://github.com/google/highwayhash/blob/0aaf66b/highwayhash/hh_avx2.h#L291
 *
 * Since our algorithm uses a pseudorandom secret to add some variance into the
 * mix, we don't need to (or want to) mix as often or as much as HighwayHash does.
 *
 * This isn't as tight as XXH3_accumulate, but still written in SIMD to avoid
 * extraction.
 *
 * Both XXH3_64bits and XXH3_128bits use this subroutine.
 ','line_number':3060,'multiline':True]
['text':' xacc[0] ^= (xacc[0] >> 47) ','line_number':3089,'multiline':True]
['text':' xacc[0] ^= secret; ','line_number':3093,'multiline':True]
['text':' xacc[0] *= XXH_PRIME32_1; ','line_number':3097,'multiline':True]
['text':' GCC has a bug, _mm512_stream_load_si512 accepts 'void*', not 'void const*',
             * this will warn "discards const qualifier". ','line_number':3119,'multiline':True]
['text':' disable attribute target ','line_number':3135,'multiline':True]
['text':' Unaligned. This is mainly for pointer arithmetic, and because
         * _mm256_loadu_si256 requires  a const __m256i * pointer for some reason. ','line_number':3145,'multiline':True]
['text':' Unaligned. This is mainly for pointer arithmetic, and because
         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. ','line_number':3148,'multiline':True]
['text':' data_vec    = xinput[i]; ','line_number':3154,'multiline':True]
['text':' key_vec     = xsecret[i]; ','line_number':3156,'multiline':True]
['text':' data_key    = data_vec ^ key_vec; ','line_number':3158,'multiline':True]
['text':' data_key_lo = data_key >> 32; ','line_number':3160,'multiline':True]
['text':' product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); ','line_number':3162,'multiline':True]
['text':' xacc[i] += swap(data_vec); ','line_number':3164,'multiline':True]
['text':' xacc[i] += product; ','line_number':3167,'multiline':True]
['text':' Unaligned. This is mainly for pointer arithmetic, and because
         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. ','line_number':3177,'multiline':True]
['text':' xacc[i] ^= (xacc[i] >> 47) ','line_number':3184,'multiline':True]
['text':' xacc[i] ^= xsecret; ','line_number':3188,'multiline':True]
['text':' xacc[i] *= XXH_PRIME32_1; ','line_number':3192,'multiline':True]
['text':'
         * On GCC & Clang, marking 'dest' as modified will cause the compiler:
         *   - do not extract the secret from sse registers in the internal loop
         *   - use less common registers, and avoid pushing these reg into stack
         * The asm hack causes Clang to assume that XXH3_kSecretPtr aliases with
         * customSecret, and on aarch64, this prevented LDP from merging two
         * loads together for free. Putting the loads together before the stores
         * properly generates LDP.
         ','line_number':3214,'multiline':True]
['text':' GCC -O2 need unroll loop manually ','line_number':3226,'multiline':True]
['text':' disable attribute target ','line_number':3241,'multiline':True]
['text':' SSE2 is just a half-scale version of the AVX2 version. ','line_number':3249,'multiline':True]
['text':' Unaligned. This is mainly for pointer arithmetic, and because
         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. ','line_number':3252,'multiline':True]
['text':' Unaligned. This is mainly for pointer arithmetic, and because
         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. ','line_number':3255,'multiline':True]
['text':' data_vec    = xinput[i]; ','line_number':3261,'multiline':True]
['text':' key_vec     = xsecret[i]; ','line_number':3263,'multiline':True]
['text':' data_key    = data_vec ^ key_vec; ','line_number':3265,'multiline':True]
['text':' data_key_lo = data_key >> 32; ','line_number':3267,'multiline':True]
['text':' product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); ','line_number':3269,'multiline':True]
['text':' xacc[i] += swap(data_vec); ','line_number':3271,'multiline':True]
['text':' xacc[i] += product; ','line_number':3274,'multiline':True]
['text':' Unaligned. This is mainly for pointer arithmetic, and because
         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. ','line_number':3284,'multiline':True]
['text':' xacc[i] ^= (xacc[i] >> 47) ','line_number':3291,'multiline':True]
['text':' xacc[i] ^= xsecret[i]; ','line_number':3295,'multiline':True]
['text':' xacc[i] *= XXH_PRIME32_1; ','line_number':3299,'multiline':True]
['text':' MSVC 32bit mode does not support _mm_set_epi64x before 2015','line_number':3315,'multiline':False]
['text':'
         * On GCC & Clang, marking 'dest' as modified will cause the compiler:
         *   - do not extract the secret from sse registers in the internal loop
         *   - use less common registers, and avoid pushing these reg into stack
         ','line_number':3326,'multiline':True]
['text':' We don't use a uint32x4_t pointer because it causes bus errors on ARMv7. ','line_number':3351,'multiline':True]
['text':' data_vec = xinput[i]; ','line_number':3357,'multiline':True]
['text':' key_vec  = xsecret[i];  ','line_number':3359,'multiline':True]
['text':' xacc[i] += swap(data_vec); ','line_number':3363,'multiline':True]
['text':' data_key = data_vec ^ key_vec; ','line_number':3367,'multiline':True]
['text':' data_key_lo = (uint32x2_t) (data_key & 0xFFFFFFFF);
             * data_key_hi = (uint32x2_t) (data_key >> 32);
             * data_key = UNDEFINED; ','line_number':3369,'multiline':True]
['text':' xacc[i] += (uint64x2_t) data_key_lo * (uint64x2_t) data_key_hi; ','line_number':3373,'multiline':True]
['text':' xacc[i] ^= (xacc[i] >> 47); ','line_number':3391,'multiline':True]
['text':' xacc[i] ^= xsecret[i]; ','line_number':3396,'multiline':True]
['text':' xacc[i] *= XXH_PRIME32_1 ','line_number':3400,'multiline':True]
['text':' data_key_lo = (uint32x2_t) (xacc[i] & 0xFFFFFFFF);
             * data_key_hi = (uint32x2_t) (xacc[i] >> 32);
             * xacc[i] = UNDEFINED; ','line_number':3402,'multiline':True]
['text':'
                 * prod_hi = (data_key >> 32) * XXH_PRIME32_1;
                 *
                 * Avoid vmul_u32 + vshll_n_u32 since Clang 6 and 7 will
                 * incorrectly "optimize" this:
                 *   tmp     = vmul_u32(vmovn_u64(a), vmovn_u64(b));
                 *   shifted = vshll_n_u32(tmp, 32);
                 * to this:
                 *   tmp     = "vmulq_u64"(a, b); // no such thing!
                 *   shifted = vshlq_n_u64(tmp, 32);
                 *
                 * However, unlike SSE, Clang lacks a 64-bit multiply routine
                 * for NEON, and it scalarizes two 64-bit multiplies instead.
                 *
                 * vmull_u32 has the same timing as vmul_u32, and it avoids
                 * this bug completely.
                 * See https://bugs.llvm.org/show_bug.cgi?id=39967
                 ','line_number':3406,'multiline':True]
['text':' xacc[i] = prod_hi << 32; ','line_number':3425,'multiline':True]
['text':' xacc[i] += (prod_hi & 0xFFFFFFFF) * XXH_PRIME32_1; ','line_number':3427,'multiline':True]
['text':' presumed aligned ','line_number':3442,'multiline':True]
['text':' no alignment restriction ','line_number':3443,'multiline':True]
['text':' no alignment restriction ','line_number':3444,'multiline':True]
['text':' data_vec = xinput[i]; ','line_number':3448,'multiline':True]
['text':' key_vec = xsecret[i]; ','line_number':3450,'multiline':True]
['text':' shuffled = (data_key << 32) | (data_key >> 32); ','line_number':3453,'multiline':True]
['text':' product = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)shuffled & 0xFFFFFFFF); ','line_number':3455,'multiline':True]
['text':' swap high and low halves ','line_number':3459,'multiline':True]
['text':' constants ','line_number':3475,'multiline':True]
['text':' xacc[i] ^= (xacc[i] >> 47); ','line_number':3481,'multiline':True]
['text':' xacc[i] ^= xsecret[i]; ','line_number':3485,'multiline':True]
['text':' xacc[i] *= XXH_PRIME32_1 ','line_number':3489,'multiline':True]
['text':' prod_lo = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)prime & 0xFFFFFFFF);  ','line_number':3490,'multiline':True]
['text':' prod_hi = ((xxh_u64x2)data_key >> 32) * ((xxh_u64x2)prime >> 32);  ','line_number':3492,'multiline':True]
['text':' scalar variants - universal ','line_number':3500,'multiline':True]
['text':' presumed aligned ','line_number':3507,'multiline':True]
['text':' no alignment restriction ','line_number':3508,'multiline':True]
['text':' no alignment restriction ','line_number':3509,'multiline':True]
['text':' swap adjacent lanes ','line_number':3515,'multiline':True]
['text':' presumed aligned ','line_number':3523,'multiline':True]
['text':' no alignment restriction ','line_number':3524,'multiline':True]
['text':'
     * We need a separate pointer for the hack below,
     * which requires a non-const pointer.
     * Any decent compiler will optimize this out otherwise.
     ','line_number':3540,'multiline':True]
['text':'
     * UGLY HACK:
     * Clang generates a bunch of MOV/MOVK pairs for aarch64, and they are
     * placed sequentially, in order, at the top of the unrolled loop.
     *
     * While MOVK is great for generating constants (2 cycles for a 64-bit
     * constant compared to 4 cycles for LDR), long MOVK chains stall the
     * integer pipelines:
     *   I   L   S
     * MOVK
     * MOVK
     * MOVK
     * MOVK
     * ADD
     * SUB      STR
     *          STR
     * By forcing loads from memory (as the asm line causes Clang to assume
     * that XXH3_kSecretPtr has been changed), the pipelines are used more
     * efficiently:
     *   I   L   S
     *      LDR
     *  ADD LDR
     *  SUB     STR
     *          STR
     * XXH3_64bits_withSeed, len == 256, Snapdragon 835
     *   without hack: 2654.4 MB/s
     *   with hack:    3202.9 MB/s
     ','line_number':3549,'multiline':True]
['text':'
     * Note: in debug mode, this overrides the asm optimization
     * and Clang will emit MOVK chains again.
     ','line_number':3579,'multiline':True]
['text':'
             * The asm hack causes Clang to assume that kSecretPtr aliases with
             * customSecret, and on aarch64, this prevented LDP from merging two
             * loads together for free. Putting the loads together before the stores
             * properly generates LDP.
             ','line_number':3588,'multiline':True]
['text':' scalar ','line_number':3637,'multiline':True]
['text':' __clang__ ','line_number':3656,'multiline':True]
['text':' XXH_PREFETCH_DIST ','line_number':3657,'multiline':True]
['text':'
 * XXH3_accumulate()
 * Loops over XXH3_accumulate_512().
 * Assumption: nbStripes will not overflow the secret size
 ','line_number':3659,'multiline':True]
['text':' last partial block ','line_number':3701,'multiline':True]
['text':' last stripe ','line_number':3707,'multiline':True]
['text':' not aligned on 8, last secret is different from acc & scrambler ','line_number':3709,'multiline':True]
['text':' Clang ','line_number':3730,'multiline':True]
['text':' ARMv7 ','line_number':3731,'multiline':True]
['text':' NEON ','line_number':3732,'multiline':True]
['text':' Define to disable ','line_number':3733,'multiline':True]
['text':'
         * UGLY HACK:
         * Prevent autovectorization on Clang ARMv7-a. Exact same problem as
         * the one in XXH3_len_129to240_64b. Speeds up shorter keys > 240b.
         * XXH3_64bits, len == 256, Snapdragon 835:
         *   without hack: 2063.7 MB/s
         *   with hack:    2560.7 MB/s
         ','line_number':3734,'multiline':True]
['text':' converge into final hash ','line_number':3762,'multiline':True]
['text':' do not align on 8, so that the secret is different from the accumulator ','line_number':3764,'multiline':True]
['text':'
 * It's important for performance that XXH3_hashLong is not inlined.
 ','line_number':3770,'multiline':True]
['text':'
 * It's important for performance that XXH3_hashLong is not inlined.
 * Since the function is not inlined, the compiler may not be able to understand that,
 * in some scenarios, its `secret` argument is actually a compile time constant.
 * This variant enforces that the compiler can detect that,
 * and uses this opportunity to streamline the generated code for better performance.
 ','line_number':3781,'multiline':True]
['text':'
 * XXH3_hashLong_64b_withSeed():
 * Generate a custom key based on alteration of default XXH3_kSecret with the seed,
 * and then use this key for long mode hashing.
 *
 * This operation is decently fast but nonetheless costs a little bit of time.
 * Try to avoid it whenever possible (typically when seed==0).
 *
 * It's important for performance that XXH3_hashLong is not inlined. Not sure
 * why (uop cache maybe?), but the difference is large and easily measurable.
 ','line_number':3796,'multiline':True]
['text':'
 * It's important for performance that XXH3_hashLong is not inlined.
 ','line_number':3825,'multiline':True]
['text':'
     * If an action is to be taken if `secretLen` condition is not respected,
     * it should be done here.
     * For now, it's a contract pre-condition.
     * Adding a check and a branch here would cost performance at every hash.
     * Also, note that function signature doesn't offer room to return an error.
     ','line_number':3847,'multiline':True]
['text':' ===   Public entry point   === ','line_number':3864,'multiline':True]
['text':' ===   XXH3 streaming   === ','line_number':3884,'multiline':True]
['text':'
 * Malloc's a pointer that is always aligned to align.
 *
 * This must be freed with `XXH_alignedFree()`.
 *
 * malloc typically guarantees 16 byte alignment on 64-bit systems and 8 byte
 * alignment on 32-bit. This isn't enough for the 32 byte aligned loads in AVX2
 * or on 32-bit, the 16 byte aligned loads in SSE2 and NEON.
 *
 * This underalignment previously caused a rather obvious crash which went
 * completely unnoticed due to XXH3_createState() not actually being tested.
 * Credit to RedSpah for noticing this bug.
 *
 * The alignment is done manually: Functions like posix_memalign or _mm_malloc
 * are avoided: To maintain portability, we would have to write a fallback
 * like this anyways, and besides, testing for the existence of library
 * functions without relying on external build tools is impossible.
 *
 * The method is simple: Overallocate, manually align, and store the offset
 * to the original behind the returned pointer.
 *
 * Align must be a power of 2 and 8 <= align <= 128.
 ','line_number':3886,'multiline':True]
['text':' range check ','line_number':3911,'multiline':True]
['text':' power of 2 ','line_number':3912,'multiline':True]
['text':' empty/overflow ','line_number':3913,'multiline':True]
['text':' Overallocate to make room for manual realignment and an offset byte ','line_number':3914,'multiline':True]
['text':'
             * Get the offset needed to align this pointer.
             *
             * Even if the returned pointer is aligned, there will always be
             * at least one byte to store the offset to the original pointer.
             ','line_number':3917,'multiline':True]
['text':' base % align ','line_number':3923,'multiline':True]
['text':' Add the offset for the now-aligned pointer ','line_number':3924,'multiline':True]
['text':' Store the offset immediately before the returned pointer. ','line_number':3929,'multiline':True]
['text':'
 * Frees an aligned pointer allocated by XXH_alignedMalloc(). Don't pass
 * normal malloc'd pointers, XXH_alignedMalloc has a specific data layout.
 ','line_number':3936,'multiline':True]
['text':' Get the offset byte we added in XXH_malloc. ','line_number':3944,'multiline':True]
['text':' Free the original malloc'd pointer ','line_number':3946,'multiline':True]
['text':' set members from bufferedSize to nbStripesPerBlock (excluded) to 0 ','line_number':3980,'multiline':True]
['text':' Note : when XXH3_consumeStripes() is invoked,
 * there must be a guarantee that at least one more byte must be consumed from input
 * so that the function can blindly consume all stripes using the "normal" secret segment ','line_number':4025,'multiline':True]
['text':' can handle max 1 scramble per invocation ','line_number':4036,'multiline':True]
['text':' need a scrambling operation ','line_number':4039,'multiline':True]
['text':'
 * Both XXH3_64bits_update and XXH3_128bits_update use this routine.
 ','line_number':4052,'multiline':True]
['text':' fill in tmp buffer ','line_number':4073,'multiline':True]
['text':' total input is now > XXH3_INTERNALBUFFER_SIZE ','line_number':4078,'multiline':True]
['text':' clean multiple ','line_number':4081,'multiline':True]
['text':'
         * Internal buffer is partially filled (always, except at beginning)
         * Complete it, then consume it.
         ','line_number':4083,'multiline':True]
['text':' Consume input by a multiple of internal buffer size ','line_number':4100,'multiline':True]
['text':' for last partial stripe ','line_number':4111,'multiline':True]
['text':' Some remaining input (always) : buffer it ','line_number':4116,'multiline':True]
['text':'
     * Digest on a local copy. This way, the state remains unaltered, and it can
     * continue ingesting more input afterwards.
     ','line_number':4137,'multiline':True]
['text':' last stripe ','line_number':4150,'multiline':True]
['text':' bufferedSize < XXH_STRIPE_LEN ','line_number':4154,'multiline':True]
['text':' there is always some input buffered ','line_number':4157,'multiline':True]
['text':' totalLen <= XXH3_MIDSIZE_MAX: digesting a short input ','line_number':4176,'multiline':True]
['text':' exact multiple ','line_number':4202,'multiline':True]
['text':'
        * Copy customSeed to seeds[], truncating or repeating as necessary.
        ','line_number':4205,'multiline':True]
['text':' generate secret ','line_number':4217,'multiline':True]
['text':' ==========================================
 * XXH3 128 bits (a.k.a XXH128)
 * ==========================================
 * XXH3's 128-bit variant has better mixing and strength than the 64-bit variant,
 * even without counting the significantly larger output size.
 *
 * For example, extra steps are taken to avoid the seed-dependent collisions
 * in 17-240 byte inputs (See XXH3_mix16B and XXH128_mix32B).
 *
 * This strength naturally comes at the cost of some speed, especially on short
 * lengths. Note that longer hashes are about as fast as the 64-bit version
 * due to it using only a slight modification of the 64-bit loop.
 *
 * XXH128 is also more oriented towards 64-bit machines. It is still extremely
 * fast for a _128-bit_ hash on 32-bit (it usually clears XXH64).
 ','line_number':4229,'multiline':True]
['text':' A doubled version of 1to3_64b with different constants. ','line_number':4249,'multiline':True]
['text':'
     * len = 1: combinedl = { input[0], 0x01, input[0], input[0] }
     * len = 2: combinedl = { input[1], 0x02, input[0], input[1] }
     * len = 3: combinedl = { input[2], 0x03, input[0], input[1] }
     ','line_number':4253,'multiline':True]
['text':' Shift len to the left to ensure it is even, this avoids even multiplies. ','line_number':4288,'multiline':True]
['text':'
         * Put len in the middle of m128 to ensure that the length gets mixed to
         * both the low and high bits in the 128x64 multiply below.
         ','line_number':4313,'multiline':True]
['text':'
         * Add the high 32 bits of input_hi to the high 32 bits of m128, then
         * add the long product of the low 32 bits of input_hi and XXH_PRIME32_2 to
         * the high 64 bits of m128.
         *
         * The best approach to this operation is different on 32-bit and 64-bit.
         ','line_number':4319,'multiline':True]
['text':' 32-bit ','line_number':4326,'multiline':True]
['text':'
             * 32-bit optimized version, which is more readable.
             *
             * On 32-bit, it removes an ADC and delays a dependency between the two
             * halves of m128.high64, but it generates an extra mask on 64-bit.
             ','line_number':4327,'multiline':True]
['text':'
             * 64-bit optimized (albeit more confusing) version.
             *
             * Uses some properties of addition and multiplication to remove the mask:
             *
             * Let:
             *    a = input_hi.lo = (input_hi & 0x00000000FFFFFFFF)
             *    b = input_hi.hi = (input_hi & 0xFFFFFFFF00000000)
             *    c = XXH_PRIME32_2
             *
             *    a + (b * c)
             * Inverse Property: x + y - x == y
             *    a + (b * (1 + c - 1))
             * Distributive Property: x * (y + z) == (x * y) + (x * z)
             *    a + (b * 1) + (b * (c - 1))
             * Identity Property: x * 1 == x
             *    a + b + (b * (c - 1))
             *
             * Substitute a, b, and c:
             *    input_hi.hi + input_hi.lo + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1))
             *
             * Since input_hi.hi + input_hi.lo == input_hi, we get this:
             *    input_hi + ((xxh_u64)input_hi.lo * (XXH_PRIME32_2 - 1))
             ','line_number':4335,'multiline':True]
['text':' m128 ^= XXH_swap64(m128 >> 64); ','line_number':4361,'multiline':True]
['text':' 128x64 multiply: h128 = m128 * XXH_PRIME64_2; ','line_number':4364,'multiline':True]
['text':'
 * Assumption: `secret` size is >= XXH3_SECRET_SIZE_MIN
 ','line_number':4374,'multiline':True]
['text':'
 * A bit slower than XXH3_mix16B, but handles multiply by zero better.
 ','line_number':4393,'multiline':True]
['text':' last bytes ','line_number':4471,'multiline':True]
['text':' converge into final hash ','line_number':4500,'multiline':True]
['text':'
 * It's important for performance that XXH3_hashLong is not inlined.
 ','line_number':4515,'multiline':True]
['text':'
 * It's important for performance that XXH3_hashLong is not inlined.
 ','line_number':4528,'multiline':True]
['text':'
 * It's important for performance that XXH3_hashLong is not inlined.
 ','line_number':4559,'multiline':True]
['text':'
     * If an action is to be taken if `secret` conditions are not respected,
     * it should be done here.
     * For now, it's a contract pre-condition.
     * Adding a check and a branch here would cost performance at every hash.
     ','line_number':4580,'multiline':True]
['text':' ===   Public XXH128 API   === ','line_number':4596,'multiline':True]
['text':' ===   XXH3 128-bit streaming   === ','line_number':4628,'multiline':True]
['text':'
 * All the functions are actually the same as for 64-bit streaming variant.
 * The only difference is the finalizatiom routine.
 ','line_number':4630,'multiline':True]
['text':' len <= XXH3_MIDSIZE_MAX : short code ','line_number':4696,'multiline':True]
['text':' 128-bit utility functions ','line_number':4703,'multiline':True]
['text':' memcmp, memcpy ','line_number':4705,'multiline':True]
['text':' return : 1 is equal, 0 if different ','line_number':4707,'multiline':True]
['text':' note : XXH128_hash_t is compact, it has no padding byte ','line_number':4710,'multiline':True]
['text':' This prototype is compatible with stdlib's qsort().
 * return : >0 if *h128_1  > *h128_2
 *          <0 if *h128_1  < *h128_2
 *          =0 if *h128_1 == *h128_2  ','line_number':4714,'multiline':True]
['text':' note : bets that, in most cases, hash values are different ','line_number':4723,'multiline':True]
['text':'======   Canonical representation   ======','line_number':4729,'multiline':True]
['text':' Pop our optimization override from above ','line_number':4751,'multiline':True]
['text':' AVX2 ','line_number':4752,'multiline':True]
['text':' GCC, not Clang ','line_number':4753,'multiline':True]
['text':' respect -O0 and -Os ','line_number':4754,'multiline':True]
['text':' XXH_NO_LONG_LONG ','line_number':4758,'multiline':True]
['text':' XXH_IMPLEMENTATION ','line_number':4761,'multiline':True]
