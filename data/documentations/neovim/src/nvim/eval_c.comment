['text':' eval.c: Expression evaluation.','line_number':1,'multiline':False]
['text':' TODO(ZyX-I): Remove DICT_MAXNEST, make users be non-recursive instead','line_number':88,'multiline':False]
['text':' maximum nesting of lists and dicts','line_number':90,'multiline':False]
['text':'/ Variable used for g:','line_number':120,'multiline':False]
['text':'/ Old Vim variables such as "v:version" are also available without the "v:".','line_number':123,'multiline':False]
['text':'/ Also in functions.  We need a special hashtable for them.','line_number':124,'multiline':False]
['text':'/ Used for checking if local variables or arguments used in a lambda.','line_number':127,'multiline':False]
['text':' attributes used for ":echo"','line_number':133,'multiline':False]
['text':'/ Info used by a ":for" loop.','line_number':135,'multiline':False]
['text':' true if ending in '; var]'','line_number':137,'multiline':False]
['text':' nr of variables in the list','line_number':138,'multiline':False]
['text':' keep an eye on the item used.','line_number':139,'multiline':False]
['text':' list being used','line_number':140,'multiline':False]
['text':' index of blob','line_number':141,'multiline':False]
['text':' blob being used','line_number':142,'multiline':False]
['text':' copy of string being used','line_number':143,'multiline':False]
['text':' byte index in fi_string','line_number':144,'multiline':False]
['text':' values for vv_flags:','line_number':147,'multiline':False]
['text':' compatible, also used without "v:"','line_number':148,'multiline':False]
['text':' read-only','line_number':149,'multiline':False]
['text':' read-only in the sandbox','line_number':150,'multiline':False]
['text':' Maximum length of the key of v:variables','line_number':163,'multiline':False]
['text':' Array to hold the value of v: variables.','line_number':165,'multiline':False]
['text':' The value is in a dictitem, so that it can also be used in the v: scope.','line_number':166,'multiline':False]
['text':' The reason to use this table anyway is for very quick access to the','line_number':167,'multiline':False]
['text':' variables with the VV_ defines.','line_number':168,'multiline':False]
['text':'/< Name of the variable, without v:.','line_number':170,'multiline':False]
['text':'/< Value and name for key (max 16 chars).','line_number':171,'multiline':False]
['text':'/< Flags: #VV_COMPAT, #VV_RO, #VV_RO_SBX.','line_number':172,'multiline':False]
['text':' VV_ tails differing from upcased string literals:','line_number':174,'multiline':False]
['text':' VV_CC_FROM "charconvert_from"','line_number':175,'multiline':False]
['text':' VV_CC_TO "charconvert_to"','line_number':176,'multiline':False]
['text':' VV_SEND_SERVER "servername"','line_number':177,'multiline':False]
['text':' VV_REG "register"','line_number':178,'multiline':False]
['text':' VV_OP "operator"','line_number':179,'multiline':False]
['text':' Neovim','line_number':270,'multiline':False]
['text':' shorthand','line_number':283,'multiline':False]
['text':'/ Variable used for v:','line_number':296,'multiline':False]
['text':'/ v: hashtab','line_number':301,'multiline':False]
['text':'/ Enum used by filter(), map() and mapnew()','line_number':304,'multiline':False]
['text':' recursive use of v:event, save, make empty and restore later','line_number':346,'multiline':False]
['text':'/ @return  "n1" divided by "n2", taking care of dividing by zero.','line_number':366,'multiline':False]
['text':' give an error message?','line_number':372,'multiline':False]
['text':' similar to NaN','line_number':374,'multiline':False]
['text':' specific case: trying to do VARNUMBAR_MIN / -1 results in a positive','line_number':381,'multiline':False]
['text':' number that doesn't fit in varnumber_T and causes an FPE','line_number':382,'multiline':False]
['text':'/ @return  "n1" modulus "n2", taking care of dividing by zero.','line_number':391,'multiline':False]
['text':' Give an error when n2 is 0?','line_number':395,'multiline':False]
['text':'/ Initialize the global and v: variables.','line_number':399,'multiline':False]
['text':' add to v: scope dict, unless the value is not always available','line_number':422,'multiline':False]
['text':' add to compat scope dict','line_number':427,'multiline':False]
['text':' There must not be duplicate items in this dictionary by definition.','line_number':446,'multiline':False]
['text':' this value shouldn't be printed, but if it is, do not crash','line_number':484,'multiline':False]
['text':' default for v:register is not 0 but '"'','line_number':488,'multiline':False]
['text':' garbage_collect() will access it','line_number':508,'multiline':False]
['text':' global variables','line_number':511,'multiline':False]
['text':' Script-local variables. Clear all the variables here.','line_number':514,'multiline':False]
['text':' The scriptvar_T is cleared later in free_scriptnames(), because a','line_number':515,'multiline':False]
['text':' variable in one script might hold a reference to the whole scope of','line_number':516,'multiline':False]
['text':' another script.','line_number':517,'multiline':False]
['text':' must come after evalvars_clear().','line_number':526,'multiline':False]
['text':' autoloaded script names','line_number':531,'multiline':False]
['text':' unreferenced lists and dicts','line_number':534,'multiline':False]
['text':' functions not garbage collected','line_number':537,'multiline':False]
['text':'/ Set an internal variable to a string value. Creates the variable if it does','line_number':543,'multiline':False]
['text':'/ not already exist.','line_number':544,'multiline':False]
['text':' NOLINT(readability-non-const-parameter)','line_number':545,'multiline':False]
['text':' Only valid when redir_lval is not NULL.','line_number':557,'multiline':False]
['text':'/ Start recording command output to a variable','line_number':561,'multiline':False]
['text':'/','line_number':562,'multiline':False]
['text':'/ @param append  append to an existing variable','line_number':563,'multiline':False]
['text':'/','line_number':564,'multiline':False]
['text':'/ @return  OK if successfully completed the setup.  FAIL otherwise.','line_number':565,'multiline':False]
['text':' Catch a bad name early.','line_number':568,'multiline':False]
['text':' Make a copy of the name, it is used in redir_lval until redir ends.','line_number':574,'multiline':False]
['text':' The output is stored in growarray "redir_ga" until redirection ends.','line_number':579,'multiline':False]
['text':' Parse the variable name (can be a dict or list entry).','line_number':582,'multiline':False]
['text':' Trailing characters are present after the variable name','line_number':589,'multiline':False]
['text':' don't store a value, only cleanup','line_number':594,'multiline':False]
['text':' check if we can write to the variable: set it to or append an empty','line_number':599,'multiline':False]
['text':' string','line_number':600,'multiline':False]
['text':' don't store a value, only cleanup','line_number':613,'multiline':False]
['text':'/ Append "value[value_len]" to the variable set by var_redir_start().','line_number':621,'multiline':False]
['text':'/ The actual appending is postponed until redirection ends, because the value','line_number':622,'multiline':False]
['text':'/ appended may in fact be the string we write to, changing it may cause freed','line_number':623,'multiline':False]
['text':'/ memory to be used:','line_number':624,'multiline':False]
['text':'/   :redir => foo','line_number':625,'multiline':False]
['text':'/   :let foo','line_number':626,'multiline':False]
['text':'/   :redir END','line_number':627,'multiline':False]
['text':' Append the entire string','line_number':636,'multiline':False]
['text':' Append only "value_len" characters','line_number':638,'multiline':False]
['text':'/ Stop redirecting command output to a variable.','line_number':646,'multiline':False]
['text':'/ Frees the allocated memory.','line_number':647,'multiline':False]
['text':' If there was no error: assign the text to the variable.','line_number':651,'multiline':False]
['text':' Append the trailing NUL.','line_number':653,'multiline':False]
['text':' Call get_lval() again, if it's inside a Dict or List it may','line_number':657,'multiline':False]
['text':' have changed.','line_number':658,'multiline':False]
['text':' free the collected output','line_number':667,'multiline':False]
['text':' errors are ignored','line_number':718,'multiline':False]
['text':' errors are ignored','line_number':740,'multiline':False]
['text':'/ Top level evaluation function, returning a boolean.','line_number':761,'multiline':False]
['text':'/ Sets "error" to true if there was an error.','line_number':762,'multiline':False]
['text':'/','line_number':763,'multiline':False]
['text':'/ @param skip  only parse, don't execute','line_number':764,'multiline':False]
['text':'/','line_number':765,'multiline':False]
['text':'/ @return  true or false.','line_number':766,'multiline':False]
['text':'/ Call eval1() and give an error message if not done at a lower level.','line_number':795,'multiline':False]
['text':' Report the invalid expression unless the expression evaluation has','line_number':808,'multiline':False]
['text':' been cancelled due to an aborting error, an interrupt, or an','line_number':809,'multiline':False]
['text':' exception, or we already gave a more specific error.','line_number':810,'multiline':False]
['text':' Also check called_emsg for when using assert_fails().','line_number':811,'multiline':False]
['text':'/ @return  whether a typval is a valid expression to pass to eval_expr_typval()','line_number':822,'multiline':False]
['text':'/          or eval_expr_to_bool().  An empty string returns false;','line_number':823,'multiline':False]
['text':'/ Evaluate an expression, which can be a function, partial or string.','line_number':831,'multiline':False]
['text':'/ Pass arguments "argv[argc]".','line_number':832,'multiline':False]
['text':'/ Return the result in "rettv" and OK or FAIL.','line_number':833,'multiline':False]
['text':'/','line_number':834,'multiline':False]
['text':'/ @param want_func  if true, treat a string as a function name, not an expression','line_number':835,'multiline':False]
['text':' check for trailing chars after expr','line_number':877,'multiline':False]
['text':'/ Like eval_to_bool() but using a typval_T instead of a string.','line_number':886,'multiline':False]
['text':'/ Works for string, funcref and partial.','line_number':887,'multiline':False]
['text':'/ Top level evaluation function, returning a string','line_number':902,'multiline':False]
['text':'/','line_number':903,'multiline':False]
['text':'/ @param[in]  arg  String to evaluate.','line_number':904,'multiline':False]
['text':'/ @param[in]  skip  If true, only do parsing to nextcmd without reporting','line_number':905,'multiline':False]
['text':'/                   errors or actually evaluating anything.','line_number':906,'multiline':False]
['text':'/','line_number':907,'multiline':False]
['text':'/ @return [allocated] string result of evaluation or NULL in case of error or','line_number':908,'multiline':False]
['text':'/                     when skipping.','line_number':909,'multiline':False]
['text':'/ Skip over an expression at "*pp".','line_number':935,'multiline':False]
['text':'/','line_number':936,'multiline':False]
['text':'/ @return  FAIL for an error, OK otherwise.','line_number':937,'multiline':False]
['text':' Don't evaluate the expression.','line_number':942,'multiline':False]
['text':'/ Convert "tv" to a string.','line_number':958,'multiline':False]
['text':'/','line_number':959,'multiline':False]
['text':'/ @param convert  when true convert a List into a sequence of lines.','line_number':960,'multiline':False]
['text':'/','line_number':961,'multiline':False]
['text':'/ @return  an allocated string.','line_number':962,'multiline':False]
['text':'/ Top level evaluation function, returning a string.','line_number':980,'multiline':False]
['text':'/','line_number':981,'multiline':False]
['text':'/ @param convert  when true convert a List into a sequence of lines.','line_number':982,'multiline':False]
['text':'/','line_number':983,'multiline':False]
['text':'/ @return  pointer to allocated memory, or NULL for failure.','line_number':984,'multiline':False]
['text':'/ Call eval_to_string() without using current local variables and using','line_number':1001,'multiline':False]
['text':'/ textlock.','line_number':1002,'multiline':False]
['text':'/','line_number':1003,'multiline':False]
['text':'/ @param use_sandbox  when true, use the sandbox.','line_number':1004,'multiline':False]
['text':'/ Top level evaluation function, returning a number.','line_number':1024,'multiline':False]
['text':'/ Evaluates "expr" silently.','line_number':1025,'multiline':False]
['text':'/','line_number':1026,'multiline':False]
['text':'/ @return  -1 for an error.','line_number':1027,'multiline':False]
['text':'/ Top level evaluation function.','line_number':1047,'multiline':False]
['text':'/','line_number':1048,'multiline':False]
['text':'/ @return  an allocated typval_T with the result or','line_number':1049,'multiline':False]
['text':'/          NULL when there is an error.','line_number':1050,'multiline':False]
['text':'/ List Vim variables.','line_number':1066,'multiline':False]
['text':'/ List script-local variables, if there is a script.','line_number':1072,'multiline':False]
['text':'/ Prepare v: variable "idx" to be used.','line_number':1090,'multiline':False]
['text':'/ Save the current typeval in "save_tv".','line_number':1091,'multiline':False]
['text':'/ When not used yet add the variable to the v: hashtable.','line_number':1092,'multiline':False]
['text':'/ Restore v: variable "idx" to typeval "save_tv".','line_number':1101,'multiline':False]
['text':'/ When no longer defined, remove the variable from the v: hashtable.','line_number':1102,'multiline':False]
['text':'/ Evaluate an expression to a list with suggestions.','line_number':1118,'multiline':False]
['text':'/ For the "expr:" part of 'spellsuggest'.','line_number':1119,'multiline':False]
['text':'/','line_number':1120,'multiline':False]
['text':'/ @return  NULL when there is an error.','line_number':1121,'multiline':False]
['text':' Set "v:val" to the bad word.','line_number':1130,'multiline':False]
['text':'/ Get spell word from an entry from spellsuggest=expr:','line_number':1159,'multiline':False]
['text':'/','line_number':1160,'multiline':False]
['text':'/ Entry in question is supposed to be a list (to be checked by the caller)','line_number':1161,'multiline':False]
['text':'/ with two items: a word and a score represented as an unsigned number','line_number':1162,'multiline':False]
['text':'/ (whether it actually is unsigned is not checked).','line_number':1163,'multiline':False]
['text':'/','line_number':1164,'multiline':False]
['text':'/ Used to get the good word and score from the eval_spell_expr() result.','line_number':1165,'multiline':False]
['text':'/','line_number':1166,'multiline':False]
['text':'/ @param[in]  list  List to get values from.','line_number':1167,'multiline':False]
['text':'/ @param[out]  ret_word  Suggested word. Not initialized if return value is','line_number':1168,'multiline':False]
['text':'/                        -1.','line_number':1169,'multiline':False]
['text':'/','line_number':1170,'multiline':False]
['text':'/ @return -1 in case of error, score otherwise.','line_number':1171,'multiline':False]
['text':'/ Call some Vim script function and return the result in "*rettv".','line_number':1186,'multiline':False]
['text':'/ Uses argv[0] to argv[argc - 1] for the function arguments. argv[argc]','line_number':1187,'multiline':False]
['text':'/ should have type VAR_UNKNOWN.','line_number':1188,'multiline':False]
['text':'/','line_number':1189,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':1190,'multiline':False]
['text':' tv_clear() uses this.','line_number':1208,'multiline':False]
['text':'/ Call Vim script function and return the result as a string.','line_number':1224,'multiline':False]
['text':'/ Uses "argv[0]" to "argv[argc - 1]" for the function arguments. "argv[argc]"','line_number':1225,'multiline':False]
['text':'/ should have type VAR_UNKNOWN.','line_number':1226,'multiline':False]
['text':'/','line_number':1227,'multiline':False]
['text':'/ @param[in]  func  Function name.','line_number':1228,'multiline':False]
['text':'/ @param[in]  argc  Number of arguments.','line_number':1229,'multiline':False]
['text':'/ @param[in]  argv  Array with typval_T arguments.','line_number':1230,'multiline':False]
['text':'/','line_number':1231,'multiline':False]
['text':'/ @return [allocated] NULL when calling function fails, allocated string','line_number':1232,'multiline':False]
['text':'/                     otherwise.','line_number':1233,'multiline':False]
['text':' All arguments are passed as strings, no conversion to number.','line_number':1238,'multiline':False]
['text':'/ Call Vim script function and return the result as a List.','line_number':1249,'multiline':False]
['text':'/ Uses "argv" and "argc" as call_func_retstr().','line_number':1250,'multiline':False]
['text':'/','line_number':1251,'multiline':False]
['text':'/ @param[in]  func  Function name.','line_number':1252,'multiline':False]
['text':'/ @param[in]  argc  Number of arguments.','line_number':1253,'multiline':False]
['text':'/ @param[in]  argv  Array with typval_T arguments.','line_number':1254,'multiline':False]
['text':'/','line_number':1255,'multiline':False]
['text':'/ @return [allocated] NULL when calling function fails or return tv is not a','line_number':1256,'multiline':False]
['text':'/                     List, allocated List otherwise.','line_number':1257,'multiline':False]
['text':' All arguments are passed as strings, no conversion to number.','line_number':1263,'multiline':False]
['text':'/ Evaluate 'foldexpr'.  Returns the foldlevel, and any character preceding','line_number':1276,'multiline':False]
['text':'/ it in "*cp".  Doesn't give error messages.','line_number':1277,'multiline':False]
['text':' If the result is a number, just return the number.','line_number':1298,'multiline':False]
['text':' If the result is a string, check if there is a non-digit before','line_number':1304,'multiline':False]
['text':' the number.','line_number':1305,'multiline':False]
['text':'/ Evaluate 'foldtext', returning an Array or a String (NULL_STRING on failure).','line_number':1326,'multiline':False]
['text':'/ Get an lvalue','line_number':1362,'multiline':False]
['text':'/','line_number':1363,'multiline':False]
['text':'/ Lvalue may be','line_number':1364,'multiline':False]
['text':'/ - variable: "name", "na{me}"','line_number':1365,'multiline':False]
['text':'/ - dictionary item: "dict.key", "dict['key']"','line_number':1366,'multiline':False]
['text':'/ - list item: "list[expr]"','line_number':1367,'multiline':False]
['text':'/ - list slice: "list[expr:expr]"','line_number':1368,'multiline':False]
['text':'/','line_number':1369,'multiline':False]
['text':'/ Indexing only works if trying to use it with an existing List or Dictionary.','line_number':1370,'multiline':False]
['text':'/','line_number':1371,'multiline':False]
['text':'/ @param[in]  name  Name to parse.','line_number':1372,'multiline':False]
['text':'/ @param  rettv  Pointer to the value to be assigned or NULL.','line_number':1373,'multiline':False]
['text':'/ @param[out]  lp  Lvalue definition. When evaluation errors occur `->ll_name`','line_number':1374,'multiline':False]
['text':'/                  is NULL.','line_number':1375,'multiline':False]
['text':'/ @param[in]  unlet  True if using `:unlet`. This results in slightly','line_number':1376,'multiline':False]
['text':'/                    different behaviour when something is wrong; must end in','line_number':1377,'multiline':False]
['text':'/                    space or cmd separator.','line_number':1378,'multiline':False]
['text':'/ @param[in]  skip  True when skipping.','line_number':1379,'multiline':False]
['text':'/ @param[in]  flags  @see GetLvalFlags.','line_number':1380,'multiline':False]
['text':'/ @param[in]  fne_flags  Flags for find_name_end().','line_number':1381,'multiline':False]
['text':'/','line_number':1382,'multiline':False]
['text':'/ @return A pointer to just after the name, including indexes. Returns NULL','line_number':1383,'multiline':False]
['text':'/         for a parsing error, but it is still needed to free items in lp.','line_number':1384,'multiline':False]
['text':' Clear everything in "lp".','line_number':1392,'multiline':False]
['text':' When skipping just find the end of the name.','line_number':1396,'multiline':False]
['text':' Find the end of the name.','line_number':1401,'multiline':False]
['text':' Don't expand the name when we already know there is an error.','line_number':1408,'multiline':False]
['text':' Report an invalid expression in braces, unless the','line_number':1418,'multiline':False]
['text':' expression evaluation has been cancelled due to an','line_number':1419,'multiline':False]
['text':' aborting error, an interrupt, or an exception.','line_number':1420,'multiline':False]
['text':' Without [idx] or .key we are done.','line_number':1435,'multiline':False]
['text':' Only pass &ht when we would write to the variable, it prevents autoload','line_number':1442,'multiline':False]
['text':' as well.','line_number':1443,'multiline':False]
['text':' For v:lua just return a pointer to the "." after the "v:lua".','line_number':1458,'multiline':False]
['text':' If the caller is trans_function_name() it will check for a Lua function name.','line_number':1459,'multiline':False]
['text':' Loop until no more [idx] or .key is following.','line_number':1463,'multiline':False]
['text':' a NULL list/blob works like an empty list/blob, allocate one now.','line_number':1484,'multiline':False]
['text':' Get the index [expr] or the first index [expr: ].','line_number':1511,'multiline':False]
['text':' Recursive!','line_number':1517,'multiline':False]
['text':' Not a number or string.','line_number':1521,'multiline':False]
['text':' Optionally get the second index [ :expr].','line_number':1528,'multiline':False]
['text':' Recursive!','line_number':1551,'multiline':False]
['text':' Not a number or string.','line_number':1557,'multiline':False]
['text':' Skip to past ']'.','line_number':1577,'multiline':False]
['text':' "[key]": get key from "var1"','line_number':1583,'multiline':False]
['text':' is number or string','line_number':1584,'multiline':False]
['text':' When assigning to a scope dictionary check that a function and','line_number':1590,'multiline':False]
['text':' variable name is valid (only variable name unless it is l: or','line_number':1591,'multiline':False]
['text':' g: dictionary). Disallow overwriting a builtin function.','line_number':1592,'multiline':False]
['text':' Avoid compiler warning.','line_number':1599,'multiline':False]
['text':' Can't add "v:" or "a:" variable.','line_number':1622,'multiline':False]
['text':' Key does not exist in dict: may need to add it.','line_number':1630,'multiline':False]
['text':' existing variable, need to check if it can be changed','line_number':1645,'multiline':False]
['text':' Get the number and item for the only or first index of the List.','line_number':1656,'multiline':False]
['text':' Is number or string.','line_number':1660,'multiline':False]
['text':' Get the number and item for the only or first index of the List.','line_number':1681,'multiline':False]
['text':' Is number or string.','line_number':1685,'multiline':False]
['text':' May need to find the item or absolute index for the second','line_number':1698,'multiline':False]
['text':' index of a range.','line_number':1699,'multiline':False]
['text':' When no index given: "lp->ll_empty2" is true.','line_number':1700,'multiline':False]
['text':' Otherwise "lp->ll_n2" is set to the second index.','line_number':1701,'multiline':False]
['text':' Is number or string.','line_number':1703,'multiline':False]
['text':'/ Clear lval "lp" that was filled by get_lval().','line_number':1720,'multiline':False]
['text':'/ Set a variable that was parsed by get_lval() to "rettv".','line_number':1727,'multiline':False]
['text':'/','line_number':1728,'multiline':False]
['text':'/ @param endp  points to just after the parsed name.','line_number':1729,'multiline':False]
['text':'/ @param op    NULL, "+" for "+=", "-" for "-=", "*" for "*=", "/" for "/=",','line_number':1730,'multiline':False]
['text':'/              "%" for "%=", "." for ".=" or "=" for "=".','line_number':1731,'multiline':False]
['text':' handle +=, -=, *=, /=, %= and .=','line_number':1774,'multiline':False]
['text':' Skip','line_number':1794,'multiline':False]
['text':' Assign to a List or Dictionary item.','line_number':1813,'multiline':False]
['text':' Need to add an item to the Dictionary.','line_number':1823,'multiline':False]
['text':' Assign the value to the variable or list item.','line_number':1843,'multiline':False]
['text':'/ Evaluate the expression used in a ":for var in expr" command.','line_number':1867,'multiline':False]
['text':'/ "arg" points to "var".','line_number':1868,'multiline':False]
['text':'/','line_number':1869,'multiline':False]
['text':'/ @param[out] *errp  set to true for an error, false otherwise;','line_number':1870,'multiline':False]
['text':'/','line_number':1871,'multiline':False]
['text':'/ @return  a pointer that holds the info.  Null when there is an error.','line_number':1872,'multiline':False]
['text':' Default: there is an error.','line_number':1880,'multiline':False]
['text':' a null list is like an empty list: do nothing','line_number':1904,'multiline':False]
['text':' No need to increment the refcount, it's already set for','line_number':1907,'multiline':False]
['text':' the list being used in "tv".','line_number':1908,'multiline':False]
['text':' Make a copy, so that the iteration still works when the','line_number':1918,'multiline':False]
['text':' blob is changed.','line_number':1919,'multiline':False]
['text':'/ Use the first item in a ":for" list.  Advance to the next.','line_number':1944,'multiline':False]
['text':'/ Assign the values to the variable (list).  "arg" points to the first one.','line_number':1945,'multiline':False]
['text':'/','line_number':1946,'multiline':False]
['text':'/ @return  true when a valid item was found, false when at end of list or','line_number':1947,'multiline':False]
['text':'/          something wrong.','line_number':1948,'multiline':False]
['text':'/ Free the structure used to store info used by ":for".','line_number':1990,'multiline':False]
['text':' ":let var1 var2 ...": find last space.','line_number':2017,'multiline':False]
['text':' environment variable','line_number':2046,'multiline':False]
['text':' Autoload function/variable contains '#'','line_number':2053,'multiline':False]
['text':' Function name can start with "<SNR>" and contain '#'.','line_number':2058,'multiline':False]
['text':' string','line_number':2061,'multiline':False]
['text':' literal string','line_number':2068,'multiline':False]
['text':' Trick: '' is like stopping and starting a literal string.','line_number':2069,'multiline':False]
['text':' Doesn't look like something valid, expand as an expression','line_number':2083,'multiline':False]
['text':' anyway.','line_number':2084,'multiline':False]
['text':' ":exe one two" completes "two"','line_number':2093,'multiline':False]
['text':'/ Delete all "menutrans_" variables.','line_number':2112,'multiline':False]
['text':'/ Local string buffer for the next two functions to store a variable name','line_number':2124,'multiline':False]
['text':'/ with its prefix. Allocated in cat_prefix_varname(), freed later in','line_number':2125,'multiline':False]
['text':'/ get_user_var_name().','line_number':2126,'multiline':False]
['text':'/ Function to concatenate a prefix and a variable name.','line_number':2131,'multiline':False]
['text':' some additional space','line_number':2139,'multiline':False]
['text':'/ Function given to ExpandGeneric() to obtain the list of user defined','line_number':2149,'multiline':False]
['text':'/ (global/buffer/window/built-in) variable names.','line_number':2150,'multiline':False]
['text':' Global variables','line_number':2165,'multiline':False]
['text':' b: variables','line_number':2181,'multiline':False]
['text':' w: variables','line_number':2195,'multiline':False]
['text':' t: variables','line_number':2209,'multiline':False]
['text':' v: variables','line_number':2223,'multiline':False]
['text':'/ Does not use 'cpo' and always uses 'magic'.','line_number':2233,'multiline':False]
['text':'/','line_number':2234,'multiline':False]
['text':'/ @return  true if "pat" matches "text".','line_number':2235,'multiline':False]
['text':' avoid 'l' flag in 'cpoptions'','line_number':2241,'multiline':False]
['text':'/ Handle a name followed by "(".  Both for just "name(arg)" and for','line_number':2254,'multiline':False]
['text':'/ "expr->name(arg)".','line_number':2255,'multiline':False]
['text':'/','line_number':2256,'multiline':False]
['text':'/ @param arg  Points to "(", will be advanced','line_number':2257,'multiline':False]
['text':'/ @param basetv  "expr" for "expr->name(arg)"','line_number':2258,'multiline':False]
['text':'/','line_number':2259,'multiline':False]
['text':'/ @return OK or FAIL.','line_number':2260,'multiline':False]
['text':' If "s" is the name of a variable of type VAR_FUNC','line_number':2275,'multiline':False]
['text':' use its contents.','line_number':2276,'multiline':False]
['text':' Need to make a copy, in case evaluating the arguments makes','line_number':2280,'multiline':False]
['text':' the name invalid.','line_number':2281,'multiline':False]
['text':' Invoke the function.','line_number':2284,'multiline':False]
['text':' If evaluate is false rettv->v_type was not set in','line_number':2296,'multiline':False]
['text':' get_func_tv, but it's needed in handle_subscript() to parse','line_number':2297,'multiline':False]
['text':' what follows. So set it here.','line_number':2298,'multiline':False]
['text':' Stop the expression evaluation when immediately','line_number':2304,'multiline':False]
['text':' aborting on error, or when an interrupt occurred or','line_number':2305,'multiline':False]
['text':' an exception was thrown but not caught.','line_number':2306,'multiline':False]
['text':'/ After using "evalarg" filled from "eap": free the memory.','line_number':2316,'multiline':False]
['text':' We may need to keep the original command line, e.g. for','line_number':2322,'multiline':False]
['text':' ":let" it has the variable names.  But we may also need the','line_number':2323,'multiline':False]
['text':' new one, "nextcmd" points into it.  Keep both.','line_number':2324,'multiline':False]
['text':'/ The "evaluate" argument: When false, the argument is only parsed but not','line_number':2336,'multiline':False]
['text':'/ executed.  The function may return OK, but the rettv will be of type','line_number':2337,'multiline':False]
['text':'/ VAR_UNKNOWN.  The function still returns FAIL for a syntax error.','line_number':2338,'multiline':False]
['text':'/ Handle zero level expression.','line_number':2340,'multiline':False]
['text':'/ This calls eval1() and handles error message and nextcmd.','line_number':2341,'multiline':False]
['text':'/ Put the result in "rettv" when returning OK and "evaluate" is true.','line_number':2342,'multiline':False]
['text':'/ Note: "rettv.v_lock" is not set.','line_number':2343,'multiline':False]
['text':'/','line_number':2344,'multiline':False]
['text':'/ @param evalarg  can be NULL, &EVALARG_EVALUATE or a pointer.','line_number':2345,'multiline':False]
['text':'/','line_number':2346,'multiline':False]
['text':'/ @return OK or FAIL.','line_number':2347,'multiline':False]
['text':' Report the invalid expression unless the expression evaluation has','line_number':2364,'multiline':False]
['text':' been cancelled due to an aborting error, an interrupt, or an','line_number':2365,'multiline':False]
['text':' exception, or we already gave a more specific error.','line_number':2366,'multiline':False]
['text':' Also check called_emsg for when using assert_fails().','line_number':2367,'multiline':False]
['text':' Some of the expression may not have been consumed.','line_number':2379,'multiline':False]
['text':' Only execute a next command if it cannot be a "||" operator.','line_number':2380,'multiline':False]
['text':' The next command may be "catch".','line_number':2381,'multiline':False]
['text':'/ Handle top level expression:','line_number':2397,'multiline':False]
['text':'/      expr2 ? expr1 : expr1','line_number':2398,'multiline':False]
['text':'/      expr2 ?? expr1','line_number':2399,'multiline':False]
['text':'/','line_number':2400,'multiline':False]
['text':'/ "arg" must point to the first non-white of the expression.','line_number':2401,'multiline':False]
['text':'/ "arg" is advanced to the next non-white after the recognized expression.','line_number':2402,'multiline':False]
['text':'/','line_number':2403,'multiline':False]
['text':'/ Note: "rettv.v_lock" is not set.','line_number':2404,'multiline':False]
['text':'/','line_number':2405,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':2406,'multiline':False]
['text':' Get the first variable.','line_number':2409,'multiline':False]
['text':' Get the second variable.  Recursive!','line_number':2443,'multiline':False]
['text':' Check for the ":".','line_number':2460,'multiline':False]
['text':' Get the third variable.  Recursive!','line_number':2471,'multiline':False]
['text':'/ Handle first level expression:','line_number':2496,'multiline':False]
['text':'/      expr2 || expr2 || expr2     logical OR','line_number':2497,'multiline':False]
['text':'/','line_number':2498,'multiline':False]
['text':'/ "arg" must point to the first non-white of the expression.','line_number':2499,'multiline':False]
['text':'/ "arg" is advanced to the next non-white after the recognized expression.','line_number':2500,'multiline':False]
['text':'/','line_number':2501,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':2502,'multiline':False]
['text':' Get the first variable.','line_number':2505,'multiline':False]
['text':' Handle the  "||" operator.','line_number':2510,'multiline':False]
['text':' Repeat until there is no following "||".','line_number':2535,'multiline':False]
['text':' Get the second variable.','line_number':2537,'multiline':False]
['text':' Compute the result.','line_number':2545,'multiline':False]
['text':'/ Handle second level expression:','line_number':2574,'multiline':False]
['text':'/      expr3 && expr3 && expr3     logical AND','line_number':2575,'multiline':False]
['text':'/','line_number':2576,'multiline':False]
['text':'/ @param arg  must point to the first non-white of the expression.','line_number':2577,'multiline':False]
['text':'/             `arg` is advanced to the next non-white after the recognized expression.','line_number':2578,'multiline':False]
['text':'/','line_number':2579,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':2580,'multiline':False]
['text':' Get the first variable.','line_number':2583,'multiline':False]
['text':' Handle the "&&" operator.','line_number':2589,'multiline':False]
['text':' Repeat until there is no following "&&".','line_number':2613,'multiline':False]
['text':' Get the second variable.','line_number':2615,'multiline':False]
['text':' Compute the result.','line_number':2623,'multiline':False]
['text':'/ Handle third level expression:','line_number':2652,'multiline':False]
['text':'/      var1 == var2','line_number':2653,'multiline':False]
['text':'/      var1 =~ var2','line_number':2654,'multiline':False]
['text':'/      var1 != var2','line_number':2655,'multiline':False]
['text':'/      var1 !~ var2','line_number':2656,'multiline':False]
['text':'/      var1 > var2','line_number':2657,'multiline':False]
['text':'/      var1 >= var2','line_number':2658,'multiline':False]
['text':'/      var1 < var2','line_number':2659,'multiline':False]
['text':'/      var1 <= var2','line_number':2660,'multiline':False]
['text':'/      var1 is var2','line_number':2661,'multiline':False]
['text':'/      var1 isnot var2','line_number':2662,'multiline':False]
['text':'/','line_number':2663,'multiline':False]
['text':'/ "arg" must point to the first non-white of the expression.','line_number':2664,'multiline':False]
['text':'/ "arg" is advanced to the next non-white after the recognized expression.','line_number':2665,'multiline':False]
['text':'/','line_number':2666,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':2667,'multiline':False]
['text':' Get the first variable.','line_number':2674,'multiline':False]
['text':' If there is a comparative operator, use it.','line_number':2723,'multiline':False]
['text':' extra question mark appended: ignore case','line_number':2726,'multiline':False]
['text':' extra '#' appended: match case','line_number':2730,'multiline':False]
['text':' nothing appended: use 'ignorecase'','line_number':2733,'multiline':False]
['text':' Get the second variable.','line_number':2737,'multiline':False]
['text':'/ Make a copy of blob "tv1" and append blob "tv2".','line_number':2754,'multiline':False]
['text':'/ Make a copy of list "tv1" and append list "tv2".','line_number':2772,'multiline':False]
['text':' Concatenate Lists.','line_number':2776,'multiline':False]
['text':'/ Handle fourth level expression:','line_number':2787,'multiline':False]
['text':'/      +       number addition, concatenation of list or blob','line_number':2788,'multiline':False]
['text':'/      -       number subtraction','line_number':2789,'multiline':False]
['text':'/      .       string concatenation','line_number':2790,'multiline':False]
['text':'/      ..      string concatenation','line_number':2791,'multiline':False]
['text':'/','line_number':2792,'multiline':False]
['text':'/ @param arg  must point to the first non-white of the expression.','line_number':2793,'multiline':False]
['text':'/             `arg` is advanced to the next non-white after the recognized expression.','line_number':2794,'multiline':False]
['text':'/','line_number':2795,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':2796,'multiline':False]
['text':' Get the first variable.','line_number':2799,'multiline':False]
['text':' Repeat computing, until no '+', '-' or '.' is following.','line_number':2804,'multiline':False]
['text':' For "list + ...", an illegal use of the first operand as','line_number':2815,'multiline':False]
['text':' a number cannot be determined before evaluating the 2nd','line_number':2816,'multiline':False]
['text':' operand: if this is also a list, all is ok.','line_number':2817,'multiline':False]
['text':' For "something . ...", "something - ..." or "non-list + ...",','line_number':2818,'multiline':False]
['text':' we know that the first operand needs to be a string or number','line_number':2819,'multiline':False]
['text':' without evaluating the 2nd operand.  So check before to avoid','line_number':2820,'multiline':False]
['text':' side effects after an error.','line_number':2821,'multiline':False]
['text':' Get the second variable.','line_number':2828,'multiline':False]
['text':' ..string concatenation','line_number':2829,'multiline':False]
['text':' Compute the result.','line_number':2840,'multiline':False]
['text':' s1 already checked','line_number':2844,'multiline':False]
['text':' Type error?','line_number':2847,'multiline':False]
['text':' This can only happen for "list + non-list" or','line_number':2873,'multiline':False]
['text':' "blob + non-blob".  For "non-list + ..." or','line_number':2874,'multiline':False]
['text':' "something - ...", we returned before evaluating the','line_number':2875,'multiline':False]
['text':' 2nd operand.','line_number':2876,'multiline':False]
['text':' If there is a float on either side the result is a float.','line_number':2901,'multiline':False]
['text':'/ Handle fifth level expression:','line_number':2926,'multiline':False]
['text':'/  - *  number multiplication','line_number':2927,'multiline':False]
['text':'/  - /  number division','line_number':2928,'multiline':False]
['text':'/  - %  number modulo','line_number':2929,'multiline':False]
['text':'/','line_number':2930,'multiline':False]
['text':'/ @param[in,out]  arg  Points to the first non-whitespace character of the','line_number':2931,'multiline':False]
['text':'/                      expression.  Is advanced to the next non-whitespace','line_number':2932,'multiline':False]
['text':'/                      character after the recognized expression.','line_number':2933,'multiline':False]
['text':'/ @param[out]  rettv  Location where result is saved.','line_number':2934,'multiline':False]
['text':'/ @param[in]  want_string  True if "." is string_concatenation, otherwise','line_number':2935,'multiline':False]
['text':'/                          float','line_number':2936,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':2937,'multiline':False]
['text':' Get the first variable.','line_number':2943,'multiline':False]
['text':' Repeat computing, until no '*', '/' or '%' is following.','line_number':2948,'multiline':False]
['text':' Get the second variable.','line_number':2975,'multiline':False]
['text':' Compute the result.','line_number':3001,'multiline':False]
['text':' When either side is a float the result is a float.','line_number':3002,'multiline':False]
['text':' uncrustify:off','line_number':3007,'multiline':False]
['text':' Division by zero triggers error from AddressSanitizer','line_number':3009,'multiline':False]
['text':' uncrustify:on','line_number':3016,'multiline':False]
['text':'/ Handle sixth level expression:','line_number':3040,'multiline':False]
['text':'/  number  number constant','line_number':3041,'multiline':False]
['text':'/  0zFFFFFFFF  Blob constant','line_number':3042,'multiline':False]
['text':'/  "string"  string constant','line_number':3043,'multiline':False]
['text':'/  'string'  literal string constant','line_number':3044,'multiline':False]
['text':'/  &option-name option value','line_number':3045,'multiline':False]
['text':'/  @r   register contents','line_number':3046,'multiline':False]
['text':'/  identifier  variable value','line_number':3047,'multiline':False]
['text':'/  function()  function call','line_number':3048,'multiline':False]
['text':'/  $VAR  environment variable','line_number':3049,'multiline':False]
['text':'/  (expression) nested expression','line_number':3050,'multiline':False]
['text':'/  [expr, expr] List','line_number':3051,'multiline':False]
['text':'/  {key: val, key: val}  Dictionary','line_number':3052,'multiline':False]
['text':'/  #{key: val, key: val}  Dictionary with literal keys','line_number':3053,'multiline':False]
['text':'/','line_number':3054,'multiline':False]
['text':'/  Also handle:','line_number':3055,'multiline':False]
['text':'/  ! in front  logical NOT','line_number':3056,'multiline':False]
['text':'/  - in front  unary minus','line_number':3057,'multiline':False]
['text':'/  + in front  unary plus (ignored)','line_number':3058,'multiline':False]
['text':'/  trailing []  subscript in String or List','line_number':3059,'multiline':False]
['text':'/  trailing .name entry in Dictionary','line_number':3060,'multiline':False]
['text':'/  trailing ->name()  method call','line_number':3061,'multiline':False]
['text':'/','line_number':3062,'multiline':False]
['text':'/ "arg" must point to the first non-white of the expression.','line_number':3063,'multiline':False]
['text':'/ "arg" is advanced to the next non-white after the recognized expression.','line_number':3064,'multiline':False]
['text':'/','line_number':3065,'multiline':False]
['text':'/ @param want_string  after "." operator','line_number':3066,'multiline':False]
['text':'/','line_number':3067,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':3068,'multiline':False]
['text':' Initialise variable so that tv_clear() can't mistake this for a','line_number':3075,'multiline':False]
['text':' string and free a string that isn't there.','line_number':3076,'multiline':False]
['text':' Skip '!', '-' and '+' characters.  They are handled later.','line_number':3079,'multiline':False]
['text':' Limit recursion to 1000 levels.  At least at 10000 we run out of stack','line_number':3086,'multiline':False]
['text':' and crash.  With MSVC the stack is smaller.','line_number':3087,'multiline':False]
['text':' Number constant.','line_number':3101,'multiline':False]
['text':' Apply prefixed "-" and "+" now.  Matters especially when','line_number':3114,'multiline':False]
['text':' "->" follows.','line_number':3115,'multiline':False]
['text':' String constant: "string".','line_number':3121,'multiline':False]
['text':' Literal string constant: 'str''ing'.','line_number':3126,'multiline':False]
['text':' List: [expr, expr]','line_number':3131,'multiline':False]
['text':' Dictionary: #{key: val, key: val}','line_number':3136,'multiline':False]
['text':' Lambda: {arg, arg -> expr}','line_number':3146,'multiline':False]
['text':' Dictionary: {'key': val, 'key': val}','line_number':3147,'multiline':False]
['text':' Option value: &name','line_number':3155,'multiline':False]
['text':' Environment variable: $VAR.','line_number':3159,'multiline':False]
['text':' Interpolated string: $"string" or $'string'.','line_number':3160,'multiline':False]
['text':' Register contents: @r.','line_number':3169,'multiline':False]
['text':' nested expression: (expression).','line_number':3181,'multiline':False]
['text':' recursive!','line_number':3185,'multiline':False]
['text':' Must be a variable or function name.','line_number':3201,'multiline':False]
['text':' Can also be a curly-braces kind of name: {expr}.','line_number':3202,'multiline':False]
['text':' "name(..."  recursive!','line_number':3215,'multiline':False]
['text':' get value of variable','line_number':3219,'multiline':False]
['text':' skip the name','line_number':3222,'multiline':False]
['text':' Handle following '[', '(' and '.' for expr[expr], expr.name,','line_number':3232,'multiline':False]
['text':' expr(expr), expr->name(expr)','line_number':3233,'multiline':False]
['text':' Apply logical NOT and unary '-', from right to left, ignore '+'.','line_number':3238,'multiline':False]
['text':'/ Apply the leading "!" and "-" before an eval7 expression to "rettv".','line_number':3247,'multiline':False]
['text':'/ Adjusts "end_leaderp" until it is at "start_leader".','line_number':3248,'multiline':False]
['text':'/','line_number':3249,'multiline':False]
['text':'/ @param numeric_only  if true only handle "+" and "-".','line_number':3250,'multiline':False]
['text':'/','line_number':3251,'multiline':False]
['text':'/ @return  OK on success, FAIL on failure.','line_number':3252,'multiline':False]
['text':'/ Call the function referred to in "rettv".','line_number':3306,'multiline':False]
['text':'/ @param lua_funcname  If `rettv` refers to a v:lua function, this must point','line_number':3307,'multiline':False]
['text':'/                      to the name of the Lua function to call (after the','line_number':3308,'multiline':False]
['text':'/                      "v:lua." prefix).','line_number':3309,'multiline':False]
['text':'/ @return  OK on success, FAIL on failure.','line_number':3310,'multiline':False]
['text':' need to copy the funcref so that we can clear rettv','line_number':3322,'multiline':False]
['text':' Invoke the function.  Recursive!','line_number':3327,'multiline':False]
['text':' Clear the funcref afterwards, so that deleting it while','line_number':3355,'multiline':False]
['text':' evaluating the arguments is possible (see test55).','line_number':3356,'multiline':False]
['text':'/ Evaluate "->method()".','line_number':3364,'multiline':False]
['text':'/','line_number':3365,'multiline':False]
['text':'/ @param verbose  if true, give error messages.','line_number':3366,'multiline':False]
['text':'/ @param *arg     points to the '-'.','line_number':3367,'multiline':False]
['text':'/','line_number':3368,'multiline':False]
['text':'/ @return  FAIL or OK.','line_number':3369,'multiline':False]
['text':'/','line_number':3370,'multiline':False]
['text':'/ @note "*arg" is advanced to after the ')'.','line_number':3371,'multiline':False]
['text':' Skip over the ->.','line_number':3377,'multiline':False]
['text':' Clear the funcref afterwards, so that deleting it while','line_number':3399,'multiline':False]
['text':' evaluating the arguments is possible (see test55).','line_number':3400,'multiline':False]
['text':'/ Evaluate "->method()" or "->v:lua.method()".','line_number':3408,'multiline':False]
['text':'/','line_number':3409,'multiline':False]
['text':'/ @param *arg  points to the '-'.','line_number':3410,'multiline':False]
['text':'/','line_number':3411,'multiline':False]
['text':'/ @return  FAIL or OK. "*arg" is advanced to after the ')'.','line_number':3412,'multiline':False]
['text':' Skip over the ->.','line_number':3419,'multiline':False]
['text':' Locate the method name.','line_number':3424,'multiline':False]
['text':' to detect trailing whitespace later','line_number':3431,'multiline':False]
['text':' Clear the funcref afterwards, so that deleting it while','line_number':3474,'multiline':False]
['text':' evaluating the arguments is possible (see test55).','line_number':3475,'multiline':False]
['text':'/ Evaluate an "[expr]" or "[expr:expr]" index.  Also "dict.key".','line_number':3483,'multiline':False]
['text':'/ "*arg" points to the '[' or '.'.','line_number':3484,'multiline':False]
['text':'/','line_number':3485,'multiline':False]
['text':'/ @param verbose  give error messages','line_number':3486,'multiline':False]
['text':'/','line_number':3487,'multiline':False]
['text':'/ @returns FAIL or OK. "*arg" is advanced to after the ']'.','line_number':3488,'multiline':False]
['text':' dict.name','line_number':3505,'multiline':False]
['text':' something[idx]','line_number':3513,'multiline':False]
['text':'','line_number':3514,'multiline':False]
['text':' Get the (first) variable from inside the [].','line_number':3515,'multiline':False]
['text':' Recursive!','line_number':3519,'multiline':False]
['text':' Not a number or string.','line_number':3522,'multiline':False]
['text':' Get the second variable from inside the [:].','line_number':3527,'multiline':False]
['text':' Recursive!','line_number':3533,'multiline':False]
['text':' Not a number or string.','line_number':3539,'multiline':False]
['text':' Check for the ']'.','line_number':3548,'multiline':False]
['text':' skip the ']'','line_number':3559,'multiline':False]
['text':'/ Check if "rettv" can have an [index] or [sli:ce]','line_number':3577,'multiline':False]
['text':'/ slice() function','line_number':3614,'multiline':False]
['text':'/ Apply index or range to "rettv".','line_number':3625,'multiline':False]
['text':'/','line_number':3626,'multiline':False]
['text':'/ @param var1  the first index, NULL for [:expr].','line_number':3627,'multiline':False]
['text':'/ @param var2  the second index, NULL for [expr] and [expr: ]','line_number':3628,'multiline':False]
['text':'/ @param exclusive  true for slice(): second index is exclusive, use character','line_number':3629,'multiline':False]
['text':'/                                     index for string.','line_number':3630,'multiline':False]
['text':'/ Alternatively, "key" is not NULL, then key[keylen] is the dict index.','line_number':3631,'multiline':False]
['text':' Not evaluating, skipping over subscript','line_number':3662,'multiline':False]
['text':' The resulting variable is a substring.  If the indexes','line_number':3676,'multiline':False]
['text':' are out of range the result is empty.','line_number':3677,'multiline':False]
['text':' The resulting variable is a string of a single','line_number':3695,'multiline':False]
['text':' character.  If the index is too big or negative the','line_number':3696,'multiline':False]
['text':' result is empty.','line_number':3697,'multiline':False]
['text':'/ Get an option value','line_number':3758,'multiline':False]
['text':'/','line_number':3759,'multiline':False]
['text':'/ @param[in,out] arg  Points to the '&' or '+' before the option name. Is','line_number':3760,'multiline':False]
['text':'/                      advanced to the character after the option name.','line_number':3761,'multiline':False]
['text':'/ @param[out] rettv  Location where result is saved.','line_number':3762,'multiline':False]
['text':'/ @param[in] evaluate  If not true, rettv is not populated.','line_number':3763,'multiline':False]
['text':'/','line_number':3764,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':3765,'multiline':False]
['text':' has("+option")','line_number':3769,'multiline':False]
['text':' Isolate the option name and find its value.','line_number':3772,'multiline':False]
['text':' Only give error if result is going to be used.','line_number':3794,'multiline':False]
['text':' Convert boolean option value to number for backwards compatibility.','line_number':3806,'multiline':False]
['text':' put back for error messages','line_number':3815,'multiline':False]
['text':'/ Allocate a variable for a number constant.  Also deals with "0z" for blob.','line_number':3821,'multiline':False]
['text':'/','line_number':3822,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':3823,'multiline':False]
['text':' We accept a float when the format matches','line_number':3829,'multiline':False]
['text':' "[0-9]\+\.[0-9]\+\([eE][+-]\?[0-9]\+\)\?".  This is very','line_number':3830,'multiline':False]
['text':' strict to avoid backwards compatibility problems.','line_number':3831,'multiline':False]
['text':' Don't look for a float after the "." operator, so that','line_number':3832,'multiline':False]
['text':' ":let vers = 1.2.3" doesn't fail.','line_number':3833,'multiline':False]
['text':' Blob constant: 0z0123456789abcdef','line_number':3860,'multiline':False]
['text':' decimal, hex or octal number','line_number':3887,'multiline':False]
['text':'/ Evaluate a string constant and put the result in "rettv".','line_number':3906,'multiline':False]
['text':'/ "*arg" points to the double quote or to after it when "interpolate" is true.','line_number':3907,'multiline':False]
['text':'/ When "interpolate" is true reduce "{{" to "{", reduce "}}" to "}" and stop','line_number':3908,'multiline':False]
['text':'/ at a single "{".','line_number':3909,'multiline':False]
['text':'/','line_number':3910,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':3911,'multiline':False]
['text':' Find the end of the string, skipping backslashed characters.','line_number':3919,'multiline':False]
['text':' A "\<x>" form occupies at least 4 characters, and produces up','line_number':3923,'multiline':False]
['text':' to 9 characters (6 for the char and 3 for a modifier):','line_number':3924,'multiline':False]
['text':' reserve space for 5 extra.','line_number':3925,'multiline':False]
['text':' Skip to the '>' to avoid using '{' inside for string','line_number':3932,'multiline':False]
['text':' interpolation.','line_number':3933,'multiline':False]
['text':' leave "p" on the ">"','line_number':3939,'multiline':False]
['text':' start of expression','line_number':3943,'multiline':False]
['text':' single '}' is an error','line_number':3947,'multiline':False]
['text':' "{{" becomes "{", "}}" becomes "}"','line_number':3951,'multiline':False]
['text':' If only parsing, set *arg and return here','line_number':3960,'multiline':False]
['text':' Copy the string into allocated memory, handling backslashed','line_number':3966,'multiline':False]
['text':' characters.','line_number':3967,'multiline':False]
['text':' hex: "\x1", "\x12"','line_number':3989,'multiline':False]
['text':' Unicode: "\u0023"','line_number':3991,'multiline':False]
['text':' For "\u" store the number according to','line_number':4010,'multiline':False]
['text':' 'encoding'.','line_number':4011,'multiline':False]
['text':' octal: "\1", "\12", "\123"','line_number':4020,'multiline':False]
['text':' Special key, e.g.: "\<C-W>"','line_number':4039,'multiline':False]
['text':' start of expression','line_number':4064,'multiline':False]
['text':' reduce "{{" to "{" and "}}" to "}"','line_number':4067,'multiline':False]
['text':'/ Allocate a variable for a 'str''ing' constant.','line_number':4081,'multiline':False]
['text':'/ When "interpolate" is true reduce "{{" to "{" and stop at a single "{".','line_number':4082,'multiline':False]
['text':'/','line_number':4083,'multiline':False]
['text':'/ @return  OK when a "rettv" was set to the string.','line_number':4084,'multiline':False]
['text':'/          FAIL on error, "rettv" is not set.','line_number':4085,'multiline':False]
['text':' Find the end of the string, skipping ''.','line_number':4092,'multiline':False]
['text':' If only parsing return after setting "*arg"','line_number':4123,'multiline':False]
['text':' Copy the string into allocated memory, handling '' to ' reduction and','line_number':4129,'multiline':False]
['text':' any expressions.','line_number':4130,'multiline':False]
['text':'/ Evaluate a single or double quoted string possibly containing expressions.','line_number':4155,'multiline':False]
['text':'/ "arg" points to the '$'.  The result is put in "rettv".','line_number':4156,'multiline':False]
['text':'/','line_number':4157,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':4158,'multiline':False]
['text':' *arg is on the '$' character, move it to the first string character.','line_number':4166,'multiline':False]
['text':' Get the string up to the matching quote or to a single '{'.','line_number':4173,'multiline':False]
['text':' "arg" is advanced to either the quote or the '{'.','line_number':4174,'multiline':False]
['text':' found terminating quote','line_number':4189,'multiline':False]
['text':'/ @return  the function name of the partial.','line_number':4209,'multiline':False]
['text':'/ Unreference a closure: decrement the reference count and free it when it','line_number':4240,'multiline':False]
['text':'/ becomes zero.','line_number':4241,'multiline':False]
['text':'/ Allocate a variable for a List and fill it from "*arg".','line_number':4249,'multiline':False]
['text':'/','line_number':4250,'multiline':False]
['text':'/ @param arg  "*arg" points to the "[".','line_number':4251,'multiline':False]
['text':'/ @return  OK or FAIL.','line_number':4252,'multiline':False]
['text':' Recursive!','line_number':4265,'multiline':False]
['text':' the comma must come after the value','line_number':4273,'multiline':False]
['text':'/ @param ic  ignore case','line_number':4306,'multiline':False]
['text':' empty and NULL function name considered the same','line_number':4309,'multiline':False]
['text':' empty dict and NULL dict is different','line_number':4326,'multiline':False]
['text':' empty list and no list considered the same','line_number':4337,'multiline':False]
['text':'/ Get next (unique) copy ID','line_number':4352,'multiline':False]
['text':'/','line_number':4353,'multiline':False]
['text':'/ Used for traversing nested structures e.g. when serializing them or garbage','line_number':4354,'multiline':False]
['text':'/ collecting.','line_number':4355,'multiline':False]
['text':' CopyID for recursively traversing lists and dicts','line_number':4359,'multiline':False]
['text':'','line_number':4360,'multiline':False]
['text':' This value is needed to avoid endless recursiveness. Last bit is used for','line_number':4361,'multiline':False]
['text':' previous_funccal and normally ignored when comparing.','line_number':4362,'multiline':False]
['text':'/ Garbage collection for lists and dictionaries.','line_number':4368,'multiline':False]
['text':'/','line_number':4369,'multiline':False]
['text':'/ We use reference counts to be able to free most items right away when they','line_number':4370,'multiline':False]
['text':'/ are no longer used.  But for composite items it's possible that it becomes','line_number':4371,'multiline':False]
['text':'/ unused while the reference count is > 0: When there is a recursive','line_number':4372,'multiline':False]
['text':'/ reference.  Example:','line_number':4373,'multiline':False]
['text':'/      :let l = [1, 2, 3]','line_number':4374,'multiline':False]
['text':'/      :let d = {9: l}','line_number':4375,'multiline':False]
['text':'/      :let l[1] = d','line_number':4376,'multiline':False]
['text':'/','line_number':4377,'multiline':False]
['text':'/ Since this is quite unusual we handle this with garbage collection: every','line_number':4378,'multiline':False]
['text':'/ once in a while find out which lists and dicts are not referenced from any','line_number':4379,'multiline':False]
['text':'/ variable.','line_number':4380,'multiline':False]
['text':'/','line_number':4381,'multiline':False]
['text':'/ Here is a good reference text about garbage collection (refers to Python','line_number':4382,'multiline':False]
['text':'/ but it applies to all reference-counting mechanisms):','line_number':4383,'multiline':False]
['text':'/      http://python.ca/nas/python/gc/','line_number':4384,'multiline':False]
['text':'/ Do garbage collection for lists and dicts.','line_number':4386,'multiline':False]
['text':'/','line_number':4387,'multiline':False]
['text':'/ @param testing  true if called from test_garbagecollect_now().','line_number':4388,'multiline':False]
['text':'/','line_number':4389,'multiline':False]
['text':'/ @return  true if some memory was freed.','line_number':4390,'multiline':False]
['text':' Only do this once.','line_number':4397,'multiline':False]
['text':' The execution stack can grow big, limit the size.','line_number':4403,'multiline':False]
['text':' Keep 150% of the current size, with a minimum of the growth size.','line_number':4405,'multiline':False]
['text':' Don't make it bigger though.','line_number':4411,'multiline':False]
['text':' We advance by two (COPYID_INC) because we add one for items referenced','line_number':4420,'multiline':False]
['text':' through previous_funccal.','line_number':4421,'multiline':False]
['text':' 1. Go through all accessible variables and mark all lists and dicts','line_number':4424,'multiline':False]
['text':' with copyID.','line_number':4425,'multiline':False]
['text':' Don't free variables in the previous_funccal list unless they are only','line_number':4427,'multiline':False]
['text':' referenced through previous_funccal.  This must be first, because if','line_number':4428,'multiline':False]
['text':' the item is referenced elsewhere the funccal must not be freed.','line_number':4429,'multiline':False]
['text':' script-local variables','line_number':4432,'multiline':False]
['text':' buffer-local variables','line_number':4438,'multiline':False]
['text':' buffer marks (ShaDa additional data)','line_number':4440,'multiline':False]
['text':' buffer change list (ShaDa additional data)','line_number':4447,'multiline':False]
['text':' buffer ShaDa additional data','line_number':4451,'multiline':False]
['text':' buffer callback functions','line_number':4454,'multiline':False]
['text':' 'completefunc', 'omnifunc' and 'thesaurusfunc' callbacks','line_number':4463,'multiline':False]
['text':' 'operatorfunc' callback','line_number':4466,'multiline':False]
['text':' 'tagfunc' callback','line_number':4469,'multiline':False]
['text':' window-local variables','line_number':4473,'multiline':False]
['text':' window jump list (ShaDa additional data)','line_number':4475,'multiline':False]
['text':' window-local variables in autocmd windows','line_number':4480,'multiline':False]
['text':' registers (ShaDa additional data)','line_number':4487,'multiline':False]
['text':' global marks (ShaDa additional data)','line_number':4501,'multiline':False]
['text':' tabpage-local variables','line_number':4514,'multiline':False]
['text':' global variables','line_number':4519,'multiline':False]
['text':' function-local variables','line_number':4522,'multiline':False]
['text':' named functions (matters for closures)','line_number':4525,'multiline':False]
['text':' Channels','line_number':4528,'multiline':False]
['text':' Timers','line_number':4538,'multiline':False]
['text':' function call arguments, if v:testing is set.','line_number':4546,'multiline':False]
['text':' v: vars','line_number':4549,'multiline':False]
['text':' history items (ShaDa additional elements)','line_number':4552,'multiline':False]
['text':' previously used search/substitute patterns (ShaDa additional data)','line_number':4566,'multiline':False]
['text':' previously used replacement string','line_number':4575,'multiline':False]
['text':' 2. Free lists and dictionaries that are not referenced.','line_number':4586,'multiline':False]
['text':' 3. Check if any funccal can be freed now.','line_number':4589,'multiline':False]
['text':'    This may call us back recursively.','line_number':4590,'multiline':False]
['text':'/ Free lists and dictionaries that are no longer referenced.','line_number':4599,'multiline':False]
['text':'/','line_number':4600,'multiline':False]
['text':'/ @note  This function may only be called from garbage_collect().','line_number':4601,'multiline':False]
['text':'/','line_number':4602,'multiline':False]
['text':'/ @param copyID  Free lists/dictionaries that don't have this ID.','line_number':4603,'multiline':False]
['text':'/','line_number':4604,'multiline':False]
['text':'/ @return  true, if something was freed.','line_number':4605,'multiline':False]
['text':' Let all "free" functions know that we are here. This means no','line_number':4610,'multiline':False]
['text':' dictionaries, lists, or jobs are to be freed, because we will','line_number':4611,'multiline':False]
['text':' do that here.','line_number':4612,'multiline':False]
['text':' PASS 1: free the contents of the items. We don't free the items','line_number':4615,'multiline':False]
['text':' themselves yet, so that it is possible to decrement refcount counters.','line_number':4616,'multiline':False]
['text':' Go through the list of dicts and free items without the copyID.','line_number':4618,'multiline':False]
['text':' Don't free dicts that are referenced internally.','line_number':4619,'multiline':False]
['text':' Free the Dictionary and ordinary items it contains, but don't','line_number':4622,'multiline':False]
['text':' recurse into Lists and Dictionaries, they will be in the list','line_number':4623,'multiline':False]
['text':' of dicts or list of lists.','line_number':4624,'multiline':False]
['text':' Go through the list of lists and free items without the copyID.','line_number':4630,'multiline':False]
['text':' But don't free a list that has a watcher (used in a for loop), these','line_number':4631,'multiline':False]
['text':' are not referenced anywhere.','line_number':4632,'multiline':False]
['text':' Free the List and ordinary items it contains, but don't recurse','line_number':4636,'multiline':False]
['text':' into Lists and Dictionaries, they will be in the list of dicts','line_number':4637,'multiline':False]
['text':' or list of lists.','line_number':4638,'multiline':False]
['text':' PASS 2: free the items themselves.','line_number':4644,'multiline':False]
['text':' Free the List and ordinary items it contains, but don't recurse','line_number':4658,'multiline':False]
['text':' into Lists and Dictionaries, they will be in the list of dicts','line_number':4659,'multiline':False]
['text':' or list of lists.','line_number':4660,'multiline':False]
['text':'/ Mark all lists and dicts referenced through hashtab "ht" with "copyID".','line_number':4668,'multiline':False]
['text':'/','line_number':4669,'multiline':False]
['text':'/ @param ht            Hashtab content will be marked.','line_number':4670,'multiline':False]
['text':'/ @param copyID        New mark for lists and dicts.','line_number':4671,'multiline':False]
['text':'/ @param list_stack    Used to add lists to be marked. Can be NULL.','line_number':4672,'multiline':False]
['text':'/','line_number':4673,'multiline':False]
['text':'/ @returns             true if setting references failed somehow.','line_number':4674,'multiline':False]
['text':' Mark each item in the hashtab.  If the item contains a hashtab','line_number':4684,'multiline':False]
['text':' it is added to ht_stack, if it contains a list it is added to','line_number':4685,'multiline':False]
['text':' list_stack.','line_number':4686,'multiline':False]
['text':' take an item from the stack','line_number':4696,'multiline':False]
['text':'/ Mark all lists and dicts referenced through list "l" with "copyID".','line_number':4706,'multiline':False]
['text':'/','line_number':4707,'multiline':False]
['text':'/ @param l             List content will be marked.','line_number':4708,'multiline':False]
['text':'/ @param copyID        New mark for lists and dicts.','line_number':4709,'multiline':False]
['text':'/ @param ht_stack      Used to add hashtabs to be marked. Can be NULL.','line_number':4710,'multiline':False]
['text':'/','line_number':4711,'multiline':False]
['text':'/ @returns             true if setting references failed somehow.','line_number':4712,'multiline':False]
['text':' Mark each item in the list.  If the item contains a hashtab','line_number':4721,'multiline':False]
['text':' it is added to ht_stack, if it contains a list it is added to','line_number':4722,'multiline':False]
['text':' list_stack.','line_number':4723,'multiline':False]
['text':' take an item from the stack','line_number':4736,'multiline':False]
['text':'/ Mark all lists and dicts referenced through typval "tv" with "copyID".','line_number':4746,'multiline':False]
['text':'/','line_number':4747,'multiline':False]
['text':'/ @param tv            Typval content will be marked.','line_number':4748,'multiline':False]
['text':'/ @param copyID        New mark for lists and dicts.','line_number':4749,'multiline':False]
['text':'/ @param ht_stack      Used to add hashtabs to be marked. Can be NULL.','line_number':4750,'multiline':False]
['text':'/ @param list_stack    Used to add lists to be marked. Can be NULL.','line_number':4751,'multiline':False]
['text':'/','line_number':4752,'multiline':False]
['text':'/ @returns             true if setting references failed somehow.','line_number':4753,'multiline':False]
['text':' Didn't see this dict yet.','line_number':4763,'multiline':False]
['text':' Didn't see this list yet.','line_number':4787,'multiline':False]
['text':' A partial does not have a copyID, because it cannot contain itself.','line_number':4804,'multiline':False]
['text':'/ Mark all lists and dicts referenced in given mark','line_number':4837,'multiline':False]
['text':'/','line_number':4838,'multiline':False]
['text':'/ @return  true if setting references failed somehow.','line_number':4839,'multiline':False]
['text':'/ Mark all lists and dicts referenced in given list and the list itself','line_number':4851,'multiline':False]
['text':'/','line_number':4852,'multiline':False]
['text':'/ @return  true if setting references failed somehow.','line_number':4853,'multiline':False]
['text':'/ Mark all lists and dicts referenced in given dict and the dict itself','line_number':4867,'multiline':False]
['text':'/','line_number':4868,'multiline':False]
['text':'/ @return  true if setting references failed somehow.','line_number':4869,'multiline':False]
['text':'/ Get the key for #{key: val} into "tv" and advance "arg".','line_number':4883,'multiline':False]
['text':'/','line_number':4884,'multiline':False]
['text':'/ @return  FAIL when there is no valid key.','line_number':4885,'multiline':False]
['text':'/ Allocate a variable for a Dictionary and fill it from "*arg".','line_number':4902,'multiline':False]
['text':'/','line_number':4903,'multiline':False]
['text':'/ @param arg  "*arg" points to the "{".','line_number':4904,'multiline':False]
['text':'/ @param literal  true for #{key: val}','line_number':4905,'multiline':False]
['text':'/','line_number':4906,'multiline':False]
['text':'/ @return  OK or FAIL.  Returns NOTDONE for {expr}.','line_number':4907,'multiline':False]
['text':' First check if it's not a curly-braces expression: {expr}.','line_number':4916,'multiline':False]
['text':' Must do this without evaluating, otherwise a function may be called','line_number':4917,'multiline':False]
['text':' twice.  Unfortunately this means we need to call eval1() twice for the','line_number':4918,'multiline':False]
['text':' first item.','line_number':4919,'multiline':False]
['text':' "{}" is an empty Dictionary.','line_number':4920,'multiline':False]
['text':' "#{abc}" is never a curly-braces expression.','line_number':4921,'multiline':False]
['text':' recursive!','line_number':4941,'multiline':False]
['text':' "key" is NULL when tv_get_string_buf_chk() gave an errmsg','line_number':4952,'multiline':False]
['text':' Recursive!','line_number':4959,'multiline':False]
['text':' the comma must come after the value','line_number':4982,'multiline':False]
['text':'/ Convert the string to a floating point number','line_number':5014,'multiline':False]
['text':'/','line_number':5015,'multiline':False]
['text':'/ This uses strtod().  setlocale(LC_NUMERIC, "C") has been used earlier to','line_number':5016,'multiline':False]
['text':'/ make sure this always uses a decimal point.','line_number':5017,'multiline':False]
['text':'/','line_number':5018,'multiline':False]
['text':'/ @param[in] text  String to convert.','line_number':5019,'multiline':False]
['text':'/ @param[out] ret_value  Location where conversion result is saved.','line_number':5020,'multiline':False]
['text':'/','line_number':5021,'multiline':False]
['text':'/ @return  Length of the text that was consumed.','line_number':5022,'multiline':False]
['text':' MS-Windows does not deal with "inf" and "nan" properly','line_number':5026,'multiline':False]
['text':'/ Get the value of an environment variable.','line_number':5044,'multiline':False]
['text':'/','line_number':5045,'multiline':False]
['text':'/ If the environment variable was not set, silently assume it is empty.','line_number':5046,'multiline':False]
['text':'/','line_number':5047,'multiline':False]
['text':'/ @param arg  Points to the '$'.  It is advanced to after the name.','line_number':5048,'multiline':False]
['text':'/','line_number':5049,'multiline':False]
['text':'/ @return  FAIL if the name is invalid.','line_number':5050,'multiline':False]
['text':' Invalid empty name.','line_number':5059,'multiline':False]
['text':' First try vim_getenv(), fast for normal environment vars.','line_number':5063,'multiline':False]
['text':' Next try expanding things like $VIM and ${HOME}.','line_number':5068,'multiline':False]
['text':'/ Add an assert error to v:errors.','line_number':5083,'multiline':False]
['text':' Make sure v:errors is a list.','line_number':5089,'multiline':False]
['text':'/ Implementation of map() and filter() for a Dict.','line_number':5095,'multiline':False]
['text':' map(): replace the dict item value','line_number':5139,'multiline':False]
['text':' mapnew(): add the item value to the new dict','line_number':5144,'multiline':False]
['text':' filter(false): remove the item from the dict','line_number':5151,'multiline':False]
['text':'/ Implementation of map() and filter() for a Blob.','line_number':5163,'multiline':False]
['text':'/ Implementation of map() and filter() for a String.','line_number':5227,'multiline':False]
['text':'/ Implementation of map() and filter() for a List.','line_number':5278,'multiline':False]
['text':' map(): replace the list item value','line_number':5323,'multiline':False]
['text':' mapnew(): append the list item value','line_number':5328,'multiline':False]
['text':'/ Implementation of map() and filter().','line_number':5342,'multiline':False]
['text':' map() and filter() return the first argument, also on failure.','line_number':5356,'multiline':False]
['text':' On type errors, the preceding call has already displayed an error','line_number':5370,'multiline':False]
['text':' message.  Avoid a misleading error message for an empty string that','line_number':5371,'multiline':False]
['text':' was not passed as argument.','line_number':5372,'multiline':False]
['text':' We reset "did_emsg" to be able to detect whether an error','line_number':5377,'multiline':False]
['text':' occurred during evaluation of the expression.','line_number':5378,'multiline':False]
['text':'/ Handle one item for map() and filter().','line_number':5404,'multiline':False]
['text':'/ Sets v:val to "tv".  Caller must set v:key.','line_number':5405,'multiline':False]
['text':'/','line_number':5406,'multiline':False]
['text':'/ @param tv     original value','line_number':5407,'multiline':False]
['text':'/ @param expr   callback','line_number':5408,'multiline':False]
['text':'/ @param newtv  for map() an mapnew(): new value','line_number':5409,'multiline':False]
['text':'/ @param remp   for filter(): remove flag','line_number':5410,'multiline':False]
['text':' filter(): when expr is zero remove the item','line_number':5427,'multiline':False]
['text':' On type error, nothing has been removed; return FAIL to stop the','line_number':5430,'multiline':False]
['text':' loop.  The error message was given by tv_get_number_chk().','line_number':5431,'multiline':False]
['text':'/ "filter()" function','line_number':5442,'multiline':False]
['text':'/ "map()" function','line_number':5448,'multiline':False]
['text':'/ "mapnew()" function','line_number':5454,'multiline':False]
['text':'/ "function()" function','line_number':5460,'multiline':False]
['text':'/ "funcref()" function','line_number':5461,'multiline':False]
['text':' function(MyFunc, [arg], dict)','line_number':5471,'multiline':False]
['text':' function(dict.MyFunc, [arg])','line_number':5475,'multiline':False]
['text':' TODO(bfredl): do the entire nlua_is_table_from_lua dance','line_number':5478,'multiline':False]
['text':' function('MyFunc', [arg], dict)','line_number':5480,'multiline':False]
['text':' Don't check an autoload name for existence here.','line_number':5496,'multiline':False]
['text':' Expand s: and <SID> into <SNR>nr_, so that the function can','line_number':5507,'multiline':False]
['text':' also be called from another script. Using trans_function_name()','line_number':5508,'multiline':False]
['text':' would also work, but some plugins depend on the name being','line_number':5509,'multiline':False]
['text':' printable text.','line_number':5510,'multiline':False]
['text':' function(name, [args], dict)','line_number':5518,'multiline':False]
['text':' function(name, dict)','line_number':5522,'multiline':False]
['text':' function(name, [args])','line_number':5525,'multiline':False]
['text':' result is a VAR_PARTIAL','line_number':5557,'multiline':False]
['text':' For "function(dict.func, [], dict)" and "func" is a partial','line_number':5575,'multiline':False]
['text':' use "dict". That is backwards compatible.','line_number':5576,'multiline':False]
['text':' The dict is bound explicitly, pt_auto is false','line_number':5578,'multiline':False]
['text':' If the dict was bound automatically the result is also','line_number':5582,'multiline':False]
['text':' bound automatically.','line_number':5583,'multiline':False]
['text':' result is a VAR_FUNC','line_number':5608,'multiline':False]
['text':'/ Get the line number from Vimscript object','line_number':5618,'multiline':False]
['text':'/','line_number':5619,'multiline':False]
['text':'/ @note Unlike tv_get_lnum(), this one supports only "$" special string.','line_number':5620,'multiline':False]
['text':'/','line_number':5621,'multiline':False]
['text':'/ @param[in] tv   Object to get value from. Is expected to be a number or','line_number':5622,'multiline':False]
['text':'/                 a special string "$".','line_number':5623,'multiline':False]
['text':'/ @param[in] buf  Buffer to take last line number from in case tv is "$". May','line_number':5624,'multiline':False]
['text':'/                 be NULL, in this case "$" results in zero return.','line_number':5625,'multiline':False]
['text':'/','line_number':5626,'multiline':False]
['text':'/ @return  Line number or 0 in case of error.','line_number':5627,'multiline':False]
['text':'/ This function is used by f_input() and f_inputdialog() functions. The third','line_number':5641,'multiline':False]
['text':'/ argument to f_input() specifies the type of completion to use at the','line_number':5642,'multiline':False]
['text':'/ prompt. The third argument to f_inputdialog() specifies the value to return','line_number':5643,'multiline':False]
['text':'/ when the user cancels the prompt.','line_number':5644,'multiline':False]
['text':' error','line_number':5683,'multiline':False]
['text':' default to NULL','line_number':5686,'multiline':False]
['text':' input() with a third argument: completion','line_number':5721,'multiline':False]
['text':' Want to see the prompt.','line_number':5733,'multiline':False]
['text':' Only the part of the message after the last NL is considered as','line_number':5734,'multiline':False]
['text':' prompt for the command line, unlsess cmdline is externalized','line_number':5735,'multiline':False]
['text':' Since the user typed this, no need to wait for return.','line_number':5765,'multiline':False]
['text':'/ Builds a process argument vector from a Vimscript object (typval_T).','line_number':5771,'multiline':False]
['text':'/','line_number':5772,'multiline':False]
['text':'/ @param[in]  cmd_tv      Vimscript object','line_number':5773,'multiline':False]
['text':'/ @param[out] cmd         Returns the command or executable name.','line_number':5774,'multiline':False]
['text':'/ @param[out] executable  Returns `false` if argv[0] is not executable.','line_number':5775,'multiline':False]
['text':'/','line_number':5776,'multiline':False]
['text':'/ @return  Result of `shell_build_argv()` if `cmd_tv` is a String.','line_number':5777,'multiline':False]
['text':'/          Else, string values of `cmd_tv` copied to a (char **) list with','line_number':5778,'multiline':False]
['text':'/          argv[0] resolved to full path ($PATHEXT-resolved on Windows).','line_number':5779,'multiline':False]
['text':' String => "shell semantics".','line_number':5782,'multiline':False]
['text':' List must have at least one item.','line_number':5798,'multiline':False]
['text':' Build the argument vector','line_number':5818,'multiline':False]
['text':' Did emsg in tv_get_string_chk; just deallocate argv.','line_number':5824,'multiline':False]
['text':' Replace argv[0] with absolute path. The only reason for this is to make','line_number':5831,'multiline':False]
['text':' $PATHEXT work on Windows with jobstart([]). #9569','line_number':5832,'multiline':False]
['text':' TODO(bfredl): this is a hack for legacy tests which use screenchar()','line_number':5849,'multiline':False]
['text':' to check printed messages on the screen (but not floats etc','line_number':5850,'multiline':False]
['text':' as these are not legacy features). If the compositor is refactored to','line_number':5851,'multiline':False]
['text':' have its own buffer, this should just read from it instead.','line_number':5852,'multiline':False]
['text':' Make `row` and `col` relative to the grid','line_number':5857,'multiline':False]
['text':'/ "stdpath()" helper for list results','line_number':5862,'multiline':False]
['text':'/ os_system wrapper. Handles 'verbose', :profile, and v:shell_error.','line_number':5899,'multiline':False]
['text':' get input to the shell command (if any), and its length','line_number':5912,'multiline':False]
['text':' get shell command to execute','line_number':5920,'multiline':False]
['text':' Already did emsg.','line_number':5928,'multiline':False]
['text':' execute the command','line_number':5944,'multiline':False]
['text':' return an empty list when there's no output','line_number':5959,'multiline':False]
['text':' res may contain several NULs before the final terminating one.','line_number':5978,'multiline':False]
['text':' Replace them with SOH (1) like in get_cmd_output() to avoid truncation.','line_number':5979,'multiline':False]
['text':' translate <CR><NL> into <NL>','line_number':5982,'multiline':False]
['text':'/ Get a callback from "arg".  It can be a Funcref or a function name.','line_number':5998,'multiline':False]
['text':' TODO(tjdvries): UnifiedCallback','line_number':6031,'multiline':False]
['text':'/ @return  whether the callback could be called.','line_number':6062,'multiline':False]
['text':'/ invoked on the main loop','line_number':6193,'multiline':False]
['text':' if repeat was negative repeat forever','line_number':6206,'multiline':False]
['text':' Handle error message','line_number':6218,'multiline':False]
['text':' special case: timeout=0 means the callback will be','line_number':6235,'multiline':False]
['text':' invoked again on the next event loop tick.','line_number':6236,'multiline':False]
['text':' we don't use uv_idle_t to not spin the event loop','line_number':6237,'multiline':False]
['text':' when the main loop is blocked.','line_number':6238,'multiline':False]
['text':' if main loop is blocked, don't queue up multiple events','line_number':6258,'multiline':False]
['text':' avoid double free','line_number':6269,'multiline':False]
['text':'/ This will be run on the main loop after the last timer_due_cb, so at this','line_number':6277,'multiline':False]
['text':'/ point it is safe to free the callback.','line_number':6278,'multiline':False]
['text':'/ Write "list" of strings to file "fd".','line_number':6308,'multiline':False]
['text':'/','line_number':6309,'multiline':False]
['text':'/ @param  fp  File to write to.','line_number':6310,'multiline':False]
['text':'/ @param[in]  list  List to write.','line_number':6311,'multiline':False]
['text':'/ @param[in]  binary  Whether to write in binary mode.','line_number':6312,'multiline':False]
['text':'/','line_number':6313,'multiline':False]
['text':'/ @return true in case of success, false otherwise.','line_number':6314,'multiline':False]
['text':'/ Write a blob to file with descriptor `fp`.','line_number':6364,'multiline':False]
['text':'/','line_number':6365,'multiline':False]
['text':'/ @param[in]  fp  File to write to.','line_number':6366,'multiline':False]
['text':'/ @param[in]  blob  Blob to write.','line_number':6367,'multiline':False]
['text':'/','line_number':6368,'multiline':False]
['text':'/ @return true on success, or false on failure.','line_number':6369,'multiline':False]
['text':'/ Read blob from file "fd".','line_number':6392,'multiline':False]
['text':'/ Caller has allocated a blob in "rettv".','line_number':6393,'multiline':False]
['text':'/','line_number':6394,'multiline':False]
['text':'/ @param[in]  fd  File to read from.','line_number':6395,'multiline':False]
['text':'/ @param[in,out]  rettv  Blob to write to.','line_number':6396,'multiline':False]
['text':'/ @param[in]  offset  Read the file from the specified offset.','line_number':6397,'multiline':False]
['text':'/ @param[in]  size  Read the specified size, or -1 if no limit.','line_number':6398,'multiline':False]
['text':'/','line_number':6399,'multiline':False]
['text':'/ @return  OK on success, or FAIL on failure.','line_number':6400,'multiline':False]
['text':' can't read the file, error','line_number':6407,'multiline':False]
['text':' The size defaults to the whole file.  If a size is given it is','line_number':6414,'multiline':False]
['text':' limited to not go past the end of the file.','line_number':6415,'multiline':False]
['text':' size may become negative, checked below','line_number':6417,'multiline':False]
['text':' limit the offset to not go before the start of the file','line_number':6422,'multiline':False]
['text':' Size defaults to reading until the end of the file.','line_number':6426,'multiline':False]
['text':' An empty blob is returned on error.','line_number':6443,'multiline':False]
['text':'/ Saves a typval_T as a string.','line_number':6451,'multiline':False]
['text':'/','line_number':6452,'multiline':False]
['text':'/ For lists or buffers, replaces NLs with NUL and separates items with NLs.','line_number':6453,'multiline':False]
['text':'/','line_number':6454,'multiline':False]
['text':'/ @param[in]  tv   Value to store as a string.','line_number':6455,'multiline':False]
['text':'/ @param[out] len  Length of the resulting string or -1 on error.','line_number':6456,'multiline':False]
['text':'/ @param[in]  endnl If true, the output will end in a newline (if a list).','line_number':6457,'multiline':False]
['text':'/ @param[in]  crlf  If true, list items will be joined with CRLF (if a list).','line_number':6458,'multiline':False]
['text':'/ @returns an allocated string if `tv` represents a Vimscript string, list, or','line_number':6459,'multiline':False]
['text':'/          number; NULL otherwise.','line_number':6460,'multiline':False]
['text':' For other types, let tv_get_string_buf_chk() get the value or','line_number':6469,'multiline':False]
['text':' print an error.','line_number':6470,'multiline':False]
['text':' Treat number as a buffer-id.','line_number':6482,'multiline':False]
['text':' Pre-calculate the resulting length.','line_number':6515,'multiline':False]
['text':'/ Convert the specified byte index of line 'lnum' in buffer 'buf' to a','line_number':6543,'multiline':False]
['text':'/ character index.  Works only for loaded buffers. Returns -1 on failure.','line_number':6544,'multiline':False]
['text':'/ The index of the first byte and the first character is zero.','line_number':6545,'multiline':False]
['text':' count the number of characters','line_number':6562,'multiline':False]
['text':' In insert mode, when the cursor is at the end of a non-empty line,','line_number':6569,'multiline':False]
['text':' byteidx points to the NUL character immediately past the end of the','line_number':6570,'multiline':False]
['text':' string. In this case, add one to the character count.','line_number':6571,'multiline':False]
['text':'/ Convert the specified character index of line 'lnum' in buffer 'buf' to a','line_number':6579,'multiline':False]
['text':'/ byte index.  Works only for loaded buffers.','line_number':6580,'multiline':False]
['text':'/ The index of the first byte and the first character is zero.','line_number':6581,'multiline':False]
['text':'/','line_number':6582,'multiline':False]
['text':'/ @return  -1 on failure.','line_number':6583,'multiline':False]
['text':' Convert the character offset to a byte offset','line_number':6596,'multiline':False]
['text':'/ Translate a Vimscript object into a position','line_number':6605,'multiline':False]
['text':'/','line_number':6606,'multiline':False]
['text':'/ Accepts VAR_LIST and VAR_STRING objects. Does not give an error for invalid','line_number':6607,'multiline':False]
['text':'/ type.','line_number':6608,'multiline':False]
['text':'/','line_number':6609,'multiline':False]
['text':'/ @param[in]  tv  Object to translate.','line_number':6610,'multiline':False]
['text':'/ @param[in]  dollar_lnum  True when "$" is last line.','line_number':6611,'multiline':False]
['text':'/ @param[out]  ret_fnum  Set to fnum for marks.','line_number':6612,'multiline':False]
['text':'/ @param[in]  charcol  True to return character column.','line_number':6613,'multiline':False]
['text':'/','line_number':6614,'multiline':False]
['text':'/ @return Pointer to position or NULL in case of error (e.g. invalid type).','line_number':6615,'multiline':False]
['text':' Argument can be [lnum, col, coladd].','line_number':6622,'multiline':False]
['text':' Get the line number.','line_number':6631,'multiline':False]
['text':' Invalid line number.','line_number':6634,'multiline':False]
['text':' Get the column number.','line_number':6638,'multiline':False]
['text':' We accept "$" for the column number: last column.','line_number':6650,'multiline':False]
['text':' Accept a position up to the NUL after the line.','line_number':6658,'multiline':False]
['text':' Invalid column number.','line_number':6660,'multiline':False]
['text':' Get the virtual offset.  Defaults to zero.','line_number':6665,'multiline':False]
['text':' cursor','line_number':6681,'multiline':False]
['text':' Visual start','line_number':6684,'multiline':False]
['text':' mark','line_number':6691,'multiline':False]
['text':' Vimscript behavior, only provide fnum if mark is global.','line_number':6698,'multiline':False]
['text':' the "w_valid" flags are not reset when moving the cursor, but they','line_number':6711,'multiline':False]
['text':' do matter for update_topline() and validate_botline().','line_number':6712,'multiline':False]
['text':' "w0": first visible line','line_number':6716,'multiline':False]
['text':' In silent Ex mode topline is zero, but that's not a valid line','line_number':6718,'multiline':False]
['text':' number; use one instead.','line_number':6719,'multiline':False]
['text':' "w$": last visible line','line_number':6722,'multiline':False]
['text':' In silent Ex mode botline is zero, return zero then.','line_number':6724,'multiline':False]
['text':' last column or line','line_number':6728,'multiline':False]
['text':'/ Convert list in "arg" into position "posp" and optional file number "fnump".','line_number':6745,'multiline':False]
['text':'/ When "fnump" is NULL there is no file number, only 3 items: [lnum, col, off]','line_number':6746,'multiline':False]
['text':'/ Note that the column is passed on as-is, the caller may want to decrement','line_number':6747,'multiline':False]
['text':'/ it to use 1 for the first column.','line_number':6748,'multiline':False]
['text':'/','line_number':6749,'multiline':False]
['text':'/ @param charcol  if true, use the column as the character index instead of the','line_number':6750,'multiline':False]
['text':'/                 byte index.','line_number':6751,'multiline':False]
['text':'/','line_number':6752,'multiline':False]
['text':'/ @return  FAIL when conversion is not possible, doesn't check the position for','line_number':6753,'multiline':False]
['text':'/          validity.','line_number':6754,'multiline':False]
['text':' List must be: [fnum, lnum, col, coladd, curswant], where "fnum" is only','line_number':6759,'multiline':False]
['text':' there when "fnump" isn't NULL; "coladd" and "curswant" are optional.','line_number':6760,'multiline':False]
['text':' fnum','line_number':6771,'multiline':False]
['text':' Current buffer.','line_number':6776,'multiline':False]
['text':' lnum','line_number':6781,'multiline':False]
['text':' col','line_number':6787,'multiline':False]
['text':' If character position is specified, then convert to byte position','line_number':6791,'multiline':False]
['text':' If the line number is zero use the cursor line.','line_number':6792,'multiline':False]
['text':' Get the text for the specified line in a loaded buffer','line_number':6794,'multiline':False]
['text':' off','line_number':6805,'multiline':False]
['text':' curswant','line_number':6813,'multiline':False]
['text':'/ Get the length of an environment variable name.','line_number':6819,'multiline':False]
['text':'/ Advance "arg" to the first character after the name.','line_number':6820,'multiline':False]
['text':'/','line_number':6821,'multiline':False]
['text':'/ @return  0 for error.','line_number':6822,'multiline':False]
['text':' No name found.','line_number':6827,'multiline':False]
['text':'/ Get the length of the name of a function or internal variable.','line_number':6836,'multiline':False]
['text':'/','line_number':6837,'multiline':False]
['text':'/ @param arg  is advanced to the first non-white character after the name.','line_number':6838,'multiline':False]
['text':'/','line_number':6839,'multiline':False]
['text':'/ @return  0 if something is wrong.','line_number':6840,'multiline':False]
['text':' Find the end of the name.','line_number':6845,'multiline':False]
['text':' "s:" is start of "s:var", but "n:" is not and can be used in','line_number':6849,'multiline':False]
['text':' slice "[n:]". Also "xx:" is not a namespace.','line_number':6850,'multiline':False]
['text':' no name found','line_number':6858,'multiline':False]
['text':'/ Get the length of the name of a variable or function.','line_number':6868,'multiline':False]
['text':'/ Only the name is recognized, does not handle ".key" or "[idx]".','line_number':6869,'multiline':False]
['text':'/','line_number':6870,'multiline':False]
['text':'/ @param arg  is advanced to the first non-white character after the name.','line_number':6871,'multiline':False]
['text':'/             If the name contains 'magic' {}'s, expand them and return the','line_number':6872,'multiline':False]
['text':'/             expanded name in an allocated string via 'alias' - caller must free.','line_number':6873,'multiline':False]
['text':'/','line_number':6874,'multiline':False]
['text':'/ @return  -1 if curly braces expansion failed or','line_number':6875,'multiline':False]
['text':'/           0 if something else is wrong.','line_number':6876,'multiline':False]
['text':' default to no alias','line_number':6879,'multiline':False]
['text':' Hard coded <SNR>, already translated.','line_number':6883,'multiline':False]
['text':' literal "<SID>", "s:" or "<SNR>"','line_number':6889,'multiline':False]
['text':' Find the end of the name; check for {} construction.','line_number':6893,'multiline':False]
['text':' Include any <SID> etc in the expanded string:','line_number':6905,'multiline':False]
['text':' Thus the -len here.','line_number':6906,'multiline':False]
['text':' Only give an error when there is something, otherwise it will be','line_number':6917,'multiline':False]
['text':' reported at a higher level.','line_number':6918,'multiline':False]
['text':'/ Find the end of a variable or function name, taking care of magic braces.','line_number':6926,'multiline':False]
['text':'/','line_number':6927,'multiline':False]
['text':'/ @param expr_start  if not NULL, then `expr_start` and `expr_end` are set to the','line_number':6928,'multiline':False]
['text':'/                    start and end of the first magic braces item.','line_number':6929,'multiline':False]
['text':'/','line_number':6930,'multiline':False]
['text':'/ @param flags  can have FNE_INCL_BR and FNE_CHECK_START.','line_number':6931,'multiline':False]
['text':'/','line_number':6932,'multiline':False]
['text':'/ @return  a pointer to just after the name.  Equal to "arg" if there is no','line_number':6933,'multiline':False]
['text':'/          valid name.','line_number':6934,'multiline':False]
['text':' Quick check for valid starting character.','line_number':6943,'multiline':False]
['text':' skip over 'string' to avoid counting [ and ] inside it.','line_number':6961,'multiline':False]
['text':' skip over "str\"ing" to avoid counting [ and ] inside it.','line_number':6967,'multiline':False]
['text':' "s:" is start of "s:var", but "n:" is not and can be used in','line_number':6977,'multiline':False]
['text':' slice "[n:]".  Also "xx:" is not a namespace. But {ns}: is.','line_number':6978,'multiline':False]
['text':'/ Expands out the 'magic' {}'s in a variable/function name.','line_number':7012,'multiline':False]
['text':'/ Note that this can call itself recursively, to deal with','line_number':7013,'multiline':False]
['text':'/ constructs like foo{bar}{baz}{bam}','line_number':7014,'multiline':False]
['text':'/ The four pointer arguments point to "foo{expre}ss{ion}bar"','line_number':7015,'multiline':False]
['text':'/                      "in_start"      ^','line_number':7016,'multiline':False]
['text':'/                      "expr_start"       ^','line_number':7017,'multiline':False]
['text':'/                      "expr_end"               ^','line_number':7018,'multiline':False]
['text':'/                      "in_end"                            ^','line_number':7019,'multiline':False]
['text':'/','line_number':7020,'multiline':False]
['text':'/ @return  a new allocated string, which the caller must free or','line_number':7021,'multiline':False]
['text':'/          NULL for failure.','line_number':7022,'multiline':False]
['text':' put char back for error messages','line_number':7047,'multiline':False]
['text':' Further expansion!','line_number':7056,'multiline':False]
['text':'/ @return  true if character "c" can be used in a variable or function name.','line_number':7067,'multiline':False]
['text':'/          Does not include '{' or '}' for magic braces.','line_number':7068,'multiline':False]
['text':'/ @return  true if character "c" can be used as the first character in a','line_number':7074,'multiline':False]
['text':'/          variable or function name (excluding '{' and '}').','line_number':7075,'multiline':False]
['text':'/ @return  true if character "c" can be used as the first character of a','line_number':7081,'multiline':False]
['text':'/          dictionary key.','line_number':7082,'multiline':False]
['text':'/ Get typval_T v: variable value.','line_number':7088,'multiline':False]
['text':'/ Get number v: variable value.','line_number':7094,'multiline':False]
['text':'/ Get string v: variable value.  Uses a static buffer, can only be used once.','line_number':7100,'multiline':False]
['text':'/ If the String variable has never been set, return an empty string.','line_number':7101,'multiline':False]
['text':'/ Never returns NULL.','line_number':7102,'multiline':False]
['text':'/ Get List v: variable value.  Caller must take care of reference count when','line_number':7109,'multiline':False]
['text':'/ needed.','line_number':7110,'multiline':False]
['text':'/ Get Dictionary v: variable value.  Caller must take care of reference count','line_number':7116,'multiline':False]
['text':'/ when needed.','line_number':7117,'multiline':False]
['text':'/ Set v:char to character "c".','line_number':7123,'multiline':False]
['text':'/ Set v:count to "count" and v:count1 to "count1".','line_number':7132,'multiline':False]
['text':'/','line_number':7133,'multiline':False]
['text':'/ @param set_prevcount  if true, first set v:prevcount from v:count.','line_number':7134,'multiline':False]
['text':'/ Set number v: variable to the given value','line_number':7144,'multiline':False]
['text':'/','line_number':7145,'multiline':False]
['text':'/ @param[in]  idx  Index of variable to set.','line_number':7146,'multiline':False]
['text':'/ @param[in]  val  Value to set to.','line_number':7147,'multiline':False]
['text':'/ Set boolean v: {true, false} to the given value','line_number':7155,'multiline':False]
['text':'/','line_number':7156,'multiline':False]
['text':'/ @param[in]  idx  Index of variable to set.','line_number':7157,'multiline':False]
['text':'/ @param[in]  val  Value to set to.','line_number':7158,'multiline':False]
['text':'/ Set special v: variable to the given value','line_number':7166,'multiline':False]
['text':'/','line_number':7167,'multiline':False]
['text':'/ @param[in]  idx  Index of variable to set.','line_number':7168,'multiline':False]
['text':'/ @param[in]  val  Value to set to.','line_number':7169,'multiline':False]
['text':'/ Set string v: variable to the given string','line_number':7177,'multiline':False]
['text':'/','line_number':7178,'multiline':False]
['text':'/ @param[in]  idx  Index of variable to set.','line_number':7179,'multiline':False]
['text':'/ @param[in]  val  Value to set to. Will be copied.','line_number':7180,'multiline':False]
['text':'/ @param[in]  len  Length of that value or -1 in which case strlen() will be','line_number':7181,'multiline':False]
['text':'/                  used.','line_number':7182,'multiline':False]
['text':'/ Set list v: variable to the given list','line_number':7196,'multiline':False]
['text':'/','line_number':7197,'multiline':False]
['text':'/ @param[in]  idx  Index of variable to set.','line_number':7198,'multiline':False]
['text':'/ @param[in,out]  val  Value to set to. Reference count will be incremented.','line_number':7199,'multiline':False]
['text':'/ Set Dictionary v: variable to the given dictionary','line_number':7210,'multiline':False]
['text':'/','line_number':7211,'multiline':False]
['text':'/ @param[in]  idx  Index of variable to set.','line_number':7212,'multiline':False]
['text':'/ @param[in,out]  val  Value to set to. Reference count will be incremented.','line_number':7213,'multiline':False]
['text':'/                      Also keys of the dictionary will be made read-only.','line_number':7214,'multiline':False]
['text':' Set readonly','line_number':7225,'multiline':False]
['text':'/ Set v:variable to tv.','line_number':7229,'multiline':False]
['text':'/','line_number':7230,'multiline':False]
['text':'/ @param[in]  idx  Index of variable to set.','line_number':7231,'multiline':False]
['text':'/ @param[in]  val  Value to set to. Will be copied.','line_number':7232,'multiline':False]
['text':'/ Set the v:argv list.','line_number':7239,'multiline':False]
['text':'/ Set v:register if needed.','line_number':7252,'multiline':False]
['text':' Avoid free/alloc when the value is already right.','line_number':7262,'multiline':False]
['text':'/ Get or set v:exception.  If "oldval" == NULL, return the current value.','line_number':7268,'multiline':False]
['text':'/ Otherwise, restore the value to "oldval" and return NULL.','line_number':7269,'multiline':False]
['text':'/ Must always be called in pairs to save and restore v:exception!  Does not','line_number':7270,'multiline':False]
['text':'/ take care of memory allocations.','line_number':7271,'multiline':False]
['text':'/ Get or set v:throwpoint.  If "oldval" == NULL, return the current value.','line_number':7282,'multiline':False]
['text':'/ Otherwise, restore the value to "oldval" and return NULL.','line_number':7283,'multiline':False]
['text':'/ Must always be called in pairs to save and restore v:throwpoint!  Does not','line_number':7284,'multiline':False]
['text':'/ take care of memory allocations.','line_number':7285,'multiline':False]
['text':'/ Set v:cmdarg.','line_number':7296,'multiline':False]
['text':'/ If "eap" != NULL, use "eap" to generate the value and return the old value.','line_number':7297,'multiline':False]
['text':'/ If "oldarg" != NULL, restore the value to "oldarg" and return NULL.','line_number':7298,'multiline':False]
['text':'/ Must always be called in pairs!','line_number':7299,'multiline':False]
['text':' " ++bin"','line_number':7309,'multiline':False]
['text':' " ++nobin"','line_number':7311,'multiline':False]
['text':' " ++edit"','line_number':7315,'multiline':False]
['text':' " ++ff=unix"','line_number':7319,'multiline':False]
['text':' " ++bad=" + "keep" or "drop"','line_number':7325,'multiline':False]
['text':' " ++p"','line_number':7328,'multiline':False]
['text':'/ Check if variable "name[len]" is a local variable or an argument.','line_number':7413,'multiline':False]
['text':'/ If so, "*eval_lavars_used" is set to true.','line_number':7414,'multiline':False]
['text':'/ check if special v:lua value for calling lua functions','line_number':7431,'multiline':False]
['text':'/ check if special v:lua value for calling lua functions','line_number':7438,'multiline':False]
['text':'/ Skips one character past the end of the name of a v:lua function.','line_number':7444,'multiline':False]
['text':'/ @param p  Pointer to the char AFTER the "v:lua." prefix.','line_number':7445,'multiline':False]
['text':'/ @return Pointer to the char one past the end of the function's name.','line_number':7446,'multiline':False]
['text':'/ check the function name after "v:lua."','line_number':7456,'multiline':False]
['text':'/ Return the character "str[index]" where "index" is the character index.  If','line_number':7467,'multiline':False]
['text':'/ "index" is out of range NULL is returned.','line_number':7468,'multiline':False]
['text':'/ Get the byte index for character index "idx" in string "str" with length','line_number':7488,'multiline':False]
['text':'/ "str_len".','line_number':7489,'multiline':False]
['text':'/ If going over the end return "str_len".','line_number':7490,'multiline':False]
['text':'/ If "idx" is negative count from the end, -1 is the last character.','line_number':7491,'multiline':False]
['text':'/ When going over the start return -1.','line_number':7492,'multiline':False]
['text':'/ Return the slice "str[first:last]" using character indexes.','line_number':7517,'multiline':False]
['text':'/','line_number':7518,'multiline':False]
['text':'/ @param exclusive  true for slice().','line_number':7519,'multiline':False]
['text':'/','line_number':7520,'multiline':False]
['text':'/ Return NULL when the result is empty.','line_number':7521,'multiline':False]
['text':' first index very negative: use zero','line_number':7530,'multiline':False]
['text':' end index is inclusive','line_number':7538,'multiline':False]
['text':'/ Handle:','line_number':7549,'multiline':False]
['text':'/ - expr[expr], expr[expr:expr] subscript','line_number':7550,'multiline':False]
['text':'/ - ".name" lookup','line_number':7551,'multiline':False]
['text':'/ - function call with Funcref variable: func(expr)','line_number':7552,'multiline':False]
['text':'/ - method call: var->method()','line_number':7553,'multiline':False]
['text':'/','line_number':7554,'multiline':False]
['text':'/ Can all be combined in any order: dict.func(expr)[idx]['func'](expr)->len()','line_number':7555,'multiline':False]
['text':'/','line_number':7556,'multiline':False]
['text':'/ @param verbose  give error messages','line_number':7557,'multiline':False]
['text':'/ @param start_leader  start of '!' and '-' prefixes','line_number':7558,'multiline':False]
['text':'/ @param end_leaderp  end of '!' and '-' prefixes','line_number':7559,'multiline':False]
['text':' "." is ".name" lookup when we found a dict.','line_number':7585,'multiline':False]
['text':' Stop the expression evaluation when immediately aborting on','line_number':7594,'multiline':False]
['text':' error, or when an interrupt occurred or an exception was thrown','line_number':7595,'multiline':False]
['text':' but not caught.','line_number':7596,'multiline':False]
['text':' expr->{lambda}()','line_number':7607,'multiline':False]
['text':' expr->name()','line_number':7610,'multiline':False]
['text':' **arg == '[' || **arg == '.'','line_number':7613,'multiline':False]
['text':' Turn "dict.Func" into a partial for "Func" bound to "dict".','line_number':7630,'multiline':False]
['text':' Don't do this when "dict.Func" is already a partial that was bound','line_number':7641,'multiline':False]
['text':' explicitly (pt_auto is false).','line_number':7642,'multiline':False]
['text':'/ Find variable "name" in the list of variables.','line_number':7650,'multiline':False]
['text':'/ Careful: "a:0" variables don't have a name.','line_number':7651,'multiline':False]
['text':'/ When "htp" is not NULL we are writing to the variable, set "htp" to the','line_number':7652,'multiline':False]
['text':'/ hashtab_T used.','line_number':7653,'multiline':False]
['text':'/','line_number':7654,'multiline':False]
['text':'/ @return  a pointer to it if found, NULL if not found.','line_number':7655,'multiline':False]
['text':' Search in parent scope for lambda','line_number':7675,'multiline':False]
['text':'/ Find variable in hashtab.','line_number':7679,'multiline':False]
['text':'/ When "varname" is empty returns curwin/curtab/etc vars dictionary.','line_number':7680,'multiline':False]
['text':'/','line_number':7681,'multiline':False]
['text':'/ @param[in]  ht  Hashtab to find variable in.','line_number':7682,'multiline':False]
['text':'/ @param[in]  htname  Hashtab name (first character).','line_number':7683,'multiline':False]
['text':'/ @param[in]  varname  Variable name.','line_number':7684,'multiline':False]
['text':'/ @param[in]  varname_len  Variable name length.','line_number':7685,'multiline':False]
['text':'/ @param[in]  no_autoload  If true then autoload scripts will not be sourced','line_number':7686,'multiline':False]
['text':'/                          if autoload variable was not found.','line_number':7687,'multiline':False]
['text':'/','line_number':7688,'multiline':False]
['text':'/ @return pointer to the dictionary item with the found variable or NULL if it','line_number':7689,'multiline':False]
['text':'/         was not found.','line_number':7690,'multiline':False]
['text':' Must be something like "s:", otherwise "ht" would be NULL.','line_number':7696,'multiline':False]
['text':' For global variables we may try auto-loading the script.  If it','line_number':7720,'multiline':False]
['text':' worked find the variable again.  Don't auto-load a script if it was','line_number':7721,'multiline':False]
['text':' loaded already, otherwise it would be loaded every time when','line_number':7722,'multiline':False]
['text':' checking if a function name is a Funcref variable.','line_number':7723,'multiline':False]
['text':' Note: script_autoload() may make "hi" invalid. It must either','line_number':7725,'multiline':False]
['text':' be obtained again or not used.','line_number':7726,'multiline':False]
['text':'/ Finds the dict (g:, l:, s:, ) and hashtable used for a variable.','line_number':7739,'multiline':False]
['text':'/','line_number':7740,'multiline':False]
['text':'/ Assigns SID if s: scope is accessed from Lua or anonymous Vimscript. #15994','line_number':7741,'multiline':False]
['text':'/','line_number':7742,'multiline':False]
['text':'/ @param[in]  name  Variable name, possibly with scope prefix.','line_number':7743,'multiline':False]
['text':'/ @param[in]  name_len  Variable name length.','line_number':7744,'multiline':False]
['text':'/ @param[out]  varname  Will be set to the start of the name without scope','line_number':7745,'multiline':False]
['text':'/                       prefix.','line_number':7746,'multiline':False]
['text':'/ @param[out]  d  Scope dictionary.','line_number':7747,'multiline':False]
['text':'/','line_number':7748,'multiline':False]
['text':'/ @return Scope hashtab, NULL if name is not valid.','line_number':7749,'multiline':False]
['text':' name has implicit scope','line_number':7760,'multiline':False]
['text':' The name must not start with a colon or #.','line_number':7762,'multiline':False]
['text':' "version" is "v:version" in all scopes','line_number':7767,'multiline':False]
['text':' global variable','line_number':7773,'multiline':False]
['text':' l: variable','line_number':7775,'multiline':False]
['text':' global variable','line_number':7782,'multiline':False]
['text':' There must be no ':' or '#' in the rest of the name if g: was not used','line_number':7787,'multiline':False]
['text':' buffer variable','line_number':7791,'multiline':False]
['text':' window variable','line_number':7793,'multiline':False]
['text':' tab page variable','line_number':7795,'multiline':False]
['text':' v: variable','line_number':7797,'multiline':False]
['text':' function argument','line_number':7799,'multiline':False]
['text':' local variable','line_number':7801,'multiline':False]
['text':' script variable','line_number':7803,'multiline':False]
['text':' For anonymous scripts without a script item, create one now so script vars can be used','line_number':7807,'multiline':False]
['text':' try to resolve lua filename & line no so it can be shown in lastset messages.','line_number':7809,'multiline':False]
['text':' Great we have valid location. Now here this out we'll create a new','line_number':7812,'multiline':False]
['text':' script context with the name and lineno of this one. why ?','line_number':7813,'multiline':False]
['text':' for behavioral consistency. With this different anonymous exec from','line_number':7814,'multiline':False]
['text':' same file can't access each others script local stuff. We need to do','line_number':7815,'multiline':False]
['text':' this all other cases except this will act like that otherwise.','line_number':7816,'multiline':False]
['text':' should_free is ignored as script_sctx will be resolved to a fnmae','line_number':7822,'multiline':False]
['text':' & new_script_item will consume it.','line_number':7823,'multiline':False]
['text':' Create SID if s: scope is accessed from Lua or anon Vimscript. #15994','line_number':7829,'multiline':False]
['text':'/ Find the hashtable used for a variable','line_number':7839,'multiline':False]
['text':'/','line_number':7840,'multiline':False]
['text':'/ @param[in]  name  Variable name, possibly with scope prefix.','line_number':7841,'multiline':False]
['text':'/ @param[in]  name_len  Variable name length.','line_number':7842,'multiline':False]
['text':'/ @param[out]  varname  Will be set to the start of the name without scope','line_number':7843,'multiline':False]
['text':'/                       prefix.','line_number':7844,'multiline':False]
['text':'/','line_number':7845,'multiline':False]
['text':'/ @return Scope hashtab, NULL if name is not valid.','line_number':7846,'multiline':False]
['text':'/ Allocate a new hashtab for a sourced script.  It will be used while','line_number':7853,'multiline':False]
['text':'/ sourcing this script and when executing functions defined in the script.','line_number':7854,'multiline':False]
['text':'/ Initialize dictionary "dict" as a scope and set variable "dict_var" to','line_number':7862,'multiline':False]
['text':'/ point to it.','line_number':7863,'multiline':False]
['text':'/ Unreference a dictionary initialized by init_var_dict().','line_number':7879,'multiline':False]
['text':' Now the dict needs to be freed if no one else is using it, go back to','line_number':7882,'multiline':False]
['text':' normal reference counting.','line_number':7883,'multiline':False]
['text':'/ Make a copy of an item','line_number':7888,'multiline':False]
['text':'/','line_number':7889,'multiline':False]
['text':'/ Lists and Dictionaries are also copied.','line_number':7890,'multiline':False]
['text':'/','line_number':7891,'multiline':False]
['text':'/ @param[in]  conv  If not NULL, convert all copied strings.','line_number':7892,'multiline':False]
['text':'/ @param[in]  from  Value to copy.','line_number':7893,'multiline':False]
['text':'/ @param[out]  to  Location where to copy to.','line_number':7894,'multiline':False]
['text':'/ @param[in]  deep  If true, use copy the container and all of the contained','line_number':7895,'multiline':False]
['text':'/                   containers (nested).','line_number':7896,'multiline':False]
['text':'/ @param[in]  copyID  If non-zero then when container is referenced more then','line_number':7897,'multiline':False]
['text':'/                     once then copy of it that was already done is used. E.g.','line_number':7898,'multiline':False]
['text':'/                     when copying list `list = [list2, list2]` (`list[0] is','line_number':7899,'multiline':False]
['text':'/                     list[1]`) var_item_copy with zero copyID will emit','line_number':7900,'multiline':False]
['text':'/                     a copy with (`copy[0] isnot copy[1]`), with non-zero it','line_number':7901,'multiline':False]
['text':'/                     will emit a copy with (`copy[0] is copy[1]`) like in the','line_number':7902,'multiline':False]
['text':'/                     original list. Not used when deep is false.','line_number':7903,'multiline':False]
['text':' Use the copy made earlier.','line_number':7947,'multiline':False]
['text':' use the copy made earlier','line_number':7966,'multiline':False]
['text':'/ ":echo expr1 ..."    print each argument separated with a space, add a','line_number':7984,'multiline':False]
['text':'/                      newline at the end.','line_number':7985,'multiline':False]
['text':'/ ":echon expr1 ..."   print each argument plain.','line_number':7986,'multiline':False]
['text':' If eval1() causes an error message the text from the command may','line_number':8003,'multiline':False]
['text':' still need to be cleared. E.g., "echo 22,44".','line_number':8004,'multiline':False]
['text':' Report the invalid expression unless the expression evaluation','line_number':8010,'multiline':False]
['text':' has been cancelled due to an aborting error, an interrupt, or an','line_number':8011,'multiline':False]
['text':' exception.','line_number':8012,'multiline':False]
['text':' Call msg_start() after eval1(), evaluating the expression','line_number':8026,'multiline':False]
['text':' may cause a message to appear.','line_number':8027,'multiline':False]
['text':' Mark the saved text as finishing the line, so that what','line_number':8029,'multiline':False]
['text':' follows is displayed on a new line when scrolling back','line_number':8030,'multiline':False]
['text':' at the more prompt.','line_number':8031,'multiline':False]
['text':' remove text that may still be there from the command','line_number':8054,'multiline':False]
['text':'/ ":echohl {name}".','line_number':8064,'multiline':False]
['text':'/ ":execute expr1 ..." execute the result of an expression.','line_number':8070,'multiline':False]
['text':'/ ":echomsg expr1 ..." Print a message','line_number':8071,'multiline':False]
['text':'/ ":echoerr expr1 ..." Print an error','line_number':8072,'multiline':False]
['text':'/ Each gets spaces around each argument and a newline at the end for','line_number':8073,'multiline':False]
['text':'/ echo commands','line_number':8074,'multiline':False]
['text':' We don't want to abort following commands, restore did_emsg.','line_number':8120,'multiline':False]
['text':'/ Skip over the name of an option: "&option", "&g:option" or "&l:option".','line_number':8141,'multiline':False]
['text':'/','line_number':8142,'multiline':False]
['text':'/ @param arg  points to the "&" or '+' when called, to "option" when returning.','line_number':8143,'multiline':False]
['text':'/','line_number':8144,'multiline':False]
['text':'/ @return  NULL when no option name found.  Otherwise pointer to the char','line_number':8145,'multiline':False]
['text':'/          after the option name.','line_number':8146,'multiline':False]
['text':' t_xx/termcap option','line_number':8168,'multiline':False]
['text':'/ Iterate over global variables','line_number':8193,'multiline':False]
['text':'/','line_number':8194,'multiline':False]
['text':'/ @warning No modifications to global variable dictionary must be performed','line_number':8195,'multiline':False]
['text':'/          while iteration is in progress.','line_number':8196,'multiline':False]
['text':'/','line_number':8197,'multiline':False]
['text':'/ @param[in]   iter   Iterator. Pass NULL to start iteration.','line_number':8198,'multiline':False]
['text':'/ @param[out]  name   Variable name.','line_number':8199,'multiline':False]
['text':'/ @param[out]  rettv  Variable value.','line_number':8200,'multiline':False]
['text':'/','line_number':8201,'multiline':False]
['text':'/ @return Pointer that needs to be passed to next `var_shada_iter` invocation','line_number':8202,'multiline':False]
['text':'/         or NULL to indicate that iteration is over.','line_number':8203,'multiline':False]
['text':' Escape special characters with a backslash.  Turn a LF and','line_number':8250,'multiline':False]
['text':' CR into \n and \r.','line_number':8251,'multiline':False]
['text':'/ Display script name where an item was last set.','line_number':8288,'multiline':False]
['text':'/ Should only be invoked when 'verbose' is non-zero.','line_number':8289,'multiline':False]
['text':'/ Displays where an option was last set.','line_number':8299,'multiline':False]
['text':'/','line_number':8300,'multiline':False]
['text':'/ Should only be invoked when 'verbose' is non-zero.','line_number':8301,'multiline':False]
['text':' reset v:option_new, v:option_old, v:option_oldlocal, v:option_oldglobal,','line_number':8321,'multiline':False]
['text':' v:option_type, and v:option_command.','line_number':8322,'multiline':False]
['text':'/ Adjust a filename, according to a string of modifiers.','line_number':8333,'multiline':False]
['text':'/ *fnamep must be NUL terminated when called.  When returning, the length is','line_number':8334,'multiline':False]
['text':'/ determined by *fnamelen.','line_number':8335,'multiline':False]
['text':'/ Returns VALID_ flags or -1 for failure.','line_number':8336,'multiline':False]
['text':'/ When there is an error, *fnamep is set to NULL.','line_number':8337,'multiline':False]
['text':'/','line_number':8338,'multiline':False]
['text':'/ @param src  string with modifiers','line_number':8339,'multiline':False]
['text':'/ @param tilde_file  "~" is a file name, not $HOME','line_number':8340,'multiline':False]
['text':'/ @param usedlen  characters after src that are used','line_number':8341,'multiline':False]
['text':'/ @param fnamep  file name so far','line_number':8342,'multiline':False]
['text':'/ @param bufp  buffer for allocated file name or NULL','line_number':8343,'multiline':False]
['text':'/ @param fnamelen  length of fnamep','line_number':8344,'multiline':False]
['text':' ":p" - full path/file_name','line_number':8355,'multiline':False]
['text':' Expand "~/path" for all systems and "~user/path" for Unix','line_number':8362,'multiline':False]
['text':' free any allocated file name','line_number':8373,'multiline':False]
['text':' When "/." or "/.." is used: force expansion to get rid of it.','line_number':8380,'multiline':False]
['text':' FullName_save() is slow, don't use it when not needed.','line_number':8392,'multiline':False]
['text':' free any allocated file name','line_number':8395,'multiline':False]
['text':' Append a path separator to a directory.','line_number':8402,'multiline':False]
['text':' Make room for one or two extra characters.','line_number':8404,'multiline':False]
['text':' free any allocated file name','line_number':8406,'multiline':False]
['text':' ":." - path relative to the current directory','line_number':8414,'multiline':False]
['text':' ":~" - path relative to the home directory','line_number':8415,'multiline':False]
['text':' ":8" - shortname path - postponed till after','line_number':8416,'multiline':False]
['text':' Need full path first (use expand_env() to remove a "~/")','line_number':8424,'multiline':False]
['text':' Do not call shorten_fname() here since it removes the prefix','line_number':8447,'multiline':False]
['text':' even though the path does not have a prefix.','line_number':8448,'multiline':False]
['text':' free any allocated file name','line_number':8457,'multiline':False]
['text':' Only replace it when it starts with '~'','line_number':8466,'multiline':False]
['text':' suppress clang "Argument with 'nonnull' attribute passed null"','line_number':8469,'multiline':False]
['text':' ":h" - head, remove "/file_name", can be repeated','line_number':8483,'multiline':False]
['text':' Don't remove the first "/" or "c:\"','line_number':8484,'multiline':False]
['text':' Result is empty.  Turn it into "." to make ":cd %:h" work.','line_number':8494,'multiline':False]
['text':' ":8" - shortname','line_number':8505,'multiline':False]
['text':' ":t" - tail, just the basename','line_number':8510,'multiline':False]
['text':' ":e" - extension, can be repeated','line_number':8517,'multiline':False]
['text':' ":r" - root, without extension, can be repeated','line_number':8518,'multiline':False]
['text':' find a '.' in the tail:','line_number':8521,'multiline':False]
['text':' - for second :e: before the current fname','line_number':8522,'multiline':False]
['text':' - otherwise: The last '.'','line_number':8523,'multiline':False]
['text':' we stopped at a '.' (so anchor to &'.' + 1)','line_number':8538,'multiline':False]
['text':' :r - Remove one extension','line_number':8547,'multiline':False]
['text':'','line_number':8548,'multiline':False]
['text':' Ensure that `s` doesn't go before `*fnamep`,','line_number':8549,'multiline':False]
['text':' since then we're taking too many roots:','line_number':8550,'multiline':False]
['text':'','line_number':8551,'multiline':False]
['text':' "path/to/this.file.ext" :e:e:r:r','line_number':8552,'multiline':False]
['text':'          ^    ^-------- *fnamep','line_number':8553,'multiline':False]
['text':'          +------------- tail','line_number':8554,'multiline':False]
['text':'','line_number':8555,'multiline':False]
['text':' Also ensure `s` doesn't go before `tail`,','line_number':8556,'multiline':False]
['text':' since then we're taking too many roots again:','line_number':8557,'multiline':False]
['text':'','line_number':8558,'multiline':False]
['text':' "path/to/this.file.ext" :r:r:r','line_number':8559,'multiline':False]
['text':'  ^       ^------------- tail','line_number':8560,'multiline':False]
['text':'  +--------------------- *fnamep','line_number':8561,'multiline':False]
['text':' ":s?pat?foo?" - substitute','line_number':8569,'multiline':False]
['text':' ":gs?pat?foo?" - global substitute','line_number':8570,'multiline':False]
['text':' find end of pattern','line_number':8585,'multiline':False]
['text':' find end of substitution','line_number':8590,'multiline':False]
['text':' after using ":s", repeat all the modifiers','line_number':8607,'multiline':False]
['text':' vim_strsave_shellescape() needs a NUL terminated string.','line_number':8615,'multiline':False]
['text':'/ Perform a substitution on "str" with pattern "pat" and substitute "sub".','line_number':8633,'multiline':False]
['text':'/ When "sub" is NULL "expr" is used, must be a VAR_FUNC or VAR_PARTIAL.','line_number':8634,'multiline':False]
['text':'/ "flags" can be "g" to do a global substitute.','line_number':8635,'multiline':False]
['text':'/','line_number':8636,'multiline':False]
['text':'/ @return  an allocated string, NULL for error.','line_number':8637,'multiline':False]
['text':' Make 'cpoptions' empty, so that the 'l' flag doesn't work here','line_number':8644,'multiline':False]
['text':' Skip empty match except for first match.','line_number':8659,'multiline':False]
['text':' avoid getting stuck on a match with an empty string','line_number':8662,'multiline':False]
['text':' Get some space for a temporary buffer to do the substitution','line_number':8672,'multiline':False]
['text':' into.  It will contain:','line_number':8673,'multiline':False]
['text':' - The text up to where the match is.','line_number':8674,'multiline':False]
['text':' - The substituted text.','line_number':8675,'multiline':False]
['text':' - The text after the match.','line_number':8676,'multiline':False]
['text':' copy the text up to where the match is','line_number':8685,'multiline':False]
['text':' add the substituted text','line_number':8688,'multiline':False]
['text':' Darn, evaluating {sub} expression or {expr} changed the value.','line_number':8714,'multiline':False]
['text':' If it's still empty it was changed and restored, need to restore in','line_number':8715,'multiline':False]
['text':' the complicated way.','line_number':8716,'multiline':False]
['text':'/ common code for getting job callbacks for jobstart, termopen and rpcstart','line_number':8726,'multiline':False]
['text':'/','line_number':8727,'multiline':False]
['text':'/ @return true/false on success/failure.','line_number':8728,'multiline':False]
['text':'/ @param discard  Clears the value returned by the provider and returns','line_number':8786,'multiline':False]
['text':'/                 an empty typval_T.','line_number':8787,'multiline':False]
['text':' Save caller scope information','line_number':8803,'multiline':False]
['text':' Restore caller scope information','line_number':8834,'multiline':False]
['text':'/ Checks if provider for feature `feat` is enabled.','line_number':8847,'multiline':False]
['text':' Avoid autoload for non-provider has() features.','line_number':8857,'multiline':False]
['text':' Normalized: "python3_compiled" => "python3".','line_number':8861,'multiline':False]
['text':' Chop any "_xx" suffix.','line_number':8863,'multiline':False]
['text':' Get the g:loaded_xx_provider variable.','line_number':8867,'multiline':False]
['text':' Trigger autoload once.','line_number':8870,'multiline':False]
['text':' Retry the (non-autoload-style) variable.','line_number':8874,'multiline':False]
['text':' Show a hint if Call() is defined but g:loaded_xx_provider is missing.','line_number':8877,'multiline':False]
['text':' Value of 2 means "loaded and working".','line_number':8888,'multiline':False]
['text':' Call() must be defined if provider claims to be working.','line_number':8892,'multiline':False]
['text':'/ Writes "<sourcing_name>:<sourcing_lnum>" to `buf[bufsize]`.','line_number':8904,'multiline':False]
['text':'/ ":checkhealth [plugins]"','line_number':8914,'multiline':False]
['text':' Add a new line for the prompt before invoking the callback, so that','line_number':8946,'multiline':False]
['text':' text can always be inserted above the last line.','line_number':8947,'multiline':False]
['text':'/ @return  true when the interrupt callback was invoked.','line_number':8969,'multiline':False]
['text':' don't skip executing commands','line_number':8980,'multiline':False]
['text':'/ Compare "typ1" and "typ2".  Put the result in "typ1".','line_number':8986,'multiline':False]
['text':'/','line_number':8987,'multiline':False]
['text':'/ @param typ1  first operand','line_number':8988,'multiline':False]
['text':'/ @param typ2  second operand','line_number':8989,'multiline':False]
['text':'/ @param type  operator','line_number':8990,'multiline':False]
['text':'/ @param ic  ignore case','line_number':8991,'multiline':False]
['text':' For "is" a different type always means false, for "isnot"','line_number':8999,'multiline':False]
['text':' it means true.','line_number':9000,'multiline':False]
['text':' Compare two Blobs for being equal or unequal.','line_number':9019,'multiline':False]
['text':' Compare two Lists for being equal or unequal.','line_number':9042,'multiline':False]
['text':' Compare two Dictionaries for being equal or unequal.','line_number':9065,'multiline':False]
['text':' When both partials are NULL, then they are equal.','line_number':9080,'multiline':False]
['text':' Otherwise they are not equal.','line_number':9081,'multiline':False]
['text':' strings are considered the same if their value is','line_number':9085,'multiline':False]
['text':' the same','line_number':9086,'multiline':False]
['text':' If one of the two variables is a float, compare as a float.','line_number':9101,'multiline':False]
['text':' When using "=~" or "!~", always compare as string.','line_number':9102,'multiline':False]
['text':' avoid gcc warning','line_number':9124,'multiline':False]
['text':' If one of the two variables is a number, compare as a number.','line_number':9128,'multiline':False]
['text':' When using "=~" or "!~", always compare as string.','line_number':9129,'multiline':False]
['text':' avoid gcc warning','line_number':9150,'multiline':False]
['text':' avoid gcc warning','line_number':9188,'multiline':False]
['text':'/ Convert any type to a string, never give an error.','line_number':9197,'multiline':False]
['text':'/ When "quotes" is true add quotes to a string.','line_number':9198,'multiline':False]
['text':'/ Returns an allocated string.','line_number':9199,'multiline':False]
