['text':' search.c: code for normal mode searching commands','line_number':1,'multiline':False]
['text':'  This file contains various searching-related routines. These fall into','line_number':68,'multiline':False]
['text':'  three groups:','line_number':69,'multiline':False]
['text':'  1. string searches (for /, ?, n, and N)','line_number':70,'multiline':False]
['text':'  2. character searches within a single line (for f, F, t, T, etc)','line_number':71,'multiline':False]
['text':'  3. "other" kinds of searches like the '%' command, and 'word' searches.','line_number':72,'multiline':False]
['text':'','line_number':73,'multiline':False]
['text':'','line_number':74,'multiline':False]
['text':'  String searches','line_number':75,'multiline':False]
['text':'','line_number':76,'multiline':False]
['text':'  The string search functions are divided into two levels:','line_number':77,'multiline':False]
['text':'  lowest:  searchit(); uses a pos_T for starting position and found match.','line_number':78,'multiline':False]
['text':'  Highest: do_search(); uses curwin->w_cursor; calls searchit().','line_number':79,'multiline':False]
['text':'','line_number':80,'multiline':False]
['text':'  The last search pattern is remembered for repeating the same search.','line_number':81,'multiline':False]
['text':'  This pattern is shared between the :g, :s, ? and / commands.','line_number':82,'multiline':False]
['text':'  This is in search_regcomp().','line_number':83,'multiline':False]
['text':'','line_number':84,'multiline':False]
['text':'  The actual string matching is done using a heavily modified version of','line_number':85,'multiline':False]
['text':'  Henry Spencer's regular expression library.  See regexp.c.','line_number':86,'multiline':False]
['text':'','line_number':87,'multiline':False]
['text':'','line_number':88,'multiline':False]
['text':'','line_number':89,'multiline':False]
['text':' Two search patterns are remembered: One for the :substitute command and','line_number':90,'multiline':False]
['text':' one for other searches.  last_idx points to the one that was used the last','line_number':91,'multiline':False]
['text':' time.','line_number':92,'multiline':False]
['text':' Last used search pattern','line_number':95,'multiline':False]
['text':' Last used substitute pattern','line_number':97,'multiline':False]
['text':' index in spats[] for RE_LAST','line_number':101,'multiline':False]
['text':' last character searched for','line_number':103,'multiline':False]
['text':' last direction of character search','line_number':104,'multiline':False]
['text':' last search t_cmd','line_number':105,'multiline':False]
['text':' >1 for multi-byte char','line_number':107,'multiline':False]
['text':' copy of spats[], for keeping the search patterns while executing autocmds','line_number':109,'multiline':False]
['text':' allocated copy of pattern used by search_regcomp()','line_number':115,'multiline':False]
['text':' Type used by find_pattern_in_path() to remember which included files have','line_number':118,'multiline':False]
['text':' been searched already.','line_number':119,'multiline':False]
['text':' File pointer','line_number':121,'multiline':False]
['text':' Full name of file','line_number':122,'multiline':False]
['text':' Line we were up to in file','line_number':123,'multiline':False]
['text':' Found a match in this file','line_number':124,'multiline':False]
['text':'/ translate search pattern for vim_regcomp()','line_number':127,'multiline':False]
['text':'/','line_number':128,'multiline':False]
['text':'/ pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)','line_number':129,'multiline':False]
['text':'/ pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)','line_number':130,'multiline':False]
['text':'/ pat_save == RE_BOTH: save pat in both patterns (:global command)','line_number':131,'multiline':False]
['text':'/ pat_use  == RE_SEARCH: use previous search pattern if "pat" is NULL','line_number':132,'multiline':False]
['text':'/ pat_use  == RE_SUBST: use previous substitute pattern if "pat" is NULL','line_number':133,'multiline':False]
['text':'/ pat_use  == RE_LAST: use last used pattern if "pat" is NULL','line_number':134,'multiline':False]
['text':'/ options & SEARCH_HIS: put search string in history','line_number':135,'multiline':False]
['text':'/ options & SEARCH_KEEP: keep previous search pattern','line_number':136,'multiline':False]
['text':'/','line_number':137,'multiline':False]
['text':'/ @param regmatch  return: pattern and ignore-case flag','line_number':138,'multiline':False]
['text':'/','line_number':139,'multiline':False]
['text':'/ @return          FAIL if failed, OK otherwise.','line_number':140,'multiline':False]
['text':' If no pattern given, use a previously defined pattern.','line_number':147,'multiline':False]
['text':' pattern was never defined','line_number':155,'multiline':False]
['text':' put new pattern in history','line_number':167,'multiline':False]
['text':' Save the currently used pattern in the appropriate place,','line_number':182,'multiline':False]
['text':' unless the pattern should not be remembered.','line_number':183,'multiline':False]
['text':' search or global command','line_number':185,'multiline':False]
['text':' substitute or global command','line_number':189,'multiline':False]
['text':'/ Get search pattern used by search_regcomp().','line_number':204,'multiline':False]
['text':' If 'hlsearch' set and search pat changed: need redraw.','line_number':223,'multiline':False]
['text':' Save the search patterns, so they can be restored later.','line_number':230,'multiline':False]
['text':' Used before/after executing autocommands and user functions.','line_number':231,'multiline':False]
['text':' copy of spats[RE_SEARCH], for keeping the search patterns while incremental','line_number':293,'multiline':False]
['text':' searching','line_number':294,'multiline':False]
['text':'/ Save and restore the search pattern for incremental highlight search','line_number':302,'multiline':False]
['text':'/ feature.','line_number':303,'multiline':False]
['text':'/','line_number':304,'multiline':False]
['text':'/ It's similar to but different from save_search_patterns() and','line_number':305,'multiline':False]
['text':'/ restore_search_patterns(), because the search pattern must be restored when','line_number':306,'multiline':False]
['text':'/ cancelling incremental searching even if it's called inside user functions.','line_number':307,'multiline':False]
['text':' nested call, nothing to do','line_number':311,'multiline':False]
['text':' nested call, nothing to do','line_number':326,'multiline':False]
['text':'/ Save and restore the incsearch highlighting variables.','line_number':343,'multiline':False]
['text':'/ This is required so that calling searchcount() at does not invalidate the','line_number':344,'multiline':False]
['text':'/ incsearch highlighting.','line_number':345,'multiline':False]
['text':'/ Return true when case should be ignored for search pattern "pat".','line_number':363,'multiline':False]
['text':'/ Uses the 'ignorecase' and 'smartcase' options.','line_number':364,'multiline':False]
['text':'/ As ignorecase() put pass the "ic" and "scs" flags.','line_number':370,'multiline':False]
['text':'/ Returns true if pattern `pat` has an uppercase character.','line_number':384,'multiline':False]
['text':' get the magicness of the pattern','line_number':391,'multiline':False]
['text':' skip "\_X"','line_number':403,'multiline':False]
['text':' skip "\%X"','line_number':405,'multiline':False]
['text':' skip "\X"','line_number':407,'multiline':False]
['text':' skip "_X" and %X','line_number':413,'multiline':False]
['text':' Reset search direction to forward.  For "gd" and "gD" commands.','line_number':469,'multiline':False]
['text':' Set the last search pattern.  For ":let @/ =" and ShaDa file.','line_number':476,'multiline':False]
['text':' Also set the saved search pattern, so that this works in an autocommand.','line_number':477,'multiline':False]
['text':' An empty string means that nothing should be matched.','line_number':481,'multiline':False]
['text':' If 'hlsearch' set and search pat changed: need redraw.','line_number':509,'multiline':False]
['text':' Get a regexp program for the last used search pattern.','line_number':515,'multiline':False]
['text':' This is used for highlighting all matches in a window.','line_number':516,'multiline':False]
['text':' Values returned in regmatch->regprog and regmatch->rmm_ic.','line_number':517,'multiline':False]
['text':' So it doesn't beep if bad expr','line_number':524,'multiline':False]
['text':'/ Lowest level search function.','line_number':529,'multiline':False]
['text':'/ Search for 'count'th occurrence of pattern "pat" in direction "dir".','line_number':530,'multiline':False]
['text':'/ Start at position "pos" and return the found position in "pos".','line_number':531,'multiline':False]
['text':'/','line_number':532,'multiline':False]
['text':'/ if (options & SEARCH_MSG) == 0 don't give any messages','line_number':533,'multiline':False]
['text':'/ if (options & SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages','line_number':534,'multiline':False]
['text':'/ if (options & SEARCH_MSG) == SEARCH_MSG give all messages','line_number':535,'multiline':False]
['text':'/ if (options & SEARCH_HIS) put search pattern in history','line_number':536,'multiline':False]
['text':'/ if (options & SEARCH_END) return position at end of match','line_number':537,'multiline':False]
['text':'/ if (options & SEARCH_START) accept match at pos itself','line_number':538,'multiline':False]
['text':'/ if (options & SEARCH_KEEP) keep previous search pattern','line_number':539,'multiline':False]
['text':'/ if (options & SEARCH_FOLD) match only once in a closed fold','line_number':540,'multiline':False]
['text':'/ if (options & SEARCH_PEEK) check for typed char, cancel search','line_number':541,'multiline':False]
['text':'/ if (options & SEARCH_COL) start at pos->col instead of zero','line_number':542,'multiline':False]
['text':'/','line_number':543,'multiline':False]
['text':'/ @param win        window to search in; can be NULL for a buffer without a window!','line_number':544,'multiline':False]
['text':'/ @param end_pos    set to end of the match, unless NULL','line_number':545,'multiline':False]
['text':'/ @param pat_use    which pattern to use when "pat" is empty','line_number':546,'multiline':False]
['text':'/ @param extra_arg  optional extra arguments, can be NULL','line_number':547,'multiline':False]
['text':'/','line_number':548,'multiline':False]
['text':'/ @returns          FAIL (zero) for failure, non-zero for success.','line_number':549,'multiline':False]
['text':'/                   the index of the first matching','line_number':550,'multiline':False]
['text':'/                   subpattern plus one; one if there was none.','line_number':551,'multiline':False]
['text':' no init to shut up Apollo cc','line_number':556,'multiline':False]
['text':' stop after this line number when != 0','line_number':571,'multiline':False]
['text':' timeout limit or NULL','line_number':572,'multiline':False]
['text':' set when timed out or NULL','line_number':573,'multiline':False]
['text':' find the string','line_number':589,'multiline':False]
['text':' loop for count','line_number':590,'multiline':False]
['text':' When not accepting a match at the start position set "extra_col" to a','line_number':591,'multiline':False]
['text':' non-zero value.  Don't do that when starting at MAXCOL, since MAXCOL + 1','line_number':592,'multiline':False]
['text':' is zero.','line_number':593,'multiline':False]
['text':' Watch out for the "col" being MAXCOL - 2, used in a closed fold.','line_number':599,'multiline':False]
['text':' remember start pos for detecting no match','line_number':615,'multiline':False]
['text':' default: not found','line_number':616,'multiline':False]
['text':' default: start in first line','line_number':617,'multiline':False]
['text':' correct lnum for when starting in line 0','line_number':618,'multiline':False]
['text':' not in first line now','line_number':621,'multiline':False]
['text':' Start searching in current line, unless searching backwards and','line_number':624,'multiline':False]
['text':' we're in column 0.','line_number':625,'multiline':False]
['text':' If we are searching backwards, in column 0, and not including the','line_number':626,'multiline':False]
['text':' current position, gain some efficiency by skipping back a line.','line_number':627,'multiline':False]
['text':' Otherwise begin the search in the current line.','line_number':628,'multiline':False]
['text':' loop twice if 'wrapscan' set','line_number':637,'multiline':False]
['text':' Stop after checking "stop_lnum", if it's set.','line_number':640,'multiline':False]
['text':' Stop after passing the "tm" time limit.','line_number':645,'multiline':False]
['text':' Look for a match somewhere in line "lnum".','line_number':650,'multiline':False]
['text':' vim_regexec_multi() may clear "regprog"','line_number':654,'multiline':False]
['text':' Abort searching on an error (e.g., out of stack).','line_number':658,'multiline':False]
['text':' match may actually be in another line when using \zs','line_number':663,'multiline':False]
['text':' "lnum" may be past end of buffer for "\n\zs".','line_number':667,'multiline':False]
['text':' Forward search in the first line: match should be after','line_number':674,'multiline':False]
['text':' the start position. If not, continue at the end of the','line_number':675,'multiline':False]
['text':' match (this is vi compatible) or on the next char.','line_number':676,'multiline':False]
['text':' When the match starts in a next line it's certainly','line_number':680,'multiline':False]
['text':' past the start position.','line_number':681,'multiline':False]
['text':' When match lands on a NUL the cursor will be put','line_number':682,'multiline':False]
['text':' one back afterwards, compare with that position,','line_number':683,'multiline':False]
['text':' otherwise "/$" will get stuck on end of line.','line_number':684,'multiline':False]
['text':' If vi-compatible searching, continue at the end','line_number':693,'multiline':False]
['text':' of the match, otherwise continue one position','line_number':694,'multiline':False]
['text':' forward.','line_number':695,'multiline':False]
['text':' end is in next line, thus no match in','line_number':698,'multiline':False]
['text':' this line','line_number':699,'multiline':False]
['text':' for empty match: advance one char','line_number':704,'multiline':False]
['text':' Advance "matchcol" to the next character.','line_number':709,'multiline':False]
['text':' This uses rmm_matchcol, the actual start of','line_number':710,'multiline':False]
['text':' the match, ignoring "\zs".','line_number':711,'multiline':False]
['text':' vim_regexec_multi() may clear "regprog"','line_number':727,'multiline':False]
['text':' This while-loop only works with matchpos.lnum == 0.','line_number':735,'multiline':False]
['text':' For bigger values the next line pointer ptr might not be a','line_number':736,'multiline':False]
['text':' buffer line.','line_number':737,'multiline':False]
['text':' Need to get the line pointer again, a multi-line search may','line_number':741,'multiline':False]
['text':' have made it invalid.','line_number':742,'multiline':False]
['text':' Now, if there are multiple matches on this line,','line_number':750,'multiline':False]
['text':' we have to get the last one. Or the last one before','line_number':751,'multiline':False]
['text':' the cursor, if we're on that line.','line_number':752,'multiline':False]
['text':' When putting the new cursor at the end, compare','line_number':753,'multiline':False]
['text':' relative to the end of the match.','line_number':754,'multiline':False]
['text':' Remember a position that is before the start','line_number':757,'multiline':False]
['text':' position, we use it if it's the last match in','line_number':758,'multiline':False]
['text':' the line.  Always accept a position after','line_number':759,'multiline':False]
['text':' wrapping around.','line_number':760,'multiline':False]
['text':' We found a valid match, now check if there is','line_number':783,'multiline':False]
['text':' another one after it.','line_number':784,'multiline':False]
['text':' If vi-compatible searching, continue at the end','line_number':785,'multiline':False]
['text':' of the match, otherwise continue one position','line_number':786,'multiline':False]
['text':' forward.','line_number':787,'multiline':False]
['text':' for empty match: advance one char','line_number':793,'multiline':False]
['text':' Stop when the match is in a next line.','line_number':799,'multiline':False]
['text':' If the search timed out, we did find a match','line_number':811,'multiline':False]
['text':' but it might be the wrong one, so that's not','line_number':812,'multiline':False]
['text':' OK.','line_number':813,'multiline':False]
['text':' vim_regexec_multi() may clear "regprog"','line_number':819,'multiline':False]
['text':' Need to get the line pointer again, a','line_number':823,'multiline':False]
['text':' multi-line search may have made it invalid.','line_number':824,'multiline':False]
['text':' If there is only a match after the cursor, skip','line_number':828,'multiline':False]
['text':' this match.','line_number':829,'multiline':False]
['text':' With the SEARCH_END option move to the last character','line_number':835,'multiline':False]
['text':' of the match.  Don't do it for an empty match, end','line_number':836,'multiline':False]
['text':' should be same as start then.','line_number':837,'multiline':False]
['text':' For a match in the first column, set the position','line_number':841,'multiline':False]
['text':' on the NUL in the previous line.','line_number':842,'multiline':False]
['text':' just in case','line_number':846,'multiline':False]
['text':' Set variables used for 'incsearch' highlighting.','line_number':876,'multiline':False]
['text':' stop if ctrl-C typed','line_number':881,'multiline':False]
['text':' Cancel searching if a character was typed.  Used for','line_number':886,'multiline':False]
['text':' 'incsearch'.  Don't check too often, that would slowdown','line_number':887,'multiline':False]
['text':' searching too much.','line_number':888,'multiline':False]
['text':' if second loop, stop where started','line_number':897,'multiline':False]
['text':' vim_regexec_multi() may clear "regprog"','line_number':902,'multiline':False]
['text':' Stop the search if wrapscan isn't set, "stop_lnum" is','line_number':907,'multiline':False]
['text':' specified, after an interrupt, after a match and after looping','line_number':908,'multiline':False]
['text':' twice.','line_number':909,'multiline':False]
['text':' If 'wrapscan' is set we continue at the other end of the file.','line_number':918,'multiline':False]
['text':' If 'shortmess' does not contain 's', we give a message, but','line_number':919,'multiline':False]
['text':' only, if we won't show the search stat later anyhow,','line_number':920,'multiline':False]
['text':' (so SEARCH_COUNT must be absent).','line_number':921,'multiline':False]
['text':' This message is also remembered in keep_msg for when the screen','line_number':922,'multiline':False]
['text':' is redrawn. The keep_msg is cleared whenever another message is','line_number':923,'multiline':False]
['text':' written.','line_number':924,'multiline':False]
['text':' start second loop at the other end','line_number':925,'multiline':False]
['text':' stop after count matches or no match','line_number':944,'multiline':False]
['text':' did not find it','line_number':948,'multiline':False]
['text':' A pattern like "\n\zs" may go past the last line.','line_number':963,'multiline':False]
['text':' Return the number of the first subpat that matched.','line_number':985,'multiline':False]
['text':' Return zero if none of them matched.','line_number':986,'multiline':False]
['text':'/ Highest level string search function.','line_number':1003,'multiline':False]
['text':'/ Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'','line_number':1004,'multiline':False]
['text':'/','line_number':1005,'multiline':False]
['text':'/ Careful: If spats[0].off.line == true and spats[0].off.off == 0 this','line_number':1006,'multiline':False]
['text':'/ makes the movement linewise without moving the match position.','line_number':1007,'multiline':False]
['text':'/','line_number':1008,'multiline':False]
['text':'/ @param dirc          if 0: use previous dir.','line_number':1009,'multiline':False]
['text':'/ @param pat           NULL or empty : use previous string.','line_number':1010,'multiline':False]
['text':'/ @param options       if true and','line_number':1011,'multiline':False]
['text':'/                      SEARCH_REV   == true : go in reverse of previous dir.','line_number':1012,'multiline':False]
['text':'/                      SEARCH_ECHO  == true : echo the search command and handle options','line_number':1013,'multiline':False]
['text':'/                      SEARCH_MSG   == true : may give error message','line_number':1014,'multiline':False]
['text':'/                      SEARCH_OPT   == true : interpret optional flags','line_number':1015,'multiline':False]
['text':'/                      SEARCH_HIS   == true : put search pattern in history','line_number':1016,'multiline':False]
['text':'/                      SEARCH_NOOF  == true : don't add offset to position','line_number':1017,'multiline':False]
['text':'/                      SEARCH_MARK  == true : set previous context mark','line_number':1018,'multiline':False]
['text':'/                      SEARCH_KEEP  == true : keep previous search pattern','line_number':1019,'multiline':False]
['text':'/                      SEARCH_START == true : accept match at curpos itself','line_number':1020,'multiline':False]
['text':'/                      SEARCH_PEEK  == true : check for typed char, cancel search','line_number':1021,'multiline':False]
['text':'/ @param oap           can be NULL','line_number':1022,'multiline':False]
['text':'/ @param dirc          '/' or '?'','line_number':1023,'multiline':False]
['text':'/ @param search_delim  delimiter for search, e.g. '%' in s%regex%replacement','line_number':1024,'multiline':False]
['text':'/ @param sia           optional arguments or NULL','line_number':1025,'multiline':False]
['text':'/','line_number':1026,'multiline':False]
['text':'/ @return              0 for failure, 1 for found, 2 for found and line offset added.','line_number':1027,'multiline':False]
['text':' position of the last match','line_number':1031,'multiline':False]
['text':' Return value','line_number':1033,'multiline':False]
['text':' A line offset is not remembered, this is vi compatible.','line_number':1043,'multiline':False]
['text':' Save the values for when (options & SEARCH_KEEP) is used.','line_number':1049,'multiline':False]
['text':' (there is no "if ()" around this because gcc wants them initialized)','line_number':1050,'multiline':False]
['text':' start searching at the cursor position','line_number':1053,'multiline':False]
['text':' Find out the direction of the search.','line_number':1055,'multiline':False]
['text':' If the cursor is in a closed fold, don't find another match in the same','line_number':1070,'multiline':False]
['text':' fold.','line_number':1071,'multiline':False]
['text':' avoid overflow when adding 1','line_number':1074,'multiline':False]
['text':' Turn 'hlsearch' highlighting back on.','line_number':1082,'multiline':False]
['text':' Repeat the search when pattern followed by ';', e.g. "/foo/;?bar".','line_number':1088,'multiline':False]
['text':' use previous pattern','line_number':1094,'multiline':False]
['text':' no previous pattern','line_number':1096,'multiline':False]
['text':' make search_regcomp() use spats[RE_SEARCH].pat','line_number':1104,'multiline':False]
['text':' look for (new) offset','line_number':1109,'multiline':False]
['text':' Find end of regular expression.','line_number':1110,'multiline':False]
['text':' If there is a matching '/' or '?', toss it.','line_number':1111,'multiline':False]
['text':' made a copy of "pat" to change "\?" to "?"','line_number':1115,'multiline':False]
['text':' remember where we put the NUL','line_number':1121,'multiline':False]
['text':' Check for a line offset or a character offset.','line_number':1127,'multiline':False]
['text':' For get_address (echo off) we don't check for a character','line_number':1128,'multiline':False]
['text':' offset, because it is meaningless and the 's' could be a','line_number':1129,'multiline':False]
['text':' substitute command.','line_number':1130,'multiline':False]
['text':' end','line_number':1135,'multiline':False]
['text':' got an offset','line_number':1140,'multiline':False]
['text':' 'nr' or '+nr' or '-nr'','line_number':1141,'multiline':False]
['text':' single '-'','line_number':1144,'multiline':False]
['text':' single '+'','line_number':1146,'multiline':False]
['text':' skip number','line_number':1150,'multiline':False]
['text':' compute length of search command for get_address()','line_number':1155,'multiline':False]
['text':' put pat after search command','line_number':1158,'multiline':False]
['text':' Compute msg_row early.','line_number':1167,'multiline':False]
['text':' Get the offset, so we know how long it is.','line_number':1170,'multiline':False]
['text':' Reserve enough space for the search pattern + offset +','line_number':1198,'multiline':False]
['text':' search stat.  Use all the space available, so that the','line_number':1199,'multiline':False]
['text':' search state is right aligned.  If there is not enough space','line_number':1200,'multiline':False]
['text':' msg_strtrunc() will shorten in the middle.','line_number':1201,'multiline':False]
['text':' adjusted below','line_number':1203,'multiline':False]
['text':' Use all the columns.','line_number':1205,'multiline':False]
['text':' Use up to 'showcmd' column.','line_number':1208,'multiline':False]
['text':' Reserve enough space for the search pattern + offset.','line_number':1215,'multiline':False]
['text':' do not fill the msgbuf buffer, if cmd_silent is set, leave it','line_number':1224,'multiline':False]
['text':' empty for the search_stat feature.','line_number':1225,'multiline':False]
['text':' Use a space to draw the composing char on.','line_number':1229,'multiline':False]
['text':' The search pattern could be shown on the right in rightleft','line_number':1245,'multiline':False]
['text':' mode, but the 'ruler' and 'showcmd' area use it too, thus','line_number':1246,'multiline':False]
['text':' it would be blanked out again very soon.  Show it on the','line_number':1247,'multiline':False]
['text':' left, but do reverse the text.','line_number':1248,'multiline':False]
['text':' move reversed text to beginning of buffer','line_number':1253,'multiline':False]
['text':' overwrite old text','line_number':1259,'multiline':False]
['text':' don't wait for this message','line_number':1272,'multiline':False]
['text':' If there is a character offset, subtract it from the current','line_number':1276,'multiline':False]
['text':' position, so we don't get stuck at "?pat?e+2" or "/pat/s-2".','line_number':1277,'multiline':False]
['text':' Skip this if pos.col is near MAXCOL (closed fold).','line_number':1278,'multiline':False]
['text':' This is not done for a line offset, because then we would not be vi','line_number':1279,'multiline':False]
['text':' compatible.','line_number':1280,'multiline':False]
['text':' at start of buffer','line_number':1288,'multiline':False]
['text':' allow lnum == 0 here','line_number':1289,'multiline':False]
['text':' at end of buffer','line_number':1298,'multiline':False]
['text':' restore second '/' or '?' for normal_cmd()','line_number':1315,'multiline':False]
['text':' 'e' includes last character','line_number':1329,'multiline':False]
['text':' pattern found','line_number':1331,'multiline':False]
['text':' Add character and/or line offset','line_number':1337,'multiline':False]
['text':' Add the offset to the line number.','line_number':1341,'multiline':False]
['text':' pattern found, line offset added','line_number':1352,'multiline':False]
['text':' just in case','line_number':1353,'multiline':False]
['text':' to the right, check for end of file','line_number':1354,'multiline':False]
['text':' to the left, check for start of file','line_number':1362,'multiline':False]
['text':' Show [1/15] if 'S' is not in 'shortmess'.','line_number':1375,'multiline':False]
['text':' The search command can be followed by a ';' to do another search.','line_number':1392,'multiline':False]
['text':' For example: "/pat/;/foo/+3;?bar"','line_number':1393,'multiline':False]
['text':' This is like doing another search command, except:','line_number':1394,'multiline':False]
['text':' - The remembered direction '/' or '?' is from the first search.','line_number':1395,'multiline':False]
['text':' - When an error happens the cursor isn't moved at all.','line_number':1396,'multiline':False]
['text':' Don't do this when called by get_address() (it handles ';' itself).','line_number':1397,'multiline':False]
['text':' search_for_exact_line(buf, pos, dir, pat)','line_number':1428,'multiline':False]
['text':'','line_number':1429,'multiline':False]
['text':' Search for a line starting with the given pattern (ignoring leading','line_number':1430,'multiline':False]
['text':' white-space), starting from pos and going in direction "dir". "pos" will','line_number':1431,'multiline':False]
['text':' contain the position of the match found.    Blank lines match only if','line_number':1432,'multiline':False]
['text':' ADDING is set.  If p_ic is set then the pattern must be in lowercase.','line_number':1433,'multiline':False]
['text':' Return OK for success, or FAIL if no line found.','line_number':1434,'multiline':False]
['text':' when adding lines the matching line may be empty but it is not','line_number':1475,'multiline':False]
['text':' ignored because we are interested in the next line -- Acevedo','line_number':1476,'multiline':False]
['text':' Ignore empty lines.','line_number':1481,'multiline':False]
['text':' Expanding lines or words.','line_number':1482,'multiline':False]
['text':' Character Searches','line_number':1493,'multiline':False]
['text':'/ Search for a character in a line.  If "t_cmd" is false, move to the','line_number':1495,'multiline':False]
['text':'/ position of the character, otherwise move to just before the char.','line_number':1496,'multiline':False]
['text':'/ Do this "cap->count1" times.','line_number':1497,'multiline':False]
['text':'/ Return FAIL or OK.','line_number':1498,'multiline':False]
['text':' char to search for','line_number':1502,'multiline':False]
['text':' true for searching forward','line_number':1503,'multiline':False]
['text':' repeat count','line_number':1504,'multiline':False]
['text':' normal search: remember args for repeat','line_number':1507,'multiline':False]
['text':' don't remember when redoing','line_number':1508,'multiline':False]
['text':' repeat previous search','line_number':1522,'multiline':False]
['text':' repeat in opposite direction','line_number':1526,'multiline':False]
['text':' For multi-byte re-use last lastc_bytes[] and lastc_bytelen.','line_number':1533,'multiline':False]
['text':' Force a move of at least one char, so ";" and "," will move the','line_number':1535,'multiline':False]
['text':' cursor, even if the cursor is right in front of char we are looking','line_number':1536,'multiline':False]
['text':' at.','line_number':1537,'multiline':False]
['text':' Backup to before the character (possibly double-byte).','line_number':1578,'multiline':False]
['text':' Landed on the search char which is lastc_bytelen long.','line_number':1581,'multiline':False]
['text':' To previous char, which may be multi-byte.','line_number':1584,'multiline':False]
['text':' "Other" Searches','line_number':1593,'multiline':False]
['text':' findmatch - find the matching paren or brace','line_number':1595,'multiline':False]
['text':'','line_number':1596,'multiline':False]
['text':' Improvement over vi: Braces inside quotes are ignored.','line_number':1597,'multiline':False]
['text':' Return true if the character before "linep[col]" equals "ch".','line_number':1603,'multiline':False]
['text':' Return false if "col" is zero.','line_number':1604,'multiline':False]
['text':' Update "*prevcol" to the column of the previous character, unless "prevcol"','line_number':1605,'multiline':False]
['text':' is NULL.','line_number':1606,'multiline':False]
['text':' Handles multibyte string correctly.','line_number':1607,'multiline':False]
['text':'/ Raw string start is found at linep[startpos.col - 1].','line_number':1620,'multiline':False]
['text':'/','line_number':1621,'multiline':False]
['text':'/ @return  true if the matching end can be found between startpos and endpos.','line_number':1622,'multiline':False]
['text':'/ Check matchpairs option for "*initc".','line_number':1655,'multiline':False]
['text':'/ If there is a match set "*initc" to the matching character and "*findc" to','line_number':1656,'multiline':False]
['text':'/ the opposite character.  Set "*backwards" to the direction.','line_number':1657,'multiline':False]
['text':'/ When "switchit" is true swap the direction.','line_number':1658,'multiline':False]
['text':' findmatchlimit -- find the matching paren or brace, if it exists within','line_number':1696,'multiline':False]
['text':' maxtravel lines of the cursor.  A maxtravel of 0 means search until falling','line_number':1697,'multiline':False]
['text':' off the edge of the file.','line_number':1698,'multiline':False]
['text':'','line_number':1699,'multiline':False]
['text':' "initc" is the character to find a match for.  NUL means to find the','line_number':1700,'multiline':False]
['text':' character at or after the cursor. Special values:','line_number':1701,'multiline':False]
['text':' '*'  look for C-style comment / *','line_number':1702,'multiline':False]
['text':' '/'  look for C-style comment / *, ignoring comment-end','line_number':1703,'multiline':False]
['text':' '#'  look for preprocessor directives','line_number':1704,'multiline':False]
['text':' 'R'  look for raw string start: R"delim(text)delim" (only backwards)','line_number':1705,'multiline':False]
['text':'','line_number':1706,'multiline':False]
['text':' flags: FM_BACKWARD search backwards (when initc is '/', '*' or '#')','line_number':1707,'multiline':False]
['text':'    FM_FORWARD  search forwards (when initc is '/', '*' or '#')','line_number':1708,'multiline':False]
['text':'    FM_BLOCKSTOP  stop at start/end of block ({ or } in column 0)','line_number':1709,'multiline':False]
['text':'    FM_SKIPCOMM skip comments (not implemented yet!)','line_number':1710,'multiline':False]
['text':'','line_number':1711,'multiline':False]
['text':' "oap" is only used to set oap->motion_type for a linewise motion, it can be','line_number':1712,'multiline':False]
['text':' NULL','line_number':1713,'multiline':False]
['text':' current search position','line_number':1716,'multiline':False]
['text':' matching brace','line_number':1717,'multiline':False]
['text':' cumulative number of braces','line_number':1718,'multiline':False]
['text':' init for gcc','line_number':1719,'multiline':False]
['text':' search for raw string','line_number':1720,'multiline':False]
['text':' true when inside quotes','line_number':1721,'multiline':False]
['text':' Direction searched for # things','line_number':1723,'multiline':False]
['text':' Direction searched for comments','line_number':1724,'multiline':False]
['text':' how far we've searched so far','line_number':1725,'multiline':False]
['text':' ignore comment end','line_number':1726,'multiline':False]
['text':' search for escaped match','line_number':1727,'multiline':False]
['text':' Direction to search','line_number':1728,'multiline':False]
['text':' start of / / comment','line_number':1729,'multiline':False]
['text':' inside of Lisp-style comment','line_number':1730,'multiline':False]
['text':' engage Lisp-specific hacks ;)','line_number':1731,'multiline':False]
['text':' pointer to current line','line_number':1735,'multiline':False]
['text':' vi compatible matching','line_number':1737,'multiline':False]
['text':' don't recognize backslashes','line_number':1739,'multiline':False]
['text':' Direction to search when initc is '/', '*' or '#'','line_number':1742,'multiline':False]
['text':' if initc given, look in the table for the matching character','line_number':1751,'multiline':False]
['text':' '/' and '*' are special cases: look for start or end of comment.','line_number':1752,'multiline':False]
['text':' When '/' is used, we ignore running backwards into a star-slash, for','line_number':1753,'multiline':False]
['text':' "[*" command, we just want to find any comment.','line_number':1754,'multiline':False]
['text':' Either initc is '#', or no initc was given and we need to look','line_number':1772,'multiline':False]
['text':' under the cursor.','line_number':1773,'multiline':False]
['text':' initc was not given, must look for something to match under','line_number':1777,'multiline':False]
['text':' or near the cursor.','line_number':1778,'multiline':False]
['text':' Only check for special things when 'cpo' doesn't have '%'.','line_number':1779,'multiline':False]
['text':' Are we before or at #if, #else etc.?','line_number':1781,'multiline':False]
['text':' Are we on a comment?','line_number':1790,'multiline':False]
['text':' If we are not on a comment or the # at the start of a line, then','line_number':1811,'multiline':False]
['text':' look for brace anywhere on this line after the cursor.','line_number':1812,'multiline':False]
['text':' Find the brace under or after the cursor.','line_number':1814,'multiline':False]
['text':' If beyond the end of the line, use the last character in','line_number':1815,'multiline':False]
['text':' the line.','line_number':1816,'multiline':False]
['text':' no brace in the line, maybe use "  #if" then','line_number':1833,'multiline':False]
['text':' Set "match_escaped" if there are an odd number of','line_number':1842,'multiline':False]
['text':' backslashes.','line_number':1843,'multiline':False]
['text':' Look for matching #if, #else, #elif, or #endif','line_number':1852,'multiline':False]
['text':' Linewise for this case only','line_number':1854,'multiline':False]
['text':' check for CTRL-C typed','line_number':1877,'multiline':False]
['text':' This is just guessing: when 'rightleft' is set, search for a matching','line_number':1916,'multiline':False]
['text':' paren/brace in the other direction.','line_number':1917,'multiline':False]
['text':' check for quotes in current line','line_number':1922,'multiline':False]
['text':' do_quotes value at start position','line_number':1923,'multiline':False]
['text':' start position is in quotes','line_number':1924,'multiline':False]
['text':' Where last slash-star was found','line_number':1925,'multiline':False]
['text':' backward search: Check if this line contains a single-line comment','line_number':1928,'multiline':False]
['text':' find match inside this comment','line_number':1933,'multiline':False]
['text':' Go to the next position, forward or backward. We could use','line_number':1937,'multiline':False]
['text':' inc() and dec() here, but that is much slower','line_number':1938,'multiline':False]
['text':' char to match is inside of comment, don't search outside','line_number':1940,'multiline':False]
['text':' at start of line, go to prev. one','line_number':1944,'multiline':False]
['text':' start of file','line_number':1945,'multiline':False]
['text':' pos.col on trailing NUL','line_number':1955,'multiline':False]
['text':' Check if this line contains a single-line comment','line_number':1959,'multiline':False]
['text':' skip comment','line_number':1963,'multiline':False]
['text':' forward search','line_number':1971,'multiline':False]
['text':' at end of line, go to next one','line_number':1973,'multiline':False]
['text':' For lisp don't search for match in comment','line_number':1974,'multiline':False]
['text':' end of file','line_number':1977,'multiline':False]
['text':' line is exhausted and comment with it,','line_number':1978,'multiline':False]
['text':' don't search for match in code','line_number':1979,'multiline':False]
['text':' find comment pos in new line','line_number':1993,'multiline':False]
['text':' If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.','line_number':2001,'multiline':False]
['text':' match!','line_number':2004,'multiline':False]
['text':' out of scope','line_number':2007,'multiline':False]
['text':' Note: comments do not nest, and we ignore quotes in them','line_number':2011,'multiline':False]
['text':' TODO(vim): ignore comment brackets inside strings','line_number':2012,'multiline':False]
['text':' Searching backwards','line_number':2018,'multiline':False]
['text':' A comment may contain / * or / /, it may also start or end','line_number':2019,'multiline':False]
['text':' with / * /. Ignore a / * after / / and after *.','line_number':2020,'multiline':False]
['text':' Possible start of raw string. Now that we have the','line_number':2027,'multiline':False]
['text':' delimiter we can check if it ends before where we','line_number':2028,'multiline':False]
['text':' started searching, or before the previously found','line_number':2029,'multiline':False]
['text':' raw string start.','line_number':2030,'multiline':False]
['text':' may have been released','line_number':2037,'multiline':False]
['text':' If smart matching ('cpoptions' does not contain '%'), braces inside','line_number':2063,'multiline':False]
['text':' of quotes are ignored, but only if there is an even number of','line_number':2064,'multiline':False]
['text':' quotes in the line.','line_number':2065,'multiline':False]
['text':' Count the number of quotes in the line, skipping \" and '"'.','line_number':2069,'multiline':False]
['text':' Watch out for "\\".','line_number':2070,'multiline':False]
['text':' result is 1 with even number of quotes','line_number':2084,'multiline':False]
['text':' If we find an uneven count, check current line and previous','line_number':2086,'multiline':False]
['text':' one for a '\' at the end.','line_number':2087,'multiline':False]
['text':' Do we need to use at_start here?','line_number':2093,'multiline':False]
['text':' ml_get() only keeps one line, need to get linep again','line_number':2114,'multiline':False]
['text':' If 'smartmatch' is set:','line_number':2123,'multiline':False]
['text':'   Things inside quotes are ignored by setting 'inquote'.  If we','line_number':2124,'multiline':False]
['text':'   find a quote without a preceding '\' invert 'inquote'.  At the','line_number':2125,'multiline':False]
['text':'   end of a line not ending in '\' we reset 'inquote'.','line_number':2126,'multiline':False]
['text':'','line_number':2127,'multiline':False]
['text':'   In lines with an uneven number of quotes (without preceding '\')','line_number':2128,'multiline':False]
['text':'   we do not know which part to ignore. Therefore we only set','line_number':2129,'multiline':False]
['text':'   inquote if the number of quotes in a line is even, unless this','line_number':2130,'multiline':False]
['text':'   line or the previous one ends in a '\'.  Complicated, isn't it?','line_number':2131,'multiline':False]
['text':' at end of line without trailing backslash, reset inquote','line_number':2135,'multiline':False]
['text':' a quote that is preceded with an odd number of backslashes is','line_number':2143,'multiline':False]
['text':' ignored','line_number':2144,'multiline':False]
['text':' If smart matching ('cpoptions' does not contain '%'):','line_number':2160,'multiline':False]
['text':'   Skip things in single quotes: 'x' or '\x'.  Be careful for single','line_number':2161,'multiline':False]
['text':'   single quotes, eg jon's.  Things like '\233' or '\x3f' are not','line_number':2162,'multiline':False]
['text':'   skipped, there is never a brace in them.','line_number':2163,'multiline':False]
['text':'   Ignore this when finding matches for `'.','line_number':2164,'multiline':False]
['text':' forward search','line_number':2178,'multiline':False]
['text':' For Lisp skip over backslashed (), {} and [].','line_number':2192,'multiline':False]
['text':' (actually, we skip #\( et al)','line_number':2193,'multiline':False]
['text':' Check for match outside of quotes, and inside of','line_number':2202,'multiline':False]
['text':' quotes when the start is also inside of quotes.','line_number':2203,'multiline':False]
['text':' Only accept a match when 'M' is in 'cpo' or when escaping','line_number':2213,'multiline':False]
['text':' is what we expect.','line_number':2214,'multiline':False]
['text':' never found it','line_number':2233,'multiline':False]
['text':'/ Check if line[] contains a / / comment.','line_number':2236,'multiline':False]
['text':'/ @returns MAXCOL if not, otherwise return the column.','line_number':2237,'multiline':False]
['text':' scan from start','line_number':2240,'multiline':False]
['text':' skip Lispish one-line comments','line_number':2241,'multiline':False]
['text':' there may be comments','line_number':2243,'multiline':False]
['text':' inside of string','line_number':2244,'multiline':False]
['text':' skip escaped quote','line_number':2249,'multiline':False]
['text':' skip #\" form','line_number':2253,'multiline':False]
['text':' found!','line_number':2260,'multiline':False]
['text':' Accept a double /, unless it's preceded with * and followed by *,','line_number':2269,'multiline':False]
['text':' because * / / * is an end and start of a C comment.  Only','line_number':2270,'multiline':False]
['text':' accept the position if it is not inside a string.','line_number':2271,'multiline':False]
['text':'/ Move cursor briefly to character matching the one under the cursor.','line_number':2286,'multiline':False]
['text':'/ Used for Insert mode and "r" command.','line_number':2287,'multiline':False]
['text':'/ Show the match only if it is visible on the screen.','line_number':2288,'multiline':False]
['text':'/ If there isn't a match, then beep.','line_number':2289,'multiline':False]
['text':'/','line_number':2290,'multiline':False]
['text':'/ @param c  char to show match for','line_number':2291,'multiline':False]
['text':' Only show match for chars in the 'matchpairs' option.','line_number':2300,'multiline':False]
['text':' 'matchpairs' is "x:y,x:y"','line_number':2301,'multiline':False]
['text':' no match, so beep','line_number':2319,'multiline':False]
['text':' save the pos, update_screen() may change it','line_number':2339,'multiline':False]
['text':' Handle "$" in 'cpo': If the ')' is typed on top of the "$",','line_number':2343,'multiline':False]
['text':' stop displaying the "$".','line_number':2344,'multiline':False]
['text':' do display ')' just before "$"','line_number':2348,'multiline':False]
['text':' may show different cursor shape','line_number':2353,'multiline':False]
['text':' move to matching char','line_number':2354,'multiline':False]
['text':' don't use 'scrolloff' here','line_number':2355,'multiline':False]
['text':' don't use 'sidescrolloff' here','line_number':2356,'multiline':False]
['text':' show the new char','line_number':2358,'multiline':False]
['text':' Restore dollar_vcol(), because setcursor() may call curs_rows()','line_number':2361,'multiline':False]
['text':' which resets it if the matching position is in a previous line','line_number':2362,'multiline':False]
['text':' and has a higher column number.','line_number':2363,'multiline':False]
['text':' brief pause, unless 'm' is present in 'cpo' and a character is','line_number':2366,'multiline':False]
['text':' available.','line_number':2367,'multiline':False]
['text':' restore cursor position','line_number':2373,'multiline':False]
['text':' may show different cursor shape','line_number':2377,'multiline':False]
['text':'/ Find next search match under cursor, cursor at end.','line_number':2380,'multiline':False]
['text':'/ Used while an operator is pending, and in Visual mode.','line_number':2381,'multiline':False]
['text':'/','line_number':2382,'multiline':False]
['text':'/ @param forward  true for forward, false for backward','line_number':2383,'multiline':False]
['text':' Correct cursor when 'selection' is exclusive','line_number':2389,'multiline':False]
['text':' end position of the pattern match','line_number':2394,'multiline':False]
['text':' position of the cursor at beginning','line_number':2395,'multiline':False]
['text':' position after the pattern','line_number':2396,'multiline':False]
['text':' result of various function calls','line_number':2397,'multiline':False]
['text':' When searching forward and the cursor is at the start of the Visual','line_number':2399,'multiline':False]
['text':' area, skip the first search backward, otherwise it doesn't move.','line_number':2400,'multiline':False]
['text':' Searching further will extend the match.','line_number':2406,'multiline':False]
['text':' Is the pattern is zero-width?, this time, don't care about the direction','line_number':2414,'multiline':False]
['text':' pattern not found','line_number':2417,'multiline':False]
['text':' The trick is to first search backwards and then search forward again,','line_number':2420,'multiline':False]
['text':' so that a match at the current cursor position will be correctly','line_number':2421,'multiline':False]
['text':' captured.  When "forward" is false do it the other way around.','line_number':2422,'multiline':False]
['text':' wrapping should not occur in the first round','line_number':2441,'multiline':False]
['text':' First search may fail, but then start searching from the','line_number':2453,'multiline':False]
['text':' beginning of the file (cursor might be on the search match)','line_number':2454,'multiline':False]
['text':' except when Visual mode is active, so that extending the visual','line_number':2455,'multiline':False]
['text':' selection works.','line_number':2456,'multiline':False]
['text':' not found, abort */','line_number':2457,'multiline':False]
['text':' try again from start of buffer','line_number':2464,'multiline':False]
['text':' try again from end of buffer','line_number':2466,'multiline':False]
['text':' searching backwards, so set pos to last line and col','line_number':2467,'multiline':False]
['text':' put the cursor after the match','line_number':2480,'multiline':False]
['text':' put the cursor on the start of the match','line_number':2484,'multiline':False]
['text':' put the cursor on last character of match','line_number':2487,'multiline':False]
['text':' put the cursor on the start of the match','line_number':2491,'multiline':False]
['text':' Correction for exclusive selection depends on the direction.','line_number':2497,'multiline':False]
['text':'/ Check if the pattern is zero-width.','line_number':2517,'multiline':False]
['text':'/ If move is true, check from the beginning of the buffer,','line_number':2518,'multiline':False]
['text':'/ else from position "cur".','line_number':2519,'multiline':False]
['text':'/ "direction" is FORWARD or BACKWARD.','line_number':2520,'multiline':False]
['text':'/ Returns true, false or -1 for failure.','line_number':2521,'multiline':False]
['text':' init startcol correctly','line_number':2539,'multiline':False]
['text':' move to match','line_number':2541,'multiline':False]
['text':' accept a match at the cursor position','line_number':2546,'multiline':False]
['text':' Zero-width pattern should match somewhere, then we can check if','line_number':2552,'multiline':False]
['text':' start and end are in the same position.','line_number':2553,'multiline':False]
['text':'/ return true if line 'lnum' is empty or has white chars only.','line_number':2578,'multiline':False]
['text':'/ Add the search count "[3/19]" to "msgbuf".','line_number':2585,'multiline':False]
['text':'/ See update_search_stat() for other arguments.','line_number':2586,'multiline':False]
['text':' keep the message even after redraw, but don't put in history','line_number':2646,'multiline':False]
['text':' Add the search count information to "stat".','line_number':2653,'multiline':False]
['text':' "stat" must not be NULL.','line_number':2654,'multiline':False]
['text':' When "recompute" is true always recompute the numbers.','line_number':2655,'multiline':False]
['text':' dirc == 0: don't find the next/previous match (only set the result to "stat")','line_number':2656,'multiline':False]
['text':' dirc == '/': find the next match','line_number':2657,'multiline':False]
['text':' dirc == '?': find the previous match','line_number':2658,'multiline':False]
['text':' If anything relevant changed the count has to be recomputed.','line_number':2689,'multiline':False]
['text':' STRNICMP ignores case, but we should not ignore case.','line_number':2690,'multiline':False]
['text':' Unfortunately, there is no STRNICMP function.','line_number':2691,'multiline':False]
['text':' XXX: above comment should be "no MB_STRCMP function" ?','line_number':2692,'multiline':False]
['text':' suppress clang/NULL passed as nonnull parameter','line_number':2694,'multiline':False]
['text':' when searching backwards and having jumped to the first occurrence,','line_number':2709,'multiline':False]
['text':' cur must remain greater than 1','line_number':2710,'multiline':False]
['text':' Stop after passing the time limit.','line_number':2726,'multiline':False]
['text':' max count exceeded','line_number':2740,'multiline':False]
['text':' abort','line_number':2745,'multiline':False]
['text':' "searchcount()" function','line_number':2763,'multiline':False]
['text':' 'shortmess' contains 'S' flag','line_number':2775,'multiline':False]
['text':' the previous pattern was never defined','line_number':2860,'multiline':False]
['text':'/ Fuzzy string matching','line_number':2876,'multiline':False]
['text':'/','line_number':2877,'multiline':False]
['text':'/ Ported from the lib_fts library authored by Forrest Smith.','line_number':2878,'multiline':False]
['text':'/ https://github.com/forrestthewoods/lib_fts/tree/master/code','line_number':2879,'multiline':False]
['text':'/','line_number':2880,'multiline':False]
['text':'/ The following blog describes the fuzzy matching algorithm:','line_number':2881,'multiline':False]
['text':'/ https://www.forrestthewoods.com/blog/reverse_engineering_sublime_texts_fuzzy_match/','line_number':2882,'multiline':False]
['text':'/','line_number':2883,'multiline':False]
['text':'/ Each matching string is assigned a score. The following factors are checked:','line_number':2884,'multiline':False]
['text':'/   - Matched letter','line_number':2885,'multiline':False]
['text':'/   - Unmatched letter','line_number':2886,'multiline':False]
['text':'/   - Consecutively matched letters','line_number':2887,'multiline':False]
['text':'/   - Proximity to start','line_number':2888,'multiline':False]
['text':'/   - Letter following a separator (space, underscore)','line_number':2889,'multiline':False]
['text':'/   - Uppercase letter following lowercase (aka CamelCase)','line_number':2890,'multiline':False]
['text':'/','line_number':2891,'multiline':False]
['text':'/ Matched letters are good. Unmatched letters are bad. Matching near the start','line_number':2892,'multiline':False]
['text':'/ is good. Matching the first letter in the middle of a phrase is good.','line_number':2893,'multiline':False]
['text':'/ Matching the uppercase letters in camel case entries is good.','line_number':2894,'multiline':False]
['text':'/','line_number':2895,'multiline':False]
['text':'/ The score assigned for each factor is explained below.','line_number':2896,'multiline':False]
['text':'/ File paths are different from file names. File extensions may be ignorable.','line_number':2897,'multiline':False]
['text':'/ Single words care about consecutive matches but not separators or camel','line_number':2898,'multiline':False]
['text':'/ case.','line_number':2899,'multiline':False]
['text':'/   Score starts at 100','line_number':2900,'multiline':False]
['text':'/   Matched letter: +0 points','line_number':2901,'multiline':False]
['text':'/   Unmatched letter: -1 point','line_number':2902,'multiline':False]
['text':'/   Consecutive match bonus: +15 points','line_number':2903,'multiline':False]
['text':'/   First letter bonus: +15 points','line_number':2904,'multiline':False]
['text':'/   Separator bonus: +30 points','line_number':2905,'multiline':False]
['text':'/   Camel case bonus: +30 points','line_number':2906,'multiline':False]
['text':'/   Unmatched leading letter: -5 points (max: -15)','line_number':2907,'multiline':False]
['text':'/','line_number':2908,'multiline':False]
['text':'/ There is some nuance to this. Scores dont have an intrinsic meaning. The','line_number':2909,'multiline':False]
['text':'/ score range isnt 0 to 100. Its roughly [50, 150]. Longer words have a','line_number':2910,'multiline':False]
['text':'/ lower minimum score due to unmatched letter penalty. Longer search patterns','line_number':2911,'multiline':False]
['text':'/ have a higher maximum score due to match bonuses.','line_number':2912,'multiline':False]
['text':'/','line_number':2913,'multiline':False]
['text':'/ Separator and camel case bonus is worth a LOT. Consecutive matches are worth','line_number':2914,'multiline':False]
['text':'/ quite a bit.','line_number':2915,'multiline':False]
['text':'/','line_number':2916,'multiline':False]
['text':'/ There is a penalty if you DONT match the first three letters. Which','line_number':2917,'multiline':False]
['text':'/ effectively rewards matching near the start. However theres no difference','line_number':2918,'multiline':False]
['text':'/ in matching between the middle and end.','line_number':2919,'multiline':False]
['text':'/','line_number':2920,'multiline':False]
['text':'/ There is not an explicit bonus for an exact match. Unmatched letters receive','line_number':2921,'multiline':False]
['text':'/ a penalty. So shorter strings and closer matches are worth more.','line_number':2922,'multiline':False]
['text':'/< used for stable sort','line_number':2924,'multiline':False]
['text':'/ bonus for adjacent matches; this is higher than SEPARATOR_BONUS so that','line_number':2930,'multiline':False]
['text':'/ matching a whole word is preferred.','line_number':2931,'multiline':False]
['text':'/ bonus if match occurs after a path separator','line_number':2933,'multiline':False]
['text':'/ bonus if match occurs after a word separator','line_number':2935,'multiline':False]
['text':'/ bonus if match is uppercase and prev is lower','line_number':2937,'multiline':False]
['text':'/ bonus if the first letter is matched','line_number':2939,'multiline':False]
['text':'/ penalty applied for every letter in str before the first match','line_number':2941,'multiline':False]
['text':'/ maximum penalty for leading letters','line_number':2943,'multiline':False]
['text':'/ penalty for every letter that doesn't match','line_number':2945,'multiline':False]
['text':'/ penalty for gap in matching positions (-2 * k)','line_number':2947,'multiline':False]
['text':'/ Score for a string that doesn't fuzzy match the pattern','line_number':2949,'multiline':False]
['text':'/ Compute a score for a fuzzy matched string. The matching character locations','line_number':2954,'multiline':False]
['text':'/ are in "matches".','line_number':2955,'multiline':False]
['text':' suppress clang "result of operation is garbage"','line_number':2960,'multiline':False]
['text':' Initialize score','line_number':2961,'multiline':False]
['text':' Apply leading letter penalty','line_number':2964,'multiline':False]
['text':' Apply unmatched penalty','line_number':2971,'multiline':False]
['text':' Apply ordering bonuses','line_number':2975,'multiline':False]
['text':' Sequential','line_number':2982,'multiline':False]
['text':' Check for bonuses based on neighbor character value','line_number':2990,'multiline':False]
['text':' Camel case','line_number':2992,'multiline':False]
['text':' Bonus if the match follows a separator character','line_number':3006,'multiline':False]
['text':' First letter','line_number':3013,'multiline':False]
['text':'/ Perform a recursive search for fuzzy matching "fuzpat" in "str".','line_number':3020,'multiline':False]
['text':'/ @return the number of matching characters.','line_number':3021,'multiline':False]
['text':' Recursion params','line_number':3028,'multiline':False]
['text':' Count recursions','line_number':3033,'multiline':False]
['text':' Detect end of strings','line_number':3039,'multiline':False]
['text':' Loop through fuzpat and str looking for a match','line_number':3044,'multiline':False]
['text':' Found match','line_number':3050,'multiline':False]
['text':' Supplied matches buffer was too short','line_number':3052,'multiline':False]
['text':' "Copy-on-Write" srcMatches into matches','line_number':3061,'multiline':False]
['text':' Recursive call that "skips" this match','line_number':3067,'multiline':False]
['text':' Pick best recursive score','line_number':3073,'multiline':False]
['text':' Advance','line_number':3082,'multiline':False]
['text':' Determine if full fuzpat was matched','line_number':3090,'multiline':False]
['text':' Calculate score','line_number':3093,'multiline':False]
['text':' Return best result','line_number':3098,'multiline':False]
['text':' Recursive score is better than "this"','line_number':3100,'multiline':False]
['text':' "this" score is better than recursive','line_number':3105,'multiline':False]
['text':' no match','line_number':3108,'multiline':False]
['text':'/ fuzzy_match()','line_number':3111,'multiline':False]
['text':'/','line_number':3112,'multiline':False]
['text':'/ Performs exhaustive search via recursion to find all possible matches and','line_number':3113,'multiline':False]
['text':'/ match with highest score.','line_number':3114,'multiline':False]
['text':'/ Scores values have no intrinsic meaning.  Possible score range is not','line_number':3115,'multiline':False]
['text':'/ normalized and varies with pattern.','line_number':3116,'multiline':False]
['text':'/ Recursion is limited internally (default=10) to prevent degenerate cases','line_number':3117,'multiline':False]
['text':'/ (pat_arg="aaaaaa" str="aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa").','line_number':3118,'multiline':False]
['text':'/ Patterns are limited to MAX_FUZZY_MATCHES characters.','line_number':3119,'multiline':False]
['text':'/','line_number':3120,'multiline':False]
['text':'/ @return true if "pat_arg" matches "str". Also returns the match score in','line_number':3121,'multiline':False]
['text':'/ "outScore" and the matching character positions in "matches".','line_number':3122,'multiline':False]
['text':' Try matching each word in "pat_arg" in "str"','line_number':3137,'multiline':False]
['text':' Extract one word from the pattern (separated by space)','line_number':3142,'multiline':False]
['text':' processed all the words','line_number':3151,'multiline':False]
['text':' Accumulate the match score and the number of matches','line_number':3168,'multiline':False]
['text':' try matching the next word','line_number':3176,'multiline':False]
['text':'/ Sort the fuzzy matches in the descending order of the match score.','line_number':3184,'multiline':False]
['text':'/ For items with same score, retain the order using the index (stable sort)','line_number':3185,'multiline':False]
['text':'/ Fuzzy search the string "str" in a list of "items" and return the matching','line_number':3197,'multiline':False]
['text':'/ strings in "fmatchlist".','line_number':3198,'multiline':False]
['text':'/ If "matchseq" is true, then for multi-word search strings, match all the','line_number':3199,'multiline':False]
['text':'/ words in sequence.','line_number':3200,'multiline':False]
['text':'/ If "items" is a list of strings, then search for "str" in the list.','line_number':3201,'multiline':False]
['text':'/ If "items" is a list of dicts, then either use "key" to lookup the string','line_number':3202,'multiline':False]
['text':'/ for each item or use "item_cb" Funcref function to get the string.','line_number':3203,'multiline':False]
['text':'/ If "retmatchpos" is true, then return a list of positions where "str"','line_number':3204,'multiline':False]
['text':'/ matches for each item.','line_number':3205,'multiline':False]
['text':' For all the string items in items, get the fuzzy matching score','line_number':3224,'multiline':False]
['text':' list of strings','line_number':3234,'multiline':False]
['text':' For a dict, either use the specified key to lookup the string or','line_number':3237,'multiline':False]
['text':' use the specified callback function to get the string.','line_number':3238,'multiline':False]
['text':' Invoke the supplied callback (if any) to get the dict item','line_number':3244,'multiline':False]
['text':' Copy the list of matching positions in itemstr to a list, if','line_number':3265,'multiline':False]
['text':' "retmatchpos" is set.','line_number':3266,'multiline':False]
['text':' Sort the list by the descending order of the match score','line_number':3285,'multiline':False]
['text':' For matchfuzzy(), return a list of matched strings.','line_number':3288,'multiline':False]
['text':'          ['str1', 'str2', 'str3']','line_number':3289,'multiline':False]
['text':' For matchfuzzypos(), return a list with three items.','line_number':3290,'multiline':False]
['text':' The first item is a list of matched strings. The second item','line_number':3291,'multiline':False]
['text':' is a list of lists where each list item is a list of matched','line_number':3292,'multiline':False]
['text':' character positions. The third item is a list of matching scores.','line_number':3293,'multiline':False]
['text':'      [['str1', 'str2', 'str3'], [[1, 3], [1, 3], [1, 3]]]','line_number':3294,'multiline':False]
['text':' Copy the matching strings with a valid score to the return list','line_number':3304,'multiline':False]
['text':' next copy the list of matching positions','line_number':3312,'multiline':False]
['text':' copy the matching scores','line_number':3325,'multiline':False]
['text':'/ Do fuzzy matching. Returns the list of matched strings in "rettv".','line_number':3340,'multiline':False]
['text':'/ If "retmatchpos" is true, also returns the matching character positions.','line_number':3341,'multiline':False]
['text':' validate and get the arguments','line_number':3346,'multiline':False]
['text':' To search a dict, either a callback function or a key can be','line_number':3365,'multiline':False]
['text':' specified.','line_number':3366,'multiline':False]
['text':' get the fuzzy matches','line_number':3394,'multiline':False]
['text':' For matchfuzzypos(), a list with three items are returned. First','line_number':3397,'multiline':False]
['text':' item is a list of matching strings, the second item is a list of','line_number':3398,'multiline':False]
['text':' lists with matching positions within each string and the third item','line_number':3399,'multiline':False]
['text':' is the list of scores of the matches.','line_number':3400,'multiline':False]
['text':'/ "matchfuzzy()" function','line_number':3412,'multiline':False]
['text':'/ "matchfuzzypos()" function','line_number':3418,'multiline':False]
['text':'/ Same as fuzzy_match_item_compare() except for use with a string match','line_number':3424,'multiline':False]
['text':'/ Sort fuzzy matches by score','line_number':3436,'multiline':False]
['text':' Sort the list by the descending order of the match score','line_number':3440,'multiline':False]
['text':'/ Same as fuzzy_match_item_compare() except for use with a function name','line_number':3444,'multiline':False]
['text':'/ string match. <SNR> functions should be sorted to the end.','line_number':3445,'multiline':False]
['text':'/ Sort fuzzy matches of function names by score.','line_number':3465,'multiline':False]
['text':'/ <SNR> functions should be sorted to the end.','line_number':3466,'multiline':False]
['text':' Sort the list by the descending order of the match score','line_number':3470,'multiline':False]
['text':'/ Fuzzy match "pat" in "str".','line_number':3474,'multiline':False]
['text':'/ @returns 0 if there is no match. Otherwise, returns the match score.','line_number':3475,'multiline':False]
['text':'/ Copy a list of fuzzy matches into a string list after sorting the matches by','line_number':3490,'multiline':False]
['text':'/ the fuzzy score. Frees the memory allocated for "fuzmatch".','line_number':3491,'multiline':False]
['text':' Sort the list by the descending order of the match score','line_number':3502,'multiline':False]
['text':'/ Free a list of fuzzy string matches.','line_number':3515,'multiline':False]
['text':'/ Get line "lnum" and copy it into "buf[LSIZE]".','line_number':3527,'multiline':False]
['text':'/ The copy is made because the regexp may make the line invalid when using a','line_number':3528,'multiline':False]
['text':'/ mark.','line_number':3529,'multiline':False]
['text':'/ Find identifiers or defines in included files.','line_number':3537,'multiline':False]
['text':'/ If p_ic && compl_status_sol() then ptr must be in lowercase.','line_number':3538,'multiline':False]
['text':'/','line_number':3539,'multiline':False]
['text':'/ @param ptr            pointer to search pattern','line_number':3540,'multiline':False]
['text':'/ @param dir            direction of expansion','line_number':3541,'multiline':False]
['text':'/ @param len            length of search pattern','line_number':3542,'multiline':False]
['text':'/ @param whole          match whole words only','line_number':3543,'multiline':False]
['text':'/ @param skip_comments  don't match inside comments','line_number':3544,'multiline':False]
['text':'/ @param type           Type of search; are we looking for a type? a macro?','line_number':3545,'multiline':False]
['text':'/ @param action         What to do when we find it','line_number':3546,'multiline':False]
['text':'/ @param start_lnum     first line to start searching','line_number':3547,'multiline':False]
['text':'/ @param end_lnum       last line for searching','line_number':3548,'multiline':False]
['text':' Stack of included files','line_number':3552,'multiline':False]
['text':' When we need more space','line_number':3553,'multiline':False]
['text':' For type==CHECK_PATH','line_number':3560,'multiline':False]
['text':' when CONT_SOL is set compare "ptr" with the beginning of the','line_number':3583,'multiline':False]
['text':' line is faster than quote_meta/regcomp/regexec "ptr" -- Acevedo','line_number':3584,'multiline':False]
['text':' ignore case according to p_ic, p_scs and pat','line_number':3590,'multiline':False]
['text':' don't ignore case in incl. pat.','line_number':3604,'multiline':False]
['text':' don't ignore case in define pat.','line_number':3613,'multiline':False]
['text':' do at least one line','line_number':3623,'multiline':False]
['text':' Use text from '\zs' to '\ze' (or end) of 'include'.','line_number':3635,'multiline':False]
['text':' Use text after match with 'include'.','line_number':3642,'multiline':False]
['text':' Check whether we have already searched in this file','line_number':3649,'multiline':False]
['text':' cursor below last one */','line_number':3661,'multiline':False]
['text':' don't display if 'q' typed at "--more--"','line_number':3662,'multiline':False]
['text':' message','line_number':3663,'multiline':False]
['text':' cursor below last one','line_number':3679,'multiline':False]
['text':' cursor at status line','line_number':3681,'multiline':False]
['text':' don't display if 'q' typed','line_number':3697,'multiline':False]
['text':' for "--more--" message','line_number':3698,'multiline':False]
['text':' using "new_fname" is more reliable, e.g., when','line_number':3703,'multiline':False]
['text':' 'includeexpr' is set.','line_number':3704,'multiline':False]
['text':' Isolate the file name.','line_number':3707,'multiline':False]
['text':' Include the surrounding "" or <> if present.','line_number':3708,'multiline':False]
['text':' pattern contains \zs, use the match','line_number':3711,'multiline':False]
['text':' find the file name after the end of the match','line_number':3716,'multiline':False]
['text':' Nothing found, use the rest of the line.','line_number':3723,'multiline':False]
['text':' Avoid checking before the start of the line, can','line_number':3727,'multiline':False]
['text':' happen if \zs appears in the regexp.','line_number':3728,'multiline':False]
['text':' Push the new file onto the file stack','line_number':3754,'multiline':False]
['text':' Something wrong. We will forget one of our already visited files','line_number':3778,'multiline':False]
['text':' now.','line_number':3779,'multiline':False]
['text':' reset in msg_trunc()','line_number':3787,'multiline':False]
['text':' Check if the line is a define (type == FIND_DEFINE)','line_number':3800,'multiline':False]
['text':' Pattern must be first identifier after 'define', so skip','line_number':3806,'multiline':False]
['text':' to that position before checking for match of pattern.  Also','line_number':3807,'multiline':False]
['text':' don't let it match beyond the end of this identifier.','line_number':3808,'multiline':False]
['text':' Look for a match.  Don't do this if we are looking for a','line_number':3816,'multiline':False]
['text':' define and this line didn't match define_prog above.','line_number':3817,'multiline':False]
['text':' compare the first "len" chars from "ptr"','line_number':3820,'multiline':False]
['text':' Check if the line is not a comment line (unless we are','line_number':3835,'multiline':False]
['text':' looking for a define).  A line starting with "# define"','line_number':3836,'multiline':False]
['text':' is not considered to be a comment line.','line_number':3837,'multiline':False]
['text':' Also check for a "/ *" or "/ /" before the match.','line_number':3845,'multiline':False]
['text':' Skips lines like "int backwards;  / * normal index','line_number':3846,'multiline':False]
['text':' * /" when looking for "normal".','line_number':3847,'multiline':False]
['text':' Note: Doesn't skip "/ *" in comments.','line_number':3848,'multiline':False]
['text':' After "//" all text is comment','line_number':3857,'multiline':False]
['text':' Can find match after "* /".','line_number':3863,'multiline':False]
['text':' IOSIZE > compl_length, so the strncpy works','line_number':3893,'multiline':False]
['text':' NOLINT(runtime/printf)','line_number':3894,'multiline':False]
['text':' Get the next line: when "depth" < 0  from the current','line_number':3896,'multiline':False]
['text':' buffer, otherwise from the included file.  Jump to','line_number':3897,'multiline':False]
['text':' exit_matched when past the last line.','line_number':3898,'multiline':False]
['text':' we read a line, set "already" to check this "line" later','line_number':3909,'multiline':False]
['text':' if depth >= 0 we'll increase files[depth].lnum far','line_number':3910,'multiline':False]
['text':' below  -- Acevedo','line_number':3911,'multiline':False]
['text':' IObuf =~ "\(\k\|\i\).* ", thus i >= 2','line_number':3920,'multiline':False]
['text':' copy as much as possible of the new word','line_number':3928,'multiline':False]
['text':' NOLINT(runtime/printf)','line_number':3932,'multiline':False]
['text':' if dir was BACKWARD then honor it just once','line_number':3949,'multiline':False]
['text':' cursor at status line','line_number':3957,'multiline':False]
['text':' cursor below last one','line_number':3961,'multiline':False]
['text':' don't display if 'q' typed','line_number':3963,'multiline':False]
['text':' at "--more--" message','line_number':3964,'multiline':False]
['text':' Set matched flag for this file and all the ones that','line_number':3977,'multiline':False]
['text':' include it','line_number':3978,'multiline':False]
['text':' ":psearch" uses the preview window','line_number':3993,'multiline':False]
['text':' match in current file','line_number':4005,'multiline':False]
['text':' failed to jump to file','line_number':4012,'multiline':False]
['text':' failed to jump to file','line_number':4022,'multiline':False]
['text':' autocommands may have changed the lnum, we don't','line_number':4024,'multiline':False]
['text':' want that here','line_number':4025,'multiline':False]
['text':' Return cursor to where we were','line_number':4036,'multiline':False]
['text':' look for other matches in the rest of the line if we','line_number':4045,'multiline':False]
['text':' are not at the end of it already','line_number':4046,'multiline':False]
['text':' Read the next line.  When reading an included file and encountering','line_number':4063,'multiline':False]
['text':' end-of-file, close the file and continue in the file that included','line_number':4064,'multiline':False]
['text':' it.','line_number':4065,'multiline':False]
['text':' we could read the line','line_number':4079,'multiline':False]
['text':' Remove any CR and LF from the line.','line_number':4081,'multiline':False]
['text':' End of big while (true) loop.','line_number':4097,'multiline':False]
['text':' Close any files that are still open.','line_number':4099,'multiline':False]
['text':' cursor below last one','line_number':4143,'multiline':False]
['text':' cursor at status line','line_number':4145,'multiline':False]
['text':' 'q' typed at "--more--" message','line_number':4147,'multiline':False]
['text':' We used fgets(), so get rid of newline at end','line_number':4153,'multiline':False]
['text':' Show match nr.','line_number':4163,'multiline':False]
['text':' Show line nr.','line_number':4165,'multiline':False]
['text':' Highlight line numbers.','line_number':4166,'multiline':False]
['text':' Definition continues until line that doesn't end with '\'','line_number':4172,'multiline':False]
['text':' end of file','line_number':4178,'multiline':False]
['text':'/ Get last search pattern','line_number':4192,'multiline':False]
['text':'/ Get last substitute pattern','line_number':4198,'multiline':False]
['text':'/ Set last search pattern','line_number':4205,'multiline':False]
['text':'/ Set last substitute pattern','line_number':4213,'multiline':False]
['text':'/ Set last used search pattern','line_number':4221,'multiline':False]
['text':'/','line_number':4222,'multiline':False]
['text':'/ @param[in]  is_substitute_pattern  If true set substitute pattern as last','line_number':4223,'multiline':False]
['text':'/                                    used. Otherwise sets search pattern.','line_number':4224,'multiline':False]
['text':'/ Returns true if search pattern was the last used one','line_number':4230,'multiline':False]
['text':'/ @return  true if 'hlsearch' highlight is currently in use.','line_number':4236,'multiline':False]
