['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':50,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-pro-type-member-init)','line_number':59,'multiline':False]
['text':' replaces all invalid characters with underscore','line_number':134,'multiline':False]
['text':' Don't start names with underscore','line_number':142,'multiline':False]
['text':' Can't vectorize due to non-constant loop start!','line_number':247,'multiline':False]
['text':' Can't vectorize due to non-constant loop stop!','line_number':253,'multiline':False]
['text':' Vectorization failed!','line_number':264,'multiline':False]
['text':' Can't vectorize a Ramp!','line_number':413,'multiline':False]
['text':' Can't vectorize a Broadcast!','line_number':446,'multiline':False]
['text':' Can't vectorize an IfThenElse condition!','line_number':455,'multiline':False]
['text':' Can't vectorize nested For with dependent loop bounds!','line_number':493,'multiline':False]
['text':' IRMutator does in-place mutations. But the logic in vectorization checks','line_number':509,'multiline':False]
['text':' for success by looking for a new stmt. So, we override the in-place','line_number':510,'multiline':False]
['text':' mutations and create a clone here if any of its statements change.','line_number':511,'multiline':False]
['text':' TODO: Can we change the logic of vectorizer so that we don't need this?','line_number':512,'multiline':False]
['text':' Attempt to vectorize each input.','line_number':556,'multiline':False]
['text':' If none of them vectorized, then don't vectorize this.','line_number':565,'multiline':False]
['text':' Insert broadcasts for any inputs that weren't vectorized.','line_number':570,'multiline':False]
['text':' And then vectorize this node.','line_number':579,'multiline':False]
['text':' Can't vectorize reduction axes.','line_number':595,'multiline':False]
['text':' We clone f before vectorizing. So, any partial vectorization will','line_number':611,'multiline':False]
['text':' have modified the clone. In case of an exception, we can continue','line_number':612,'multiline':False]
['text':' using f.','line_number':613,'multiline':False]
['text':' Vectorization was not successful.','line_number':622,'multiline':False]
['text':' Flatten initializers.','line_number':641,'multiline':False]
['text':' If the index can be a constant, then that dimension must have size 1','line_number':667,'multiline':False]
['text':' (since we don't support in-place writes). Resolves issue 52581.','line_number':668,'multiline':False]
['text':' Dimensions of producer and consumer expressions do not match in inliner','line_number':687,'multiline':False]
['text':' in the fuser','line_number':688,'multiline':False]
['text':' Duplicated variables','line_number':700,'multiline':False]
['text':' Add a mapping for each function parameter to it's source name.','line_number':704,'multiline':False]
['text':' Call the actual replacement.','line_number':714,'multiline':False]
['text':' Remove the mappings we created for this function parameters.','line_number':721,'multiline':False]
['text':' Number of indices doesn't match buf rank in the fuser','line_number':747,'multiline':False]
['text':' If we don't inline successfully return the given load.','line_number':753,'multiline':False]
['text':' Replace the target variable with the caller expressions.','line_number':760,'multiline':False]
['text':' Continue to transform the value from the lookup table.','line_number':770,'multiline':False]
['text':' Handle random intrinsics which should be cached.','line_number':775,'multiline':False]
['text':' Create a new Let Statement for the random variable, which we can refer','line_number':784,'multiline':False]
['text':' to multiple times and resolve the same value (ie. store it in a scalar','line_number':785,'multiline':False]
['text':' rather than the Tensor).','line_number':786,'multiline':False]
['text':' Remove the buffer write from the inlined function.','line_number':795,'multiline':False]
['text':' If the buf_ is in the outputs set, keep its statement intact. Otherwise,','line_number':800,'multiline':False]
['text':' remove it.','line_number':801,'multiline':False]
['text':' Producer statement for output buf should remain non-null in the fuser','line_number':806,'multiline':False]
['text':' Any Random Intrinsics that were turned into vars must be inserted here.','line_number':817,'multiline':False]
['text':' Find any random bindings that should be defined in this loops body.','line_number':848,'multiline':False]
['text':' Index Vars present in the producer.','line_number':869,'multiline':False]
['text':' In the producer's scope - we need to bind any calls to rand().','line_number':875,'multiline':False]
['text':' If buf is used or defined in an ExternalCall, we cannot inline it','line_number':886,'multiline':False]
['text':' Find producers.','line_number':898,'multiline':False]
['text':' Cannot inline a reduction computation','line_number':905,'multiline':False]
['text':' Cannot inline Buf with multiple Tensors','line_number':909,'multiline':False]
['text':' Cannot find a relevant store to inline a buf in the fuser','line_number':917,'multiline':False]
['text':' Inlining may not always be successful. Since all mutations now happen','line_number':931,'multiline':False]
['text':' in-place, an unsuccessful inlining transformation might leave the IR','line_number':932,'multiline':False]
['text':' in an invalid state. To get around this problem, we clone the root stmt,','line_number':933,'multiline':False]
['text':' try inlining on the clone, and if it succeeds, we proceed to perform','line_number':934,'multiline':False]
['text':' inlining on the actual root stmt. This way the root stmt will always be','line_number':935,'multiline':False]
['text':' in a valid state.','line_number':936,'multiline':False]
['text':' Could not find buffer producer to inline','line_number':949,'multiline':False]
['text':' inlining buffers with multiple uses can create duplicated work, which can','line_number':955,'multiline':False]
['text':' slow down cpu code generation but is enabled on gpu because it avoids','line_number':956,'multiline':False]
['text':' difficult synchronization logic across blocks. Inlining trivial reads does','line_number':957,'multiline':False]
['text':' not duplicate work','line_number':958,'multiline':False]
['text':' if the intermediate is the buffer formed from reading in the input','line_number':979,'multiline':False]
['text':' tensors, always inline, bc we are not duplicating any work','line_number':980,'multiline':False]
['text':' and avoiding an intermediary buffer','line_number':981,'multiline':False]
['text':' If S is not a store, it must be an ExternalCall.','line_number':990,'multiline':False]
['text':' all bufs will have at least one store (if they have > 1 they cant be','line_number':1000,'multiline':False]
['text':' inlined anyway)','line_number':1001,'multiline':False]
['text':' if only one read, we can inline it without duplicating work','line_number':1003,'multiline':False]
['text':' TODO: Unify with DepTracker','line_number':1019,'multiline':False]
['text':' Sets of loads and stores in order to keep the results unique','line_number':1080,'multiline':False]
['text':' Simply list all Stores and Block that are children of the given stmt','line_number':1093,'multiline':False]
['text':' Expand reduction ops.','line_number':1178,'multiline':False]
['text':' This is extended from IRCloner instead of IRMutator because we want all','line_number':1187,'multiline':False]
['text':' the rest of the IR nodes (the ones not touched directly) to be cloned.','line_number':1188,'multiline':False]
['text':' Check if the given condition is optimizable.','line_number':1206,'multiline':False]
['text':' Specifically, this function looks for the following pattern:','line_number':1207,'multiline':False]
['text':'    "var < expr"','line_number':1208,'multiline':False]
['text':'','line_number':1209,'multiline':False]
['text':' If this pattern is found, then this function:','line_number':1210,'multiline':False]
['text':'   * sets `cond_var` to `var`,','line_number':1211,'multiline':False]
['text':'   * sets `compared_value` to `expr`, and','line_number':1212,'multiline':False]
['text':'   * returns true.','line_number':1213,'multiline':False]
['text':' Checks if the given if-then-else expression is a conditional that is','line_number':1230,'multiline':False]
['text':' generated from `aten::cat`.','line_number':1231,'multiline':False]
['text':'','line_number':1232,'multiline':False]
['text':' The expected format of conditionals is:','line_number':1233,'multiline':False]
['text':'     IfThenElse(var < val1? 1 : 0,','line_number':1234,'multiline':False]
['text':'       IfThenElse (var < val2? 1 : 0,','line_number':1235,'multiline':False]
['text':'         IfThenElse (var < val3? 1 : 0,','line_number':1236,'multiline':False]
['text':'           sub-expr1,','line_number':1237,'multiline':False]
['text':'           sub-expr2),','line_number':1238,'multiline':False]
['text':'         sub-expr3),','line_number':1239,'multiline':False]
['text':'       sub-expr4)','line_number':1240,'multiline':False]
['text':'','line_number':1241,'multiline':False]
['text':' If such a conditional is found, this function also sets:','line_number':1242,'multiline':False]
['text':'   * cond_var to the condition variable found in this expression.','line_number':1243,'multiline':False]
['text':'   * comp_values to the list of compared values in the condition expressions.','line_number':1244,'multiline':False]
['text':'   * sub_exprs to the list of sub-expressions that are the result of this','line_number':1245,'multiline':False]
['text':'     if-then-else expression.','line_number':1246,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1253,'multiline':False]
['text':' Different condition variables found in nested if-then-else','line_number':1259,'multiline':False]
['text':' expressions. Can not optimize such cases.','line_number':1260,'multiline':False]
['text':' namespace','line_number':1294,'multiline':False]
['text':' Consider every store in the root_stmt_ and try to optimize the','line_number':1297,'multiline':False]
['text':' conditionals in that store.','line_number':1298,'multiline':False]
['text':' `comp_values` represent the list of compared values that will be','line_number':1303,'multiline':False]
['text':' collected as we check for the expected pattern. Since that will','line_number':1304,'multiline':False]
['text':' only include the RHS of the conditions in the if-then-else expressions','line_number':1305,'multiline':False]
['text':' we need to start with `0` which is the initial bound, given that we','line_number':1306,'multiline':False]
['text':' only handle normalized loops (check for this is done below).','line_number':1307,'multiline':False]
['text':' We only check if the first if-then-else expression in this store','line_number':1314,'multiline':False]
['text':' corresponds to a conditional of the required format. If there are more','line_number':1315,'multiline':False]
['text':' than one such conditional, optimizing them requires checking if the','line_number':1316,'multiline':False]
['text':' conditions are exactly the same across them and handling all of them','line_number':1317,'multiline':False]
['text':' together. Currently, this is not handled.','line_number':1318,'multiline':False]
['text':' Currently, we only handle the case where the condition variable','line_number':1331,'multiline':False]
['text':' is the same as the inner-most loop variable.','line_number':1332,'multiline':False]
['text':' TODO: Handle all other cases here.','line_number':1333,'multiline':False]
['text':'','line_number':1334,'multiline':False]
['text':' In order to handle all other cases, the method `clone_and_replace`','line_number':1335,'multiline':False]
['text':' called below to clone the body of the loop with a new store needs','line_number':1336,'multiline':False]
['text':' to recursively handle cloning of the loops and other blocks it','line_number':1337,'multiline':False]
['text':' contains.','line_number':1338,'multiline':False]
['text':' Do not optimize this conditional since the condition variable','line_number':1344,'multiline':False]
['text':' refers to a loop that is not normalized.','line_number':1345,'multiline':False]
['text':' This loop has already been split while optimizing conditionals','line_number':1349,'multiline':False]
['text':' earlier.','line_number':1350,'multiline':False]
['text':'','line_number':1351,'multiline':False]
['text':' Optimizing multiple conditionals that require splitting the same loop','line_number':1352,'multiline':False]
['text':' is tricky. It requires checking if the conditions are exactly the same','line_number':1353,'multiline':False]
['text':' across them and handling all of them together by splitting the loop','line_number':1354,'multiline':False]
['text':' exactly once.','line_number':1355,'multiline':False]
['text':'','line_number':1356,'multiline':False]
['text':' Currently, this case is not supported.','line_number':1357,'multiline':False]
['text':' `comp_values` needs to include the end bound, which is `for_to_split`','line_number':1362,'multiline':False]
['text':' stop value.','line_number':1363,'multiline':False]
['text':' Check if all `comp_values` are constants and they are sorted.','line_number':1366,'multiline':False]
['text':' Remove all the if-then-else expressions from this store and create','line_number':1371,'multiline':False]
['text':' one loop per sub-expression.','line_number':1372,'multiline':False]
['text':' Find outer-most For loops','line_number':1399,'multiline':False]
['text':' Traverse the For loop nest find inner-most loops, which are','line_number':1418,'multiline':False]
['text':' vectorization candidates.','line_number':1419,'multiline':False]
['text':' vectorize inner loops.','line_number':1439,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1441,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1443,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1451,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1453,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1497,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1537,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1543,'multiline':False]
['text':' Normalize the loop to simplify start and stop bound computation','line_number':1562,'multiline':False]
['text':' x -> x.outer * inner.size + x.inner','line_number':1587,'multiline':False]
['text':' x -> x.tail + outer.size * inner.size','line_number':1593,'multiline':False]
['text':' The input loop `f` will be the outer loop after split.','line_number':1611,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1619,'multiline':False]
['text':' split_count = (size + factor - 1) / factor','line_number':1646,'multiline':False]
['text':' x -> x.outer * inner.size + x.inner','line_number':1656,'multiline':False]
['text':' TODO: is it ok that we're doing it eagerly? In the other implementation we','line_number':1661,'multiline':False]
['text':' are only materializing predicates at the last, lowering, step.','line_number':1662,'multiline':False]
['text':' The input loop `f` will be the outer loop after split.','line_number':1678,'multiline':False]
['text':' Extract bodies for all the loops after distribution.','line_number':1702,'multiline':False]
['text':' The first loop body has to be in the original loop.','line_number':1718,'multiline':False]
['text':' Create loops for all the remaining blocks.','line_number':1722,'multiline':False]
['text':' Add all the new loops to the parent block.','line_number':1723,'multiline':False]
['text':' Returns true if the given list of indices refer to two accesses','line_number':1780,'multiline':False]
['text':' that are loop-independent w.r.t. the given list of outer loop','line_number':1781,'multiline':False]
['text':' variables.','line_number':1782,'multiline':False]
['text':' High-level algorithm to check if two accesses to a buffer, A and B, one of','line_number':1813,'multiline':False]
['text':' which is a Store, result in a loop-carried dependence:','line_number':1814,'multiline':False]
['text':'   1. For every pair of index expressions, Ai and Bi, that refer to a dim','line_number':1815,'multiline':False]
['text':'      of A and B, if one of the following conditions are satisfied:','line_number':1816,'multiline':False]
['text':'       a) Ai and Bi are equal (OR)','line_number':1817,'multiline':False]
['text':'       b) Both Ai and Bi do not contain any outer-loop variables','line_number':1818,'multiline':False]
['text':'      then, the dependence between A and B is a loop-independent','line_number':1819,'multiline':False]
['text':'      dependence. This is because, in the case of b), those index','line_number':1820,'multiline':False]
['text':'      expressions do not affect the ordering of accesses A and B.','line_number':1821,'multiline':False]
['text':'   2. If condition 1) is not satisfied:','line_number':1822,'multiline':False]
['text':'       a) if the bounds on the accesses overlap, then this is a','line_number':1823,'multiline':False]
['text':'          loop-carried dependence.','line_number':1824,'multiline':False]
['text':'       b) if the bounds on the accesses do not overlap, then there is no','line_number':1825,'multiline':False]
['text':'          dependence.','line_number':1826,'multiline':False]
['text':'','line_number':1827,'multiline':False]
['text':' NOTE: Since we check for equality of index expressions whenever outer','line_number':1828,'multiline':False]
['text':'     loop variables are involved, this may incorrectly report some cases as','line_number':1829,'multiline':False]
['text':'     having a loop-carried dependence. It is impractical to handle all','line_number':1830,'multiline':False]
['text':'     possible cases here, so, we are being conservative and allow for','line_number':1831,'multiline':False]
['text':'     some false positives. While this will prevent some loop fusion','line_number':1832,'multiline':False]
['text':'     opportunities, that should be a small fraction of the cases that are','line_number':1833,'multiline':False]
['text':'     allowed.','line_number':1834,'multiline':False]
['text':'','line_number':1835,'multiline':False]
['text':' Implementation:','line_number':1836,'multiline':False]
['text':'','line_number':1837,'multiline':False]
['text':' For every pair of statements, S1 and S2, in the loop:','line_number':1838,'multiline':False]
['text':'  * Get the loads and stores in S1 and S2.','line_number':1839,'multiline':False]
['text':'  * For every store in S1 and load in S2 to the same buffer, if the index','line_number':1840,'multiline':False]
['text':'    expressions are not equal and there is an overlap in accesses, return','line_number':1841,'multiline':False]
['text':'    true to indicate a loop-carried dependence.','line_number':1842,'multiline':False]
['text':'  * For every load in S1 and store in S2 to the same buffer, if the index','line_number':1843,'multiline':False]
['text':'    expressions are not equal and there is an overlap in accesses, return','line_number':1844,'multiline':False]
['text':'    true to indicate a loop-carried dependence.','line_number':1845,'multiline':False]
['text':'  * For every store in S1 and store in S2 to the same buffer, if the index','line_number':1846,'multiline':False]
['text':'    expressions are not equal and there is an overlap in accesses, return','line_number':1847,'multiline':False]
['text':'    true to indicate a loop-carried dependence.','line_number':1848,'multiline':False]
['text':' ReadAfterWrite','line_number':1855,'multiline':False]
['text':' WriteAfterRead','line_number':1868,'multiline':False]
['text':' WriteAfterWrite','line_number':1881,'multiline':False]
['text':' Check if all the loops have the same parent.','line_number':1910,'multiline':False]
['text':' Currently, we only handle cases where there are no statements between','line_number':1926,'multiline':False]
['text':' the given loops in their parents body. We can possibly relax this','line_number':1927,'multiline':False]
['text':' constraint by allowing statements that do not affect the loops being','line_number':1928,'multiline':False]
['text':' fused by performing some dependency analysis. TODO.','line_number':1929,'multiline':False]
['text':' Fuse the loops by taking all the statements from the second loops','line_number':1948,'multiline':False]
['text':' onwards and moving them into the first loop's body.','line_number':1949,'multiline':False]
['text':' This way the final fused loop will be the same as the first loop.','line_number':1950,'multiline':False]
['text':' Check if bounds are the same for all the loops.','line_number':1971,'multiline':False]
['text':' We need to check if fusing the loops results in a loop-carried dependence.','line_number':1987,'multiline':False]
['text':' This check can be done only after the loops are fused into one. But if the','line_number':1988,'multiline':False]
['text':' check is violated, we need to return the given loops in the original form.','line_number':1989,'multiline':False]
['text':' So, we create a clone of all the loops, fuse them and check for this.','line_number':1990,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':1999,'multiline':False]
['text':' Now that all conditions are satisfied, we fuse the given loops.','line_number':2006,'multiline':False]
['text':' guess b is the latter.','line_number':2011,'multiline':False]
['text':' yes, b is after a.','line_number':2014,'multiline':False]
['text':' check that the two are in the same loop nest.','line_number':2020,'multiline':False]
['text':' a is after b.','line_number':2024,'multiline':False]
['text':' a and b have no relationship.','line_number':2030,'multiline':False]
['text':' nothing to do.','line_number':2036,'multiline':False]
['text':' find inner and outer.','line_number':2039,'multiline':False]
['text':' Find relevant axes, store reversed.','line_number':2048,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)','line_number':2055,'multiline':False]
['text':' Do a shallow copy of the inner blocks.','line_number':2064,'multiline':False]
['text':' s is the false branch of Cond','line_number':2079,'multiline':False]
['text':' This is the major complexity in loop reordering: handling statements not in','line_number':2087,'multiline':False]
['text':' the straight line of the reorder. To handle this we partition the tree into','line_number':2088,'multiline':False]
['text':' the section before the critical path and after the critical path.','line_number':2089,'multiline':False]
['text':'','line_number':2090,'multiline':False]
['text':' An example of this pattern is:','line_number':2091,'multiline':False]
['text':' for i in ..','line_number':2092,'multiline':False]
['text':'   Statement A','line_number':2093,'multiline':False]
['text':'   for j in ..','line_number':2094,'multiline':False]
['text':'     Statement B','line_number':2095,'multiline':False]
['text':'   Statement C','line_number':2096,'multiline':False]
['text':'','line_number':2097,'multiline':False]
['text':' When reordering loop i and j we need to ensure that Statement A and C are','line_number':2098,'multiline':False]
['text':' still both executed with the loop extents of i, and that the three','line_number':2099,'multiline':False]
['text':' statements are not reordered (as much as possible).','line_number':2100,'multiline':False]
['text':' If the inner loop had a component after the loop we must wrap it in a For','line_number':2102,'multiline':False]
['text':' loop matching this level of the tree.','line_number':2103,'multiline':False]
['text':' Be careful not to invalidate the iterator.','line_number':2111,'multiline':False]
['text':' This is the midpoint.','line_number':2114,'multiline':False]
['text':' If there were no existing statements this loop does not need  to be','line_number':2117,'multiline':False]
['text':' preserved and we can roll it into the above loop.','line_number':2118,'multiline':False]
['text':' Statements after the reordered path must be moved to a new tree after','line_number':2123,'multiline':False]
['text':' the reordered statement has occurred to preserve ordering.','line_number':2124,'multiline':False]
['text':' We can leave any statements before the reordered loop alone, so long','line_number':2132,'multiline':False]
['text':' as we preserve the loop structure.','line_number':2133,'multiline':False]
['text':' now we can actually reorder the chosen axes.','line_number':2139,'multiline':False]
['text':' Create the reordered internals:','line_number':2142,'multiline':False]
['text':' Append the new statements to the root of the tree.','line_number':2147,'multiline':False]
['text':' If the top level is now empty, eliminate it.','line_number':2149,'multiline':False]
['text':' Reorder the loops according to the permutation.','line_number':2198,'multiline':False]
['text':' Remove the bodies from all the loops.','line_number':2204,'multiline':False]
['text':' We use an empty block statement to replace the outermost loop','line_number':2206,'multiline':False]
['text':' so that we know the position where the outermost reordered loop','line_number':2207,'multiline':False]
['text':' is to be inserted.','line_number':2208,'multiline':False]
['text':' Set the new bodies after reorder for all the loops.','line_number':2220,'multiline':False]
['text':' Split x, y axes by x_factor and y_factor','line_number':2262,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2263,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2266,'multiline':False]
['text':' Distribute xi over yo and ytail so we can manipulate the loop order of {xo,','line_number':2270,'multiline':False]
['text':' xi, yo, yi}','line_number':2271,'multiline':False]
['text':' For {xi, yo, yi}, reorder the axes to be yo, xi, yi','line_number':2274,'multiline':False]
['text':' For {xi, ytail}, reorder the axes to be ytail, xi','line_number':2280,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2337,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2346,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2353,'multiline':False]
['text':' No need to normalize anymore here.','line_number':2371,'multiline':False]
['text':' This function expects that there are 'num' loops perfectly nested within','line_number':2384,'multiline':False]
['text':' and including 'f'.','line_number':2385,'multiline':False]
['text':' This loop nest is already flattened.','line_number':2413,'multiline':False]
['text':' Check if all the loops correspond to a perfect loopnest:','line_number':2418,'multiline':False]
['text':'  * every loop except the inner-most should have only one stmt, the For.','line_number':2419,'multiline':False]
['text':' Do not flatten, otherwise.','line_number':2420,'multiline':False]
['text':' This check also ensures we do not flatten reduction loops.','line_number':2421,'multiline':False]
['text':' Normalize the loops before flattening.','line_number':2429,'multiline':False]
['text':' We need to normalize them from inner-most to outer because once the outer','line_number':2430,'multiline':False]
['text':' loop is normalized, the given pointers to inner loops point to old code.','line_number':2431,'multiline':False]
['text':' For the same reason, we can't store the normalized inner loops until after','line_number':2432,'multiline':False]
['text':' the outer-most loop is normalized.','line_number':2433,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2434,'multiline':False]
['text':' 'normalized' points to the outer-most loop in the normalized loopnest.','line_number':2440,'multiline':False]
['text':' Collect all the normalized loops.','line_number':2441,'multiline':False]
['text':' NOLINTNEXTLINE(clang-analyzer-core.CallAndMessage)','line_number':2442,'multiline':False]
['text':' NOLINTNEXTLINE(cppcoreguidelines-init-variables)','line_number':2470,'multiline':False]
['text':' Loop iterations in NNC IR do not follow sequential semantics by default.','line_number':2476,'multiline':False]
['text':' In other words, the iterations of the loops could be executed in any','line_number':2477,'multiline':False]
['text':' random order without affecting correctness. This constraint in turn','line_number':2478,'multiline':False]
['text':' implies that there canâ€™t be any *inter-iteration* dependences','line_number':2479,'multiline':False]
['text':' (or *loop-carried* dependences) in NNC loops. So, any NNC IR with such','line_number':2480,'multiline':False]
['text':' dependences is considered invalid.','line_number':2481,'multiline':False]
['text':'','line_number':2482,'multiline':False]
['text':' Given the constraint above, for any pair of accesses to a buffer (where','line_number':2483,'multiline':False]
['text':' at least one of the access is a write), the accesses must be','line_number':2484,'multiline':False]
['text':' loop-independent on the innermost loop containing the accesses as well as','line_number':2485,'multiline':False]
['text':' all the loops above it. So, any dimension that uses only those loop','line_number':2486,'multiline':False]
['text':' variables to access the given buffer could be optimized away.','line_number':2487,'multiline':False]
['text':'','line_number':2488,'multiline':False]
['text':' Algorithm:','line_number':2489,'multiline':False]
['text':'   * Find all the accesses to the given buf. (A)','line_number':2490,'multiline':False]
['text':'   * Find the parent common to all accesses in A. (P)','line_number':2491,'multiline':False]
['text':'   * Collect all the loops above P. (L)','line_number':2492,'multiline':False]
['text':'   * Collect all the loop variables corresponding to L. (LV)','line_number':2493,'multiline':False]
['text':'   * For every access a in A:','line_number':2494,'multiline':False]
['text':'      * For the index I in every dimension of a:','line_number':2495,'multiline':False]
['text':'          * If the variables in I are all in LV, mark this dimension','line_number':2496,'multiline':False]
['text':'            for deletion.','line_number':2497,'multiline':False]
['text':'   * For every dimension that is marked for deletion in ALL accesses in A:','line_number':2498,'multiline':False]
['text':'      * Update the buffer to set the size of that dimension to 1.','line_number':2499,'multiline':False]
['text':'      * Update all accesses in A to set the index in that dimension to 0.','line_number':2500,'multiline':False]
['text':' Find the parent common to all the buffer accesses.','line_number':2505,'multiline':False]
['text':' Collect all the loops that are above the common parent.','line_number':2518,'multiline':False]
['text':' TODO: Need to handle other Stmts / Exprs that read / write buffers.','line_number':2525,'multiline':False]
['text':' Vector to indicate which dimensions could be compressed away.','line_number':2529,'multiline':False]
['text':' A variable in this index is not in loop_vars.','line_number':2540,'multiline':False]
['text':' This implies that this dimension cannot be optimized away.','line_number':2541,'multiline':False]
['text':' Compress buffer by removing the marked dims.','line_number':2566,'multiline':False]
['text':' Modify all access to reflect the removed dims.','line_number':2575,'multiline':False]
['text':' special case for reduction Tensors, ignore the initializer if it's the only','line_number':2637,'multiline':False]
['text':' op:','line_number':2638,'multiline':False]
['text':' NOLINT','line_number':2642,'multiline':False]
['text':' NOLINT','line_number':2657,'multiline':False]
['text':' Auxiliary class for rewriting we're doing in `compute_at`. See','line_number':2718,'multiline':False]
['text':' LoopNest::computeAt for more details.','line_number':2719,'multiline':False]
['text':' Map indices to call-parameters.','line_number':2786,'multiline':False]
['text':' Map indices to call-parameters.','line_number':2811,'multiline':False]
['text':' Check bounds but don't care about AccessKind.','line_number':2856,'multiline':False]
['text':' Determine the size of the cache, and create a loop var for each dimension.','line_number':2877,'multiline':False]
['text':' Create the var.','line_number':2889,'multiline':False]
['text':' determine the offsets for calls into the cache based off the loop start of','line_number':2893,'multiline':False]
['text':' each axis.','line_number':2894,'multiline':False]
['text':' Replace accesses to the producer in the consumer with the cache.','line_number':2900,'multiline':False]
['text':' replace the old consumer with the replaced consumer.','line_number':2904,'multiline':False]
['text':' if the consumer is a block, we should mutate it in place.','line_number':2907,'multiline':False]
['text':' If there's a reduction and we are operating on the reduce axis, we need to','line_number':2910,'multiline':False]
['text':' initialize the cache with 0s. Also, we can't just write the result straight','line_number':2911,'multiline':False]
['text':' back to the original buffer, since after parallelism the writes will race.','line_number':2912,'multiline':False]
['text':' Instead we need to create a new ReduceOp.','line_number':2913,'multiline':False]
['text':' reduceOp means we had both loads and stores.','line_number':2929,'multiline':False]
['text':' Init cache to 0.','line_number':2931,'multiline':False]
['text':' Reduce back to the original buffer:','line_number':2946,'multiline':False]
['text':' Fill the cache with values from the consumer.','line_number':2971,'multiline':False]
['text':' sync the cache back to the producer buf.','line_number':2988,'multiline':False]
['text':'
 * WHAT COMPUTE_AT DOES
 * ====================
 *
 * Suppose we have two loops:
 *
 * for i in 0..100:
 *   for j in 0..200:
 *     A[i,j] = sin(i*j)
 * for i in 0..100:
 *   for j in 0..199:
 *     B[i,j] = A[i,j] + A[i, j+1]
 *
 * If we compute these loops as is, we would have to allocate two buffers:
 * 100x200 for A and 100x199 for B. To decrease the memory usage one can use
 * compute_inline primitive, which would result in the following:
 *
 * for i in 0..100:
 *   for j in 0..199:
 *     B[i,j] = sin(i*j) + sin(i*(j+1))
 *
 * We now need only one buffer - 100x199 for B. However, we're now doing some
 * redundant computations: we're calling `sin` twice as much as in the first
 * version.
 *
 * Ultimately, we nede to choose at what point we prefer to compute values of
 * A[i,j] - we can do it in the very beginning for the entire buffer A (the
 * first option) or compute it on the fly when we compute B (the second option).
 * There are also options in between those two: we can compute a part of B which
 * is required for a computation of part of B, e.g. for a single row of B. The
 * code would then look like:
 *
 * for i in 0..100:
 *   for j in 0..200:
 *     A[j] = sin(i*j)
 *   for j in 0..199:
 *     B[i,j] = A[j] + A[j+1]
 *
 * In this case we're only using 1x200 for A, and we're avoiding redundant
 * computations.
 *
 * The purpose of `compute_at` is to achieve exactly this transformation.
 *
 * compute_at requires to specify What to compute and Where to compute: in our
 * example we would call compute_at(What=`A[i,j] = sin(i*j)`, Where=`for i in
 * 0..100`).
 *
 * More info about compute_at could be found in Halide's tutorials:
 * https://halide-lang.org/tutorials/tutorial_lesson_08_scheduling_2.html
 *
 * HOW COMPUTE_AT WORKS
 * ====================
 *
 * The most important part of compute_at is bounds inference: we need to figure
 * out what part of the used tensors we need to compute when we move the
 * computation to a new scope. In the example above, we need bounds inference to
 * tell us that in order to compute A at each iteration of the outer loop, we
 * need to compute A within indices [i:i+1,0:200].
 *
 * This info allows us to conclude that we need a temp buffer of size 1x200.
 *
 * Once this is known we need to insert statements for allocation and freeing
 * the temporary buffer and copy the original computation to fill the temp
 * buffer with proper values. When we copy the computation we also must rewrite
 * indices used in it: old indices are referring to the old loop and are not
 * valid in the new loop.
 *
 * To easier follow the logic, let's examine an example. Suppose we start from
 * the following loop nest:
 *   for py in 0..100:
 *     for px in 0..100:
 *       producer[py,px] = py*px
 *   for cy in 0..100:
 *     for cx in 0..100:
 *       consumer[cy,cx] = producer[cy,cx]
 *
 * And then we're running `compute_at(producer, cy)`.
 *
 * What we would like to get is the following loop nest:
 *   for py in 0..100:
 *     for px in 0..100:
 *       producer[py,px] = py*px
 *   for cy in 0..100:
 *     Allocate(temp, {1, 100})
 *     for ty in 0..1:
 *       for tx in 0..100:
 *         temp[ty,tx] = (ty+cy)*(tx+0)
 *     for cx in 0..100:
 *       consumer[cy,cx] = temp[0,cx]
 *     Free(temp)
 *
 * NB: this loop nest can and should be simplified (e.g. the producer loop can
 * be removed since its result is no longer used), but this clean-up
 * optimization is performed separately (currently, not performed at all).
 *
 * If we examine the final loop nest, we can identify that the following steps
 * needs to be performed:
 *   - Bounds inference needs to tell us that we need a 1x100 buffer for temp.
 *   - Allocate and Free statements for this buffer need to be inserted to the
 *   loop.
 *   - A new loop-nest should be inserted to the loop CY for computing `temp`
 *   and it should replicate the loopnest of producer (PY,PX loops). The indices
 *   in the loop body need to be offset by (cy, 0) - the offsets come from
 *   bounds inference too.
 *   - The computation of `consumer` needs to be rewritten so that it uses
 *   `temp` instead of `producer`. The indices in the corresponding accesses
 *   also need to be offset.
 ','line_number':3007,'multiline':True]
['text':' Infer bounds info for all accesses that we make in the loop','line_number':3121,'multiline':False]
['text':' bounds_it holds bounds info for the store we're trying to move to','line_number':3124,'multiline':False]
['text':' the loop. If its result isn't accessed in the loop at all - do nothing and','line_number':3125,'multiline':False]
['text':' exit early.','line_number':3126,'multiline':False]
['text':' Compute dimensions of the temp buffer we would need to allocate','line_number':3132,'multiline':False]
['text':' TODO: Use name-hint of the producer instead of "temp"','line_number':3135,'multiline':False]
['text':' Generate index variables for 'temp'','line_number':3138,'multiline':False]
['text':' TODO: Use name-hint of the producer indices instead of 'idx'','line_number':3141,'multiline':False]
['text':' Prepare substitute rules for constructing the temp statement from the prod','line_number':3146,'multiline':False]
['text':' statement','line_number':3147,'multiline':False]
['text':' TODO: Instead of going up the loop nest we should go through the indices in','line_number':3148,'multiline':False]
['text':' the original tensor expression. The loops in the nest might've been','line_number':3149,'multiline':False]
['text':' modified (e.g. split or merged) so that the loop indices no longer','line_number':3150,'multiline':False]
['text':' correspond to the indices of the original expression and even their number','line_number':3151,'multiline':False]
['text':' might be different. In that case, the loop below would crash.','line_number':3152,'multiline':False]
['text':' Construct the temp statement','line_number':3172,'multiline':False]
['text':' Construct the loop nest for the temp computation','line_number':3178,'multiline':False]
['text':' We're creating loops from innermost to outermost, so we need to access','line_number':3180,'multiline':False]
['text':' dimensions in reversed order.','line_number':3181,'multiline':False]
['text':' Add constructed stmts to the consumer loop','line_number':3190,'multiline':False]
['text':' Rewrite accesses to producer in consumer with accesses to temp','line_number':3193,'multiline':False]
['text':' Not a reduction store','line_number':3299,'multiline':False]
['text':' Not enough reduction axis to do rfactor','line_number':3311,'multiline':False]
['text':' Verify that outer_reduction_for is a perfect loop nest with all loops being','line_number':3315,'multiline':False]
['text':' reductions','line_number':3316,'multiline':False]
['text':' output axis inside outer_reduction_for are not allowed','line_number':3320,'multiline':False]
['text':' The reduction store is not a single stmt in the innermost loop - bail in','line_number':3332,'multiline':False]
['text':' that case','line_number':3333,'multiline':False]
['text':' This is not the outermost reduction axis','line_number':3337,'multiline':False]
['text':' assert: reduce_axis match loop vars from outer_reduction_for and inside','line_number':3341,'multiline':False]
['text':' assert: no other stmts in outer_reduction_for or its child loops','line_number':3342,'multiline':False]
['text':' Rewrite the original reduction store to use the temporary rfac buffer:','line_number':3358,'multiline':False]
['text':'   1) X[*indexes] --> T[*indexes + {reduction_var}]','line_number':3359,'multiline':False]
['text':'   2) reduce_axis -= {reduction_var}','line_number':3360,'multiline':False]
['text':' Insert a store for the final reduction over the temp buffer into the','line_number':3366,'multiline':False]
['text':' original buffer:','line_number':3367,'multiline':False]
['text':'   X[*indexes] = ReduceOp(X[*indexes] + T[*indexes + {reduction_var}],','line_number':3368,'multiline':False]
['text':'                          reduce_axis={reduction_var})','line_number':3369,'multiline':False]
['text':' Insert an initialization store for the temp buffer:','line_number':3388,'multiline':False]
['text':'   T[a,b,c] = init','line_number':3389,'multiline':False]
['text':' namespace torch::jit::tensorexpr','line_number':3396,'multiline':False]
