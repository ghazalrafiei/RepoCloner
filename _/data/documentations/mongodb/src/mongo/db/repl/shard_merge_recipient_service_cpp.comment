['text':'*
 *    Copyright (C) 2023-present MongoDB, Inc.
 *
 *    This program is free software: you can redistribute it and/or modify
 *    it under the terms of the Server Side Public License, version 1,
 *    as published by MongoDB, Inc.
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    Server Side Public License for more details.
 *
 *    You should have received a copy of the Server Side Public License
 *    along with this program. If not, see
 *    <http://www.mongodb.com/licensing/server-side-public-license>.
 *
 *    As a special exception, the copyright holders give permission to link the
 *    code of portions of this program with the OpenSSL library under certain
 *    conditions as described in each individual source file and distribute
 *    linked combinations including the program with the OpenSSL library. You
 *    must comply with the Server Side Public License in all respects for
 *    all of the code used other than as permitted herein. If you modify file(s)
 *    with this exception, you may extend this exception to your version of the
 *    file(s), but you are not obligated to do so. If you do not wish to do so,
 *    delete this exception statement from your version. If you delete this
 *    exception statement from all source files in the program, then also delete
 *    it in the license file.
 ','line_number':1,'multiline':True]['text':' IWYU pragma: keep','line_number':60,'multiline':False]['text':' Add kTenantMigrationOplogView, kSessionTransactionsTableNamespace, and kRsOplogNamespace','line_number':180,'multiline':False]['text':' to resolvedNamespaces since they are all used during different pipeline stages.','line_number':181,'multiline':False]['text':' explain ','line_number':192,'multiline':True]['text':' fromMongos ','line_number':193,'multiline':True]['text':' needsMerge ','line_number':194,'multiline':True]['text':' allowDiskUse ','line_number':195,'multiline':True]['text':' bypassDocumentValidation ','line_number':196,'multiline':True]['text':' isMapReduceCommand ','line_number':197,'multiline':True]['text':' runtimeConstants ','line_number':199,'multiline':True]['text':' collator ','line_number':200,'multiline':True]['text':' collUUID ','line_number':203,'multiline':True]['text':' We allow retrying on the following oplog fetcher errors:','line_number':206,'multiline':False]['text':' 1) InvalidSyncSource - we cannot sync from the chosen sync source, potentially because the sync','line_number':207,'multiline':False]['text':'    source is too stale or there was a network error when connecting to the sync source.','line_number':208,'multiline':False]['text':' 2) ShudownInProgress - the current sync source is shutting down','line_number':209,'multiline':False]['text':' We never restart just the oplog fetcher.  If a failure occurs, we restart the whole state machine','line_number':215,'multiline':False]['text':' and recover from there.  So the restart decision is always "no".','line_number':216,'multiline':False]['text':' The oplog fetcher requires some of the methods in DataReplicatorExternalState to operate.','line_number':227,'multiline':False]['text':' The oplog fetcher is passed its executor directly and does not use the one from the','line_number':230,'multiline':False]['text':' DataReplicatorExternalState.','line_number':231,'multiline':False]['text':' The oplog fetcher uses the current term and opTime to inform the sync source of term changes.','line_number':239,'multiline':False]['text':' As the term on the donor and the term on the recipient have nothing to do with each other,','line_number':240,'multiline':False]['text':' we do not want to do that.','line_number':241,'multiline':False]['text':' Tenant migration does not require the metadata from the oplog query.','line_number':246,'multiline':False]['text':' Tenant migration does not change sync source depending on metadata.','line_number':250,'multiline':False]['text':' Tenant migration does not re-evaluate sync source on error.','line_number':259,'multiline':False]['text':' The oplog fetcher should never call the rest of the methods.','line_number':265,'multiline':False]['text':'
 * Acceptable classes for the 'Target' are AbstractAsyncComponent and RandomAccessOplogBuffer.
 ','line_number':301,'multiline':True]['text':' Don't allow reading before the opTime timestamp of the final write on the recipient','line_number':352,'multiline':False]['text':' associated with cloning the donor's data so the client can't see an inconsistent state. The','line_number':353,'multiline':False]['text':' oplog applier timestamp may be null if no oplog entries were copied, but data may still have','line_number':354,'multiline':False]['text':' been cloned, so use the last applied opTime in that case.','line_number':355,'multiline':False]['text':'','line_number':356,'multiline':False]['text':' Note the cloning writes happen on a separate thread, but the last applied opTime in the','line_number':357,'multiline':False]['text':' replication coordinator is guaranteed to be inclusive of those writes because this function','line_number':358,'multiline':False]['text':' is called after waiting for the _dataConsistentPromise to resolve, which happens after the','line_number':359,'multiline':False]['text':' last write for cloning completes (and all of its WUOW onCommit() handlers).','line_number':360,'multiline':False]['text':' Also don't allow reading before the returnAfterReachingTimestamp (aka the blockTimestamp) to','line_number':365,'multiline':False]['text':' prevent readers from possibly seeing data in a point in time snapshot on the recipient that','line_number':366,'multiline':False]['text':' would not have been seen at the same point in time on the donor if the donor's cluster time','line_number':367,'multiline':False]['text':' is ahead of the recipient's.','line_number':368,'multiline':False]['text':'*
 * Converts migration errors, such as, network errors and cancellation errors to interrupt
 * error status.
 *
 * On migration interrupt, async components will fail with generic network/cancellation
 * errors rather than interrupt error status. When sending the migration command response to
 * donor, we should convert those into real errors so that donor can decide if they need to
 * retry migration commands.
 ','line_number':373,'multiline':True]['text':' Network and cancellation errors can be caused due to migration interrupt so replace those','line_number':389,'multiline':False]['text':' error status with interrupt error status, if set.','line_number':390,'multiline':False]['text':' All of our async components don't exit with CallbackCanceled normally unless','line_number':397,'multiline':False]['text':' they are shut down by the instance itself via interrupt. If we get a','line_number':398,'multiline':False]['text':' CallbackCanceled error without an interrupt, it is coming from the service's','line_number':399,'multiline':False]['text':' cancellation token or scoped task executor shutdown on failovers. It is possible','line_number':400,'multiline':False]['text':' for the token to get canceled or scope task executor to shutdown','line_number':401,'multiline':False]['text':' before the instance is interrupted. So we replace the CallbackCanceled error','line_number':402,'multiline':False]['text':' with InterruptedDueToReplStateChange and treat it as a retryable error.','line_number':403,'multiline':False]['text':' namespace','line_number':419,'multiline':False]['text':' We don't start migration if `startGarbageCollect` is true. So, it's safe to not','line_number':480,'multiline':False]['text':' check the conflicts with other instances.','line_number':481,'multiline':False]['text':'','line_number':482,'multiline':False]['text':' We need this to avoid races, like, delayed 'recipientForgetMigration'with migration decision','line_number':483,'multiline':False]['text':' 'committed' received after the corresponding migration state doc was deleted and another','line_number':484,'multiline':False]['text':' conflicting migration was started.','line_number':485,'multiline':False]['text':' This gives assurance that _tenantOplogApplier pointer won't be empty, and that it has been','line_number':609,'multiline':False]['text':' started. Additionally, we must have finished processing the recipientSyncData command that','line_number':610,'multiline':False]['text':' waits on _dataConsistentPromise.','line_number':611,'multiline':False]['text':' We start tenant oplog applier after recipient informs donor,','line_number':616,'multiline':False]['text':' the data is in consistent state. So, there is a possibility, recipient might receive','line_number':617,'multiline':False]['text':' recipientSyncData cmd with `returnAfterReachingDonorTimestamp` from donor before the','line_number':618,'multiline':False]['text':' recipient has started the tenant oplog applier.','line_number':619,'multiline':False]['text':' When the data sync is done, we reset _tenantOplogApplier, so just throw the data sync','line_number':624,'multiline':False]['text':' completion future result.','line_number':625,'multiline':False]['text':' Sanity checks.','line_number':630,'multiline':False]['text':' A cancellation error may occur due to an interrupt. If that is the case, replace the error','line_number':654,'multiline':False]['text':' code with the interrupt code, the true reason for interruption.','line_number':655,'multiline':False]['text':' Make sure that the recipient logical clock has advanced to at least the donor timestamp','line_number':662,'multiline':False]['text':' before returning success for recipientSyncData.','line_number':663,'multiline':False]['text':' Note: tickClusterTimeTo() will not tick the recipient clock backwards in time.','line_number':664,'multiline':False]['text':' updateStateDoc was a no-op, but we still must ensure it's all-replicated.','line_number':679,'multiline':False]['text':' ConnectionString::connect() always returns a DBClientConnection in a unique_ptr of','line_number':711,'multiline':False]['text':' DBClientBase type.','line_number':712,'multiline':False]['text':' Authenticate connection to the donor.','line_number':715,'multiline':False]['text':' Only ever used to cancel when the setTenantMigrationRecipientInstanceHostTimeout failpoint is','line_number':752,'multiline':False]['text':' set.','line_number':753,'multiline':False]['text':' Cancel the find host request after a timeout. Ignore callback handle.','line_number':759,'multiline':False]['text':' Get all donor hosts that we have excluded.','line_number':776,'multiline':False]['text':' If the future chain has been interrupted, stop retrying.','line_number':852,'multiline':False]['text':'
             * Retry sync source selection if we encountered any of the following errors:
             * 1) The RSM couldn't find a suitable donor host
             * 2) The majority snapshot OpTime on the donor host was not ahead of our stored
             * 'startApplyingDonorOpTime'
             * 3) Some other retriable error
             ','line_number':864,'multiline':True]['text':' Clean up any hosts that have had their exclusion duration expired.','line_number':898,'multiline':False]['text':' Return the list of currently excluded donor hosts.','line_number':905,'multiline':False]['text':' Record the opTime at which the state doc is initialized.','line_number':970,'multiline':False]['text':' Cancel the backup cursor keep alive task.','line_number':997,'multiline':False]['text':' Ignore the result Future','line_number':1022,'multiline':False]['text':' We must set a writeConcern on internal commands.','line_number':1032,'multiline':False]['text':' First batch must contain the metadata.','line_number':1067,'multiline':False]['text':' This ensures that the recipient wonâ€™t receive any 2 phase index build donor','line_number':1085,'multiline':False]['text':' oplog entries during the migration. We also have a check in the tenant oplog','line_number':1086,'multiline':False]['text':' applier to detect such oplog entries. Adding a check here helps us to detect','line_number':1087,'multiline':False]['text':' the problem earlier.','line_number':1088,'multiline':False]['text':' Disabling internal document validation because the fetcher batch size','line_number':1109,'multiline':False]['text':' can exceed the max data size limit BSONObjMaxUserSize with the','line_number':1110,'multiline':False]['text':' additional fields we add to documents.','line_number':1111,'multiline':False]['text':' Writes are ordered, check only the last writeOp result.','line_number':1126,'multiline':False]['text':' Exit fetcher but keep the backupCursor alive to prevent WT on Donor from','line_number':1133,'multiline':False]['text':' modifying file bytes. backupCursor can be closed after all Recipient nodes','line_number':1134,'multiline':False]['text':' have copied files from Donor primary.','line_number':1135,'multiline':False]['text':' aggregateTimeout ','line_number':1158,'multiline':True]['text':' getMoreNetworkTimeout ','line_number':1159,'multiline':True]['text':' the callback was never invoked','line_number':1169,'multiline':False]['text':' Fetcher closes backup cursor on post-opening errors, eliminating the need','line_number':1182,'multiline':False]['text':' for explicit 'killCursors' with 'kBackupCursorTooStaleErrorCode' prior to retries.','line_number':1183,'multiline':False]['text':' Generally, snapshot reads on config.transactions table have some risks.','line_number':1262,'multiline':False]['text':' But for this case, it is safe because we query only for multi-statement transaction entries','line_number':1263,'multiline':False]['text':' (and "state" field is set only for multi-statement transaction transactions) and writes to','line_number':1264,'multiline':False]['text':' config.transactions collection aren't coalesced for multi-statement transactions during','line_number':1265,'multiline':False]['text':' secondary oplog application, unlike the retryable writes where updates to config.transactions','line_number':1266,'multiline':False]['text':' collection are coalesced on secondaries.','line_number':1267,'multiline':False]['text':' Unlock the mutex before doing network reads','line_number':1300,'multiline':False]['text':' If the tenantMigrationInfo is set on the opCtx, we will set the','line_number':1335,'multiline':False]['text':' 'fromTenantMigration' field when writing oplog entries. That field is used to help recipient','line_number':1336,'multiline':False]['text':' secondaries determine if a no-op entry is related to a transaction entry.','line_number':1337,'multiline':False]['text':' The in-memory transaction state may have been updated past the on-disk transaction state. For','line_number':1363,'multiline':False]['text':' instance, this might happen in an unprepared read-only transaction, which updates in-memory','line_number':1364,'multiline':False]['text':' but not on-disk. To prevent potential errors, we use the on-disk state for the following','line_number':1365,'multiline':False]['text':' transaction number checks.','line_number':1366,'multiline':False]['text':' If the entry's transaction number is stale/older than the current active transaction number','line_number':1370,'multiline':False]['text':' on the participant, fail the migration.','line_number':1371,'multiline':False]['text':' If the txn numbers are equal, move on to the next entry.','line_number':1381,'multiline':False]['text':' Shard merge copies all tenants from the donor. This means that merge does','line_number':1391,'multiline':False]['text':' not need to filter prefetched committed transactions by tenantId. As a result, setting','line_number':1392,'multiline':False]['text':' a nss containing the tenantId for the no-op entry isn't necessary.','line_number':1393,'multiline':False]['text':' Use the same wallclock time as the noop entry.','line_number':1403,'multiline':False]['text':' Write the no-op entry and update 'config.transactions'.','line_number':1411,'multiline':False]['text':' Invalidate in-memory state so that the next time the session is checked out, it would reload','line_number':1420,'multiline':False]['text':' the transaction state from 'config.transactions'.','line_number':1421,'multiline':False]['text':' Simulate the sync source shutting down/restarting.','line_number':1428,'multiline':False]['text':' Test-only.','line_number':1442,'multiline':False]['text':' Test-only.','line_number':1514,'multiline':False]['text':' If the oplog buffer contains entries at this point, it indicates that the recipient went','line_number':1532,'multiline':False]['text':' through failover before it finished writing all oplog entries to the buffer. Clear it and','line_number':1533,'multiline':False]['text':' redo the work.','line_number':1534,'multiline':False]['text':' Ensure we are primary when trying to clear the oplog buffer since it will drop and','line_number':1537,'multiline':False]['text':' re-create the collection.','line_number':1538,'multiline':False]['text':' Fetch the oplog chains of all retryable writes that occurred before startFetchingTimestamp.','line_number':1562,'multiline':False]['text':' Use local read concern. This is because secondary oplog application coalesces multiple','line_number':1573,'multiline':False]['text':' updates to the same config.transactions record into a single update of the most recent','line_number':1574,'multiline':False]['text':' retryable write statement, and since after SERVER-47844, the committed snapshot of a','line_number':1575,'multiline':False]['text':' secondary can be in the middle of batch, the combination of these two makes secondary','line_number':1576,'multiline':False]['text':' majority reads on config.transactions not always reflect committed retryable writes at','line_number':1577,'multiline':False]['text':' that majority commit point. So we need to do a local read to fetch the retryable writes','line_number':1578,'multiline':False]['text':' so that we don't miss the config.transactions record and later do a majority read on the','line_number':1579,'multiline':False]['text':' donor's last applied operationTime to make sure the fetched results are majority committed.','line_number':1580,'multiline':False]['text':' We must set a writeConcern on internal commands.','line_number':1584,'multiline':False]['text':' Allow aggregation to write to temporary files in case it reaches memory restriction.','line_number':1586,'multiline':False]['text':' Failpoint to set a small batch size on the aggregation request.','line_number':1589,'multiline':False]['text':' secondaryOk ','line_number':1598,'multiline':True]['text':' useExhaust ','line_number':1598,'multiline':True]['text':' cursor->more() will automatically request more from the server if necessary.','line_number':1601,'multiline':False]['text':' Similar to the OplogFetcher, we keep track of each oplog entry to apply and the number of','line_number':1603,'multiline':False]['text':' the bytes of the documents read off the network.','line_number':1604,'multiline':False]['text':' Gather entries from current batch.','line_number':1610,'multiline':False]['text':' Wait for enough space.','line_number':1617,'multiline':False]['text':' Buffer retryable writes entries.','line_number':1619,'multiline':False]['text':' In between batches, check for recipient failover.','line_number':1626,'multiline':False]['text':' Do a majority read on the sync source to make sure the pre-fetch result exists on a','line_number':1630,'multiline':False]['text':' majority of nodes in the set. The timestamp we wait on is the donor's last applied','line_number':1631,'multiline':False]['text':' operationTime, which is guaranteed to be at batch boundary if the sync source is a','line_number':1632,'multiline':False]['text':' secondary. We do not check the rollbackId - rollback would lead to the sync source','line_number':1633,'multiline':False]['text':' closing connections so the migration would fail and retry.','line_number':1634,'multiline':False]['text':' Update _stateDoc to indicate that we've finished the retryable writes oplog entry fetching','line_number':1653,'multiline':False]['text':' stage.','line_number':1654,'multiline':False]['text':' It is illegal to start the replicated donor buffer when the node is not primary.','line_number':1661,'multiline':False]['text':' So ensure we are primary before trying to startup the oplog buffer.','line_number':1662,'multiline':False]['text':' Start the oplog buffer outside the mutex to avoid deadlock on a concurrent stepdown.','line_number':1683,'multiline':False]['text':' The config is only used for setting the awaitData timeout; the defaults are fine.','line_number':1711,'multiline':False]['text':' We do not need to check the rollback ID.','line_number':1715,'multiline':False]['text':' forTenantMigration ','line_number':1719,'multiline':True]['text':' Starting oplog fetcher after migration interrupt would cause the fetcher to fail','line_number':1728,'multiline':False]['text':' due to closed _oplogFetcherClient connection.','line_number':1729,'multiline':False]['text':' Wait for enough space.','line_number':1755,'multiline':False]['text':' Buffer docs for later application.','line_number':1757,'multiline':False]['text':' The oplog fetcher is normally canceled when migration is done; any other error','line_number':1765,'multiline':False]['text':' indicates failure.','line_number':1766,'multiline':False]['text':' Oplog fetcher status of "OK" means the stopReplProducer failpoint is set.  Migration','line_number':1768,'multiline':False]['text':' cannot continue in this state so force a failure.','line_number':1769,'multiline':False]['text':' fp is locked. If we call pauseWhileSet here, another thread can't disable fp.','line_number':1813,'multiline':False]['text':' Advance the cluster time to the donorBkpCursorCkptTs so that we ensure we','line_number':1860,'multiline':False]['text':' write the no-op entry below at ts > donorBkpCursorCkptTs.','line_number':1861,'multiline':False]['text':' Get the timestamp of the no-op. This will have ts > donorBkpCursorCkptTs.','line_number':1877,'multiline':False]['text':' Mark the migration has reached consistent state.','line_number':1889,'multiline':False]['text':' Nothing to do if the state doc already has the expireAt set.','line_number':1958,'multiline':False]['text':' Closing this connection will be cause tenant oplog fetcher to fail.','line_number':1983,'multiline':False]['text':' Save them to join() with it outside of _mutex.','line_number':2043,'multiline':False]['text':' Perform join outside the lock to avoid deadlocks.','line_number':2056,'multiline':False]['text':'fromMigrate=','line_number':2105,'multiline':True]['text':' Intentionally not checking `updateResult.numDocsModified` to handle no-op','line_number':2107,'multiline':False]['text':' updates.','line_number':2108,'multiline':False]['text':'(Generic FCV reference): This FCV check should exist across LTS binary versions.','line_number':2121,'multiline':False]['text':' Test-only.','line_number':2130,'multiline':False]['text':' Don't start the tenant oplog applier if the migration is interrupted.','line_number':2163,'multiline':False]['text':' Do not set the internal states if the migration is already interrupted.','line_number':2200,'multiline':False]['text':' expireAt ','line_number':2222,'multiline':True]['text':' During failovers, the scoped task executor may shut down before the callback to cancel the','line_number':2256,'multiline':False]['text':' sleep timeout source is executed. However, the scoped task executor shutdown will also','line_number':2257,'multiline':False]['text':' cancel all pending tasks, including this sleep task. So, no concern about orphaned','line_number':2258,'multiline':False]['text':' pending tasks after migration task completion.','line_number':2259,'multiline':False]['text':' Cancel the sleep task.','line_number':2280,'multiline':False]['text':' wait for oplog applier to complete/stop.','line_number':2321,'multiline':False]['text':' The oplog applier does not exit normally; it must be shut down externally,','line_number':2322,'multiline':False]['text':' e.g. by recipientForgetMigration.','line_number':2323,'multiline':False]['text':' The donated files and oplog buffer collections can be safely dropped at this','line_number':2333,'multiline':False]['text':' point. In case either collection does not exist, dropping will be a no-op.','line_number':2334,'multiline':False]['text':' It isn't necessary that a given drop is majority-committed. A new primary will','line_number':2335,'multiline':False]['text':' attempt to drop the collection anyway.','line_number':2336,'multiline':False]['text':' It's possible to get here only for following cases.','line_number':2399,'multiline':False]['text':' 1) The migration was forgotten before receiving a 'recipientSyncData'.','line_number':2400,'multiline':False]['text':' 2) A delayed 'recipientForgetMigration' was received after the state doc was','line_number':2401,'multiline':False]['text':' deleted.','line_number':2402,'multiline':False]['text':' 3) Fail to initialize the state document.','line_number':2403,'multiline':False]['text':' indexesAffected ','line_number':2430,'multiline':True]['text':' OpDebug* ','line_number':2431,'multiline':True]['text':' Note marking the keys as garbage collectable is not atomic with marking the','line_number':2479,'multiline':False]['text':' state document garbage collectable, so an interleaved failover can lead the','line_number':2480,'multiline':False]['text':' keys to be deleted before the state document has an expiration date. This is','line_number':2481,'multiline':False]['text':' acceptable because the decision to forget a migration is not reversible.','line_number':2482,'multiline':False]['text':' Note: The tenant oplog applier does not normally stop by itself on success. It','line_number':2527,'multiline':False]['text':' completes only on errors or on external interruption (e.g. by shutDown/stepDown or by','line_number':2528,'multiline':False]['text':' recipientForgetMigration command). So, errored completion status doesn't always mean','line_number':2529,'multiline':False]['text':' migration wasn't success.','line_number':2530,'multiline':False]['text':' we won't don't want the errors','line_number':2559,'multiline':False]['text':' happened in the garbage collection stage to be replaced with interrupt errors due to','line_number':2560,'multiline':False]['text':' on receive of 'recipientForgetMigration' command but still want to replace with','line_number':2561,'multiline':False]['text':' failover/shutdown interrupt errors.','line_number':2562,'multiline':False]['text':' We should only hit here on a stepdown or shutdown errors.','line_number':2572,'multiline':False]['text':' namespace repl','line_number':2633,'multiline':False]['text':' namespace mongo','line_number':2634,'multiline':False]