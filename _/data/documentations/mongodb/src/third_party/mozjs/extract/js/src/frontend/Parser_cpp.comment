['text':' -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. ','line_number':1,'multiline':True]['text':'
 * JS parser.
 *
 * This is a recursive-descent parser for the JavaScript language specified by
 * "The ECMAScript Language Specification" (Standard ECMA-262).  It uses
 * lexical and semantic feedback to disambiguate non-LL(1) structures.  It
 * generates trees of nodes induced by the recursive parsing (not precise
 * syntax trees, see Parser.h).  After tree construction, it rewrites trees to
 * fold constants and evaluate compile-time expressions.
 *
 * This parser attempts no error recovery.
 ','line_number':7,'multiline':True]['text':' FunctionSyntaxKind','line_number':42,'multiline':False]['text':' ScriptIndex','line_number':46,'multiline':False]['text':' js::GetErrorMessage, JSMSG_*','line_number':49,'multiline':False]['text':' JS::RegExpFlags','line_number':50,'multiline':False]['text':' StringBuffer','line_number':51,'multiline':False]['text':' js::FunctionFlags','line_number':54,'multiline':False]['text':' js::GeneratorKind, js::FunctionAsyncKind','line_number':55,'multiline':False]['text':' js::ModuleBuilder','line_number':60,'multiline':False]['text':' GetScopeDataTrailingNames','line_number':62,'multiline':False]['text':' js_*_str','line_number':65,'multiline':False]['text':' This source extent will be further filled in during the remainder of parse.','line_number':276,'multiline':False]['text':'
   * We use JSContext.tempLifoAlloc to allocate parsed objects and place them
   * on a list in this Parser to ensure GC safety. Thus the tempLifoAlloc
   * arenas containing the entries must be alive until we are done with
   * scanning, parsing and code generation for the whole script or top-level
   * function.
   ','line_number':280,'multiline':True]['text':' If support for source pragmas have been fully disabled, we can skip','line_number':301,'multiline':False]['text':' processing of all of these values.','line_number':302,'multiline':False]['text':' Not all clients initialize ss. Can't update info to an object that isn't','line_number':307,'multiline':False]['text':' there.','line_number':308,'multiline':False]['text':'
   * Source map URLs passed as a compile option (usually via a HTTP source map
   * header) override any source map urls passed as comment pragmas.
   ','line_number':326,'multiline':True]['text':' Warn about the replacement, but use the new one.','line_number':331,'multiline':False]['text':'
 * Parse a top-level JS script.
 ','line_number':347,'multiline':True]['text':' len = ','line_number':355,'multiline':True]['text':' newDirectives = ','line_number':359,'multiline':True]['text':' Don't constant-fold inside "use asm" code, as this could create a parse','line_number':389,'multiline':False]['text':' tree that doesn't type-check as asm.js.','line_number':390,'multiline':False]['text':'
 * Strict mode forbids introducing new definitions for 'eval', 'arguments',
 * 'let', 'static', 'yield', or for any strict mode reserved word.
 ','line_number':402,'multiline':True]['text':'
 * Returns true if all parameter names are valid strict mode binding names and
 * no duplicate parameter names are present.
 ','line_number':416,'multiline':True]['text':' notePositionalFormalParameter is called for both the arguments of a regular','line_number':504,'multiline':False]['text':' function definition and the arguments specified by the Function','line_number':505,'multiline':False]['text':' constructor.','line_number':506,'multiline':False]['text':'','line_number':507,'multiline':False]['text':' The 'disallowDuplicateParams' bool indicates whether the use of another','line_number':508,'multiline':False]['text':' feature (destructuring or default arguments) disables duplicate arguments.','line_number':509,'multiline':False]['text':' (ECMA-262 requires us to support duplicate parameter names, but, for newer','line_number':510,'multiline':False]['text':' features, we consider the code to have "opted in" to higher standards and','line_number':511,'multiline':False]['text':' forbid duplicates.)','line_number':512,'multiline':False]['text':' Strict-mode disallows duplicate args. We may not know whether we are','line_number':524,'multiline':False]['text':' in strict mode or not (since the function body hasn't been parsed).','line_number':525,'multiline':False]['text':' In such cases, report will queue up the potential error and return','line_number':526,'multiline':False]['text':' 'true'.','line_number':527,'multiline':False]['text':' Append an empty name to the positional formals vector to keep track of','line_number':564,'multiline':False]['text':' argument slots when making FunctionScope::ParserData.','line_number':565,'multiline':False]['text':' The asm.js validator does all its own symbol-table management so, as an','line_number':580,'multiline':False]['text':' optimization, avoid doing any work here.','line_number':581,'multiline':False]['text':' Body-level functions in modules are always closed over.','line_number':618,'multiline':False]['text':' It is an early error if any non-positional formal parameter name','line_number':625,'multiline':False]['text':' (e.g., destructuring formal parameter) is duplicated.','line_number':626,'multiline':False]['text':' Functions in block have complex allowances in sloppy mode for being','line_number':663,'multiline':False]['text':' labelled that other lexical declarations do not have. Those checks','line_number':664,'multiline':False]['text':' are more complex than calling checkLexicalDeclarationDirectlyWithin-','line_number':665,'multiline':False]['text':' Block and are done in checkFunctionDefinition.','line_number':666,'multiline':False]['text':' It is usually an early error if there is another declaration','line_number':670,'multiline':False]['text':' with the same name in the same scope.','line_number':671,'multiline':False]['text':'','line_number':672,'multiline':False]['text':' Sloppy lexical functions may redeclare other sloppy lexical','line_number':673,'multiline':False]['text':' functions for web compatibility reasons.','line_number':674,'multiline':False]['text':' The BoundNames of LexicalDeclaration and ForDeclaration must not','line_number':692,'multiline':False]['text':' contain 'let'. (CatchParameter is the only lexical binding form','line_number':693,'multiline':False]['text':' without this restriction.)','line_number':694,'multiline':False]['text':' For body-level lexically declared names in a function, it is an','line_number':700,'multiline':False]['text':' early error if there is a formal parameter of the same name. This','line_number':701,'multiline':False]['text':' needs a special check if there is an extra var scope due to','line_number':702,'multiline':False]['text':' parameter expressions.','line_number':703,'multiline':False]['text':' Module code is always strict, so 'let' is always a keyword and never a','line_number':715,'multiline':False]['text':' name.','line_number':716,'multiline':False]['text':' It is an early error if there is another declaration with the same','line_number':724,'multiline':False]['text':' name in the same scope.','line_number':725,'multiline':False]['text':' CoverArrowParameter is only used as a placeholder declaration kind.','line_number':741,'multiline':False]['text':' Optimized private method. Non-optimized paths still get','line_number':779,'multiline':False]['text':' DeclarationKind::Synthetic.','line_number':780,'multiline':False]['text':' Methods must be marked closed-over so that','line_number':784,'multiline':False]['text':' EmitterScope::lookupPrivate() works even if the method is used, but not','line_number':785,'multiline':False]['text':' within any method (from a computed property name, or debugger frame)','line_number':786,'multiline':False]['text':' Private methods demands that','line_number':806,'multiline':False]['text':'','line_number':807,'multiline':False]['text':' class A {','line_number':808,'multiline':False]['text':'   static set #x(_) {}','line_number':809,'multiline':False]['text':'   get #x() { }','line_number':810,'multiline':False]['text':' }','line_number':811,'multiline':False]['text':'','line_number':812,'multiline':False]['text':' Report a SyntaxError.','line_number':813,'multiline':False]['text':' The asm.js validator does all its own symbol-table management so, as an','line_number':840,'multiline':False]['text':' optimization, avoid doing any work here.','line_number':841,'multiline':False]['text':' Global bindings are properties and not actual bindings; we don't need','line_number':846,'multiline':False]['text':' to know if they are closed over. So no need to track used name at the','line_number':847,'multiline':False]['text':' global scope. It is not incorrect to track them, this is an','line_number':848,'multiline':False]['text':' optimization.','line_number':849,'multiline':False]['text':'','line_number':850,'multiline':False]['text':' As an exception however, we continue to track private name references,','line_number':851,'multiline':False]['text':' as the used names tracker is used to provide early errors for undeclared','line_number':852,'multiline':False]['text':' private name references','line_number':853,'multiline':False]['text':' Now that we have all the declared names in the scope, check which','line_number':867,'multiline':False]['text':' functions should exhibit Annex B semantics.','line_number':868,'multiline':False]['text':' Scopes are nullptr-delimited in the BaseScript closed over bindings','line_number':876,'multiline':False]['text':' array.','line_number':877,'multiline':False]['text':' TODO-Stencil','line_number':880,'multiline':False]['text':'   After closed-over-bindings are snapshotted in the handler,','line_number':881,'multiline':False]['text':'   remove this.','line_number':882,'multiline':False]['text':' Append a nullptr to denote end-of-scope.','line_number':935,'multiline':False]['text':' This is designed to be paired with parsing a statement list at the top','line_number':949,'multiline':False]['text':' level.','line_number':950,'multiline':False]['text':'','line_number':951,'multiline':False]['text':' The statementList() call breaks on TokenKind::RightCurly, so make sure','line_number':952,'multiline':False]['text':' we've reached EOF here.','line_number':953,'multiline':False]['text':' namespace detail','line_number':1019,'multiline':False]['text':' Initialize the trailing name bindings of |data|, then set |data->length| to','line_number':1021,'multiline':False]['text':' the count of bindings added (which must equal |count|).','line_number':1022,'multiline':False]['text':'','line_number':1023,'multiline':False]['text':' First, |firstBindings| are added to the trailing names.  Then any','line_number':1024,'multiline':False]['text':' "steps" present are performed first to last.  Each step is 1) a pointer to a','line_number':1025,'multiline':False]['text':' member of |data| to be set to the current number of bindings added, and 2) a','line_number':1026,'multiline':False]['text':' vector of |ParserBindingName|s to then copy into |data->trailingNames|.','line_number':1027,'multiline':False]['text':' (Thus each |data| member field indicates where the corresponding vector's','line_number':1028,'multiline':False]['text':'  names start.)','line_number':1029,'multiline':False]['text':' The ordering here is important. See comments in GlobalScope.','line_number':1101,'multiline':False]['text':' Imports are indirect bindings and must not be given known slots.','line_number':1126,'multiline':False]['text':' The ordering here is important. See comments in ModuleScope.','line_number':1166,'multiline':False]['text':' Treat all bindings as closed over in non-strict eval.','line_number':1187,'multiline':False]['text':' Eval scopes only contain 'var' bindings.','line_number':1191,'multiline':False]['text':' Positional parameter names must be added in order of appearance as they are','line_number':1236,'multiline':False]['text':' referenced using argument slots.','line_number':1237,'multiline':False]['text':' Do not consider any positional formal parameters closed over if','line_number':1245,'multiline':False]['text':' there are parameter defaults. It is the binding in the defaults','line_number':1246,'multiline':False]['text':' scope that is closed over instead.','line_number':1247,'multiline':False]['text':' If the parameter name has duplicates, only the final parameter','line_number':1251,'multiline':False]['text':' name should be on the environment, as otherwise the environment','line_number':1252,'multiline':False]['text':' object would have multiple, same-named properties.','line_number':1253,'multiline':False]['text':' Positional parameter names are already handled above.','line_number':1278,'multiline':False]['text':' The only vars in the function scope when there are parameter','line_number':1286,'multiline':False]['text':' exprs, which induces a separate var environment, should be the','line_number':1287,'multiline':False]['text':' special bindings.','line_number':1288,'multiline':False]['text':' The ordering here is important. See comments in FunctionScope.','line_number':1314,'multiline':False]['text':' Compute if `NewFunctionScopeData` would return any binding list with any','line_number':1324,'multiline':False]['text':' entry marked as closed-over. This is done without the need to allocate the','line_number':1325,'multiline':False]['text':' binding list. If true, an EnvironmentObject will be needed at runtime.','line_number':1326,'multiline':False]['text':' Compute if `NewVarScopeData` would return any binding list. This is done','line_number':1397,'multiline':False]['text':' without allocate the binding list.','line_number':1398,'multiline':False]['text':' The ordering here is important. See comments in LexicalScope.','line_number':1456,'multiline':False]['text':' Compute if `NewLexicalScopeData` would return any binding list with any entry','line_number':1464,'multiline':False]['text':' marked as closed-over. This is done without the need to allocate the binding','line_number':1465,'multiline':False]['text':' list. If true, an EnvironmentObject will be needed at runtime.','line_number':1466,'multiline':False]['text':' We should have zero or one private brands.','line_number':1533,'multiline':False]['text':' To simplify initialization of the bindings, we concatenate the','line_number':1545,'multiline':False]['text':' synthetics+privateBrand vector such that the private brand is always the','line_number':1546,'multiline':False]['text':' first element, as ordering is important. See comments in ClassBodyScope.','line_number':1547,'multiline':False]['text':' The ordering here is important. See comments in ClassBodyScope.','line_number':1556,'multiline':False]['text':' `EmitterScope::lookupPrivate()` requires `.privateBrand` to be stored in a','line_number':1562,'multiline':False]['text':' predictable slot: the first slot available in the environment object,','line_number':1563,'multiline':False]['text':' `ClassBodyLexicalEnvironmentObject::privateBrandSlot()`. We assume that','line_number':1564,'multiline':False]['text':' if `.privateBrand` is first in the scope, it will be stored there.','line_number':1565,'multiline':False]['text':' We're delazifying -- so we already checked private names during first','line_number':1634,'multiline':False]['text':' parse.','line_number':1635,'multiline':False]['text':' No unbound names, let's get out of here!','line_number':1648,'multiline':False]['text':' It is an early error if there's private name references unbound,','line_number':1653,'multiline':False]['text':' unless it's an eval, in which case we need to check the scope','line_number':1654,'multiline':False]['text':' chain.','line_number':1655,'multiline':False]['text':' The unbound private names are sorted, so just grab the first one.','line_number':1657,'multiline':False]['text':' It's important that the unbound private names are sorted, as we','line_number':1668,'multiline':False]['text':' want our errors to always be issued to the first textually.','line_number':1669,'multiline':False]['text':' If the enclosingScope is non-syntactic, then we are in a','line_number':1671,'multiline':False]['text':' Debugger.Frame.prototype.eval call. In order to find the declared private','line_number':1672,'multiline':False]['text':' names, we must use the effective scope that was determined when creating','line_number':1673,'multiline':False]['text':' the scopeContext.','line_number':1674,'multiline':False]['text':' newDirectives = ','line_number':1694,'multiline':True]['text':' All evals have an implicit non-extensible lexical scope.','line_number':1706,'multiline':False]['text':' Private names not lexically defined must trigger a syntax error.','line_number':1721,'multiline':False]['text':' If superScopeNeedsHomeObject_ is set and we are an entry-point','line_number':1735,'multiline':False]['text':' ParseContext, then we must be emitting an eval script, and the','line_number':1736,'multiline':False]['text':' outer function must already be marked as needing a home object','line_number':1737,'multiline':False]['text':' since it contains an eval.','line_number':1738,'multiline':False]['text':' Don't constant-fold inside "use asm" code, as this could create a parse','line_number':1751,'multiline':False]['text':' tree that doesn't type-check as asm.js.','line_number':1752,'multiline':False]['text':' For non-strict eval scripts, since all bindings are automatically','line_number':1769,'multiline':False]['text':' considered closed over, we don't need to call propagateFreeNames-','line_number':1770,'multiline':False]['text':' AndMarkClosedOverBindings. However, Annex B.3.3 functions still need to','line_number':1771,'multiline':False]['text':' be marked.','line_number':1772,'multiline':False]['text':' newDirectives = ','line_number':1790,'multiline':True]['text':' Don't constant-fold inside "use asm" code, as this could create a parse','line_number':1818,'multiline':False]['text':' tree that doesn't type-check as asm.js.','line_number':1819,'multiline':False]['text':' For global scripts, whether bindings are closed over or not doesn't','line_number':1831,'multiline':False]['text':' matter, so no need to call propagateFreeNamesAndMarkClosedOver-','line_number':1832,'multiline':False]['text':' Bindings. However, Annex B.3.3 functions still need to be marked.','line_number':1833,'multiline':False]['text':' Set the module to async if an await keyword was found at the top level.','line_number':1903,'multiline':False]['text':' Generate the Import/Export tables and store in CompilationState.','line_number':1909,'multiline':False]['text':' Check exported local bindings exist and mark them as closed over.','line_number':1914,'multiline':False]['text':' Reserve an environment slot for a "*namespace*" psuedo-binding and mark as','line_number':1933,'multiline':False]['text':' closed-over. We do not know until module linking if this will be used.','line_number':1934,'multiline':False]['text':' Don't constant-fold inside "use asm" code, as this could create a parse','line_number':1949,'multiline':False]['text':' tree that doesn't type-check as asm.js.','line_number':1950,'multiline':False]['text':' Private names not lexically defined must trigger a syntax error.','line_number':1962,'multiline':False]['text':' Functions with parameter expressions utilize the FunctionScope for vars','line_number':2023,'multiline':False]['text':' generated by sloppy-direct-evals, as well as arguments (which are','line_number':2024,'multiline':False]['text':' lexicals bindings). If the function body has var bindings (or has a','line_number':2025,'multiline':False]['text':' sloppy-direct-eval that might), then an extra VarScope must be created','line_number':2026,'multiline':False]['text':' for them.','line_number':2027,'multiline':False]['text':' See: JSFunction::needsCallObject()','line_number':2034,'multiline':False]['text':' See: JSFunction::needsNamedLambdaEnvironment()','line_number':2045,'multiline':False]['text':' = false ','line_number':2056,'multiline':True]['text':' BCE will need to generate bytecode for this.','line_number':2065,'multiline':False]['text':' = false ','line_number':2116,'multiline':True]['text':' The BaseScript for a lazily parsed function needs to know its set of','line_number':2117,'multiline':False]['text':' free variables and inner functions so that when it is fully parsed, we','line_number':2118,'multiline':False]['text':' can skip over any already syntax parsed inner functions and still','line_number':2119,'multiline':False]['text':' retain correct scope information.','line_number':2120,'multiline':False]['text':' Elide nullptr sentinels from end of binding list. These are inserted for','line_number':2136,'multiline':False]['text':' each scope regardless of if any bindings are actually closed over.','line_number':2137,'multiline':False]['text':' Check if we will overflow the `ngcthings` field later.','line_number':2145,'multiline':False]['text':' If there are no script-things, we can return early without allocating.','line_number':2154,'multiline':False]['text':' Copy inner-function and closed-over-binding info for the stencil. The order','line_number':2166,'multiline':False]['text':' is important here. We emit functions first, followed by the bindings info.','line_number':2167,'multiline':False]['text':' The bindings list uses nullptr as delimiter to separates the bindings per','line_number':2168,'multiline':False]['text':' scope.','line_number':2169,'multiline':False]['text':'','line_number':2170,'multiline':False]['text':' See: FullParseHandler::nextLazyInnerFunction(),','line_number':2171,'multiline':False]['text':'      FullParseHandler::nextLazyClosedOverBinding()','line_number':2172,'multiline':False]['text':' Only normal function statements/expressions may force extended mode. Other','line_number':2211,'multiline':False]['text':' types of functions use extended slots for their own purposes.','line_number':2212,'multiline':False]['text':' Skip prelude.','line_number':2271,'multiline':False]['text':' Skip function name, if present.','line_number':2294,'multiline':False]['text':' toStringStart = ','line_number':2317,'multiline':True]['text':' Function is not syntactically part of another script.','line_number':2323,'multiline':False]['text':' isStandaloneFunction = ','line_number':2340,'multiline':True]['text':' Don't constant-fold inside "use asm" code, as this could create a parse','line_number':2357,'multiline':False]['text':' tree that doesn't type-check as asm.js.','line_number':2358,'multiline':False]['text':' When we transitioned from non-strict to strict mode, we need to','line_number':2397,'multiline':False]['text':' validate that all parameter names are valid strict mode names.','line_number':2398,'multiline':False]['text':' Request that this function be reparsed as strict to report','line_number':2404,'multiline':False]['text':' the invalid parameter name at the correct source location.','line_number':2405,'multiline':False]['text':' Async functions are implemented as generators, and generators are','line_number':2413,'multiline':False]['text':' assumed to be statement lists, to prepend initial `yield`.','line_number':2414,'multiline':False]['text':' Declare the 'arguments' and 'this' bindings if necessary before','line_number':2460,'multiline':False]['text':' finishing up the scope so these special bindings get marked as closed','line_number':2461,'multiline':False]['text':' over if necessary. Arrow functions don't have these bindings.','line_number':2462,'multiline':False]['text':' = TokenStream::SlashIsRegExp ','line_number':2480,'multiline':True]['text':'
     * When current token is `await` and it's outside of async function,
     * it's possibly intended to be an await expression.
     *
     *   await f();
     *        ^
     *        |
     *        tried to insert semicolon here
     *
     * Detect this situation and throw an understandable error.  Otherwise
     * we'd throw a confusing "unexpected token: (unexpected token)" error.
     ','line_number':2487,'multiline':True]['text':' Advance the scanner for proper error location reporting. ','line_number':2513,'multiline':True]['text':' If the current function allows super.property but cannot have a home','line_number':2528,'multiline':False]['text':' object, i.e., it is an arrow function, we need to propagate the flag to','line_number':2529,'multiline':False]['text':' the outer ParseContext.','line_number':2530,'multiline':False]['text':' Lazy functions inner to another lazy function need to be remembered by','line_number':2539,'multiline':False]['text':' the inner function so that if the outer function is eventually parsed','line_number':2540,'multiline':False]['text':' we do not need any further parsing or processing of the inner function.','line_number':2541,'multiline':False]['text':'','line_number':2542,'multiline':False]['text':' Append the inner function index here unconditionally; the vector is only','line_number':2543,'multiline':False]['text':' used if the Parser using outerpc is a syntax parsing. See','line_number':2544,'multiline':False]['text':' GeneralParser<SyntaxParseHandler>::finishFunction.','line_number':2545,'multiline':False]['text':' NOTE: `Debugger::CallData::findScripts` relies on sourceStart and','line_number':2580,'multiline':False]['text':'       lineno/column referring to the same location.','line_number':2581,'multiline':False]['text':' Modifier for the following tokens.','line_number':2598,'multiline':False]['text':' TokenStream::SlashIsDiv for the following cases:','line_number':2599,'multiline':False]['text':'   async a => 1','line_number':2600,'multiline':False]['text':'         ^','line_number':2601,'multiline':False]['text':'','line_number':2602,'multiline':False]['text':'   (a) => 1','line_number':2603,'multiline':False]['text':'   ^','line_number':2604,'multiline':False]['text':'','line_number':2605,'multiline':False]['text':'   async (a) => 1','line_number':2606,'multiline':False]['text':'         ^','line_number':2607,'multiline':False]['text':'','line_number':2608,'multiline':False]['text':'   function f(a) {}','line_number':2609,'multiline':False]['text':'             ^','line_number':2610,'multiline':False]['text':'','line_number':2611,'multiline':False]['text':' TokenStream::SlashIsRegExp for the following case:','line_number':2612,'multiline':False]['text':'   a => 1','line_number':2613,'multiline':False]['text':'   ^','line_number':2614,'multiline':False]['text':' Modifier for the the first token in each argument.','line_number':2617,'multiline':False]['text':' can be changed to TokenStream::SlashIsDiv for the following case:','line_number':2618,'multiline':False]['text':'   async a => 1','line_number':2619,'multiline':False]['text':'         ^','line_number':2620,'multiline':False]['text':' In async function, the first token after `async` is already gotten','line_number':2624,'multiline':False]['text':' with TokenStream::SlashIsDiv.','line_number':2625,'multiline':False]['text':' In sync function, the first token is already gotten with','line_number':2626,'multiline':False]['text':' TokenStream::SlashIsRegExp.','line_number':2627,'multiline':False]['text':' Record the start of function source (for FunctionToString). If we','line_number':2653,'multiline':False]['text':' are parenFreeArrow, we will set this below, after consuming the NAME.','line_number':2654,'multiline':False]['text':' When delazifying, we may not have a current token and pos() is','line_number':2657,'multiline':False]['text':' garbage. In that case, substitute the first token's position.','line_number':2658,'multiline':False]['text':' Has duplicated args before the rest parameter.','line_number':2721,'multiline':False]['text':' Has duplicated args before the destructuring parameter.','line_number':2745,'multiline':False]['text':' The next step is to detect arguments with default expressions,','line_number':2798,'multiline':False]['text':' e.g. |function parseInt(str, radix = 10) {}|.  But if we have a','line_number':2799,'multiline':False]['text':' parentheses-free arrow function, |a => ...|, the '=' necessary','line_number':2800,'multiline':False]['text':' for a default expression would really be an assignment operator:','line_number':2801,'multiline':False]['text':' that is, |a = b => 42;| would parse as |a = (b => 42);|.  So we','line_number':2802,'multiline':False]['text':' should stop parsing arguments here.','line_number':2803,'multiline':False]['text':' A default argument without parentheses would look like:','line_number':2814,'multiline':False]['text':' a = expr => body, but both operators are right-associative, so','line_number':2815,'multiline':False]['text':' that would have been parsed as a = (expr => body) instead.','line_number':2816,'multiline':False]['text':' Therefore it's impossible to get here with parenFreeArrow.','line_number':2817,'multiline':False]['text':' The Function.length property is the number of formals','line_number':2833,'multiline':False]['text':' before the first default argument.','line_number':2834,'multiline':False]['text':' Setter syntax uniquely requires exactly one argument.','line_number':2849,'multiline':False]['text':' When a lazily-parsed function is called, we only fully parse (and emit)','line_number':2904,'multiline':False]['text':' that function, not any of its nested children. The initial syntax-only','line_number':2905,'multiline':False]['text':' parse recorded the free variables of nested functions and their extents,','line_number':2906,'multiline':False]['text':' so we can skip over them after accounting for their free variables.','line_number':2907,'multiline':False]['text':' TODO-Stencil: Consider for snapshotting.','line_number':2913,'multiline':False]['text':' strict = ','line_number':2925,'multiline':True]['text':' If the inner lazy function is class constructor, connect it to the class','line_number':2934,'multiline':False]['text':' statement/expression we are parsing.','line_number':2935,'multiline':False]['text':' Info derived from parent compilation should not be set yet for our inner','line_number':2946,'multiline':False]['text':' lazy functions. Instead that info will be updated when we finish our','line_number':2947,'multiline':False]['text':' compilation.','line_number':2948,'multiline':False]['text':' Append possible Annex B function box only upon successfully parsing.','line_number':2957,'multiline':False]['text':' = false ','line_number':3064,'multiline':True]['text':' If we see any inner function, note it on our current context. The bytecode','line_number':3067,'multiline':False]['text':' emitter may eliminate the function later, but we use a conservative','line_number':3068,'multiline':False]['text':' definition for consistency between lazy and full parsing.','line_number':3069,'multiline':False]['text':' When fully parsing a lazy script, we do not fully reparse its inner','line_number':3072,'multiline':False]['text':' functions, which are also lazy. Instead, their free variables and source','line_number':3073,'multiline':False]['text':' extents are recorded and may be skipped.','line_number':3074,'multiline':False]['text':' Self-hosted functions with special function names require extended slots','line_number':3083,'multiline':False]['text':' for various purposes.','line_number':3084,'multiline':False]['text':' Speculatively parse using the directives of the parent parsing context.','line_number':3093,'multiline':False]['text':' If a directive is encountered (e.g., "use strict") that changes how the','line_number':3094,'multiline':False]['text':' function should have been parsed, we backup and reparse with the new set','line_number':3095,'multiline':False]['text':' of directives.','line_number':3096,'multiline':False]['text':' Parse the inner function. The following is a loop as we may attempt to','line_number':3103,'multiline':False]['text':' reparse a function due to failed syntax parsing and encountering new','line_number':3104,'multiline':False]['text':' "use foo" directives.','line_number':3105,'multiline':False]['text':' Return on error.','line_number':3114,'multiline':False]['text':' Assignment must be monotonic to prevent infinitely attempting to','line_number':3119,'multiline':False]['text':' reparse.','line_number':3120,'multiline':False]['text':' Rewind to retry parsing with new directives applied.','line_number':3125,'multiline':False]['text':' functionFormalParametersAndBody may have already set body before','line_number':3129,'multiline':False]['text':' failing.','line_number':3130,'multiline':False]['text':' Advance this parser over tokens processed by the syntax parser.','line_number':3142,'multiline':False]['text':' Try a syntax parse for this inner function.','line_number':3160,'multiline':False]['text':' If we're assuming this function is an IIFE, always perform a full','line_number':3162,'multiline':False]['text':' parse to avoid the overhead of a lazy syntax-only parse. Although','line_number':3163,'multiline':False]['text':' the prediction may be incorrect, IIFEs are common enough that it','line_number':3164,'multiline':False]['text':' pays off for lots of code.','line_number':3165,'multiline':False]['text':' Move the syntax parser to the current position in the stream.  In the','line_number':3180,'multiline':False]['text':' common case this seeks forward, but it'll also seek backward *at least*','line_number':3181,'multiline':False]['text':' when arrow functions appear inside arrow function argument defaults','line_number':3182,'multiline':False]['text':' (because we rewind to reparse arrow functions once we're certain they're','line_number':3183,'multiline':False]['text':' arrow functions):','line_number':3184,'multiline':False]['text':'','line_number':3185,'multiline':False]['text':'   var x = (y = z => 2) => q;','line_number':3186,'multiline':False]['text':'   //           ^ we first seek to here to syntax-parse this function','line_number':3187,'multiline':False]['text':'   //      ^ then we seek back to here to syntax-parse the outer function','line_number':3188,'multiline':False]['text':' Make a FunctionBox before we enter the syntax parser, because |pn|','line_number':3194,'multiline':False]['text':' still expects a FunctionBox to be attached to it during BCE, and','line_number':3195,'multiline':False]['text':' the syntax parser cannot attach one to it.','line_number':3196,'multiline':False]['text':' Try again with a full parse. UsedNameTracker needs to be','line_number':3211,'multiline':False]['text':' rewound to just before we tried the syntax parse for','line_number':3212,'multiline':False]['text':' correctness.','line_number':3213,'multiline':False]['text':' Update the end position of the parse node.','line_number':3228,'multiline':False]['text':' Append possible Annex B function box only upon successfully parsing.','line_number':3231,'multiline':False]['text':' We failed to do a syntax parse above, so do the full parse.','line_number':3241,'multiline':False]['text':' This is already a syntax parser, so just parse the inner function.','line_number':3261,'multiline':False]['text':' Note that it is possible for outerpc != this->pc_, as we may be','line_number':3294,'multiline':False]['text':' attempting to syntax parse an inner function from an outer full','line_number':3295,'multiline':False]['text':' parser. In that case, outerpc is a SourceParseContext from the full parser','line_number':3296,'multiline':False]['text':' instead of the current top of the stack of the syntax parser.','line_number':3297,'multiline':False]['text':' Push a new ParseContext.','line_number':3299,'multiline':False]['text':' Note that it is possible for outerpc != this->pc_, as we may be','line_number':3326,'multiline':False]['text':' attempting to syntax parse an inner function from an outer full','line_number':3327,'multiline':False]['text':' parser. In that case, outerpc is a SourceParseContext from the full parser','line_number':3328,'multiline':False]['text':' instead of the current top of the stack of the syntax parser.','line_number':3329,'multiline':False]['text':' Append possible Annex B function box only upon successfully parsing.','line_number':3345,'multiline':False]['text':' TODO-Stencil: Consider for snapshotting.','line_number':3411,'multiline':False]['text':' Our tokenStream has no current token, so funNode's position is garbage.','line_number':3440,'multiline':False]['text':' Substitute the position of the first token in our source.  If the','line_number':3441,'multiline':False]['text':' function is a not-async arrow, use TokenStream::SlashIsRegExp to keep','line_number':3442,'multiline':False]['text':' verifyConsistentModifier from complaining (we will use','line_number':3443,'multiline':False]['text':' TokenStream::SlashIsRegExp in functionArguments).','line_number':3444,'multiline':False]['text':' Currently default class constructors are the only synthetic function that','line_number':3456,'multiline':False]['text':' supports delazification.','line_number':3457,'multiline':False]['text':' Reset pos() to the `class` keyword for predictable results.','line_number':3467,'multiline':False]['text':' Don't constant-fold inside "use asm" code, as this could create a parse','line_number':3487,'multiline':False]['text':' tree that doesn't type-check as asm.js.','line_number':3488,'multiline':False]['text':' = Nothing() ','line_number':3508,'multiline':True]['text':' = false ','line_number':3509,'multiline':True]['text':' Given a properly initialized parse context, try to parse an actual','line_number':3510,'multiline':False]['text':' function without concern for conversion to strict mode, use of lazy','line_number':3511,'multiline':False]['text':' parsing and such.','line_number':3512,'multiline':False]['text':' See below for an explanation why arrow function parameters and arrow','line_number':3523,'multiline':False]['text':' function bodies are parsed with different yield/await settings.','line_number':3524,'multiline':False]['text':' When parsing something for new Function() we have to make sure to','line_number':3568,'multiline':False]['text':' only treat a certain part of the source as a parameter list.','line_number':3569,'multiline':False]['text':' Parse the function body.','line_number':3575,'multiline':False]['text':' Arrow function parameters inherit yieldHandling from the enclosing','line_number':3595,'multiline':False]['text':' context, but the arrow body doesn't. E.g. in |(a = yield) => yield|,','line_number':3596,'multiline':False]['text':' |yield| in the parameters is either a name or keyword, depending on','line_number':3597,'multiline':False]['text':' whether the arrow function is enclosed in a generator function or not.','line_number':3598,'multiline':False]['text':' Whereas the |yield| in the function body is always parsed as a name.','line_number':3599,'multiline':False]['text':' The same goes when parsing |await| in arrow functions.','line_number':3600,'multiline':False]['text':' Revalidate the function name when we transitioned to strict mode.','line_number':3616,'multiline':False]['text':' Named lambda has binding inside it.','line_number':3627,'multiline':False]['text':' Otherwise YieldHandling cannot be checked at this point','line_number':3630,'multiline':False]['text':' because of different context.','line_number':3631,'multiline':False]['text':' It should already be checked before this point.','line_number':3632,'multiline':False]['text':' We already use the correct await-handling at this point, therefore','line_number':3636,'multiline':False]['text':' we don't need call AutoAwaitIsKeyword here.','line_number':3637,'multiline':False]['text':' Cannot use mustMatchToken here because of internal compiler error on','line_number':3646,'multiline':False]['text':' gcc 6.4.0, with linux 64 SM hazard build.','line_number':3647,'multiline':False]['text':' In sloppy mode, Annex B.3.2 allows labelled function declarations.','line_number':3698,'multiline':False]['text':' Otherwise it's a parse error.','line_number':3699,'multiline':False]['text':' Find the innermost non-label statement.  Report an error if it's','line_number':3705,'multiline':False]['text':' unbraced: functions can't appear in it.  Otherwise the statement','line_number':3706,'multiline':False]['text':' (or its absence) determines the scope the function's bound in.','line_number':3707,'multiline':False]['text':' Unnamed function expressions are forbidden in statement context. ','line_number':3741,'multiline':True]['text':' Note the declared name and check for early errors.','line_number':3746,'multiline':False]['text':' Under sloppy mode, try Annex B.3.3 semantics. If making an additional','line_number':3772,'multiline':False]['text':' 'var' binding of the same name does not throw an early error, do so.','line_number':3773,'multiline':False]['text':' This 'var' binding would be assigned the function object when its','line_number':3774,'multiline':False]['text':' declaration is reached, not at the start of the block.','line_number':3775,'multiline':False]['text':'','line_number':3776,'multiline':False]['text':' This semantics is implemented upon Scope exit in','line_number':3777,'multiline':False]['text':' Scope::propagateAndMarkAnnexBFunctionBoxes.','line_number':3778,'multiline':False]['text':'
 * Return true if this node, known to be an unparenthesized string literal
 * that never contain escape sequences, could be the string of a directive in a
 * Directive Prologue. Directive strings never contain escape sequences or line
 * continuations.
 ','line_number':3835,'multiline':True]['text':' the length of "use strict", including quotation.','line_number':3843,'multiline':False]['text':' the length of "use asm", including quotation.','line_number':3850,'multiline':False]['text':' While asm.js could technically be validated and compiled during syntax','line_number':3858,'multiline':False]['text':' parsing, we have no guarantee that some later JS wouldn't abort the','line_number':3859,'multiline':False]['text':' syntax parse and cause us to re-parse (and re-compile) the asm.js module.','line_number':3860,'multiline':False]['text':' For simplicity, unconditionally abort the syntax parse when "use asm" is','line_number':3861,'multiline':False]['text':' encountered so that asm.js is always validated/compiled exactly once','line_number':3862,'multiline':False]['text':' during a full parse.','line_number':3863,'multiline':False]['text':' Record that the current script source constains some AsmJS, to disable','line_number':3866,'multiline':False]['text':' any incremental encoder, as AsmJS cannot be encoded with XDR at the','line_number':3867,'multiline':False]['text':' moment.','line_number':3868,'multiline':False]['text':' Disable syntax parsing in anything nested inside the asm.js module.','line_number':3877,'multiline':False]['text':' We should be encountering the "use asm" directive for the first time; if','line_number':3880,'multiline':False]['text':' the directive is already, we must have failed asm.js validation and we're','line_number':3881,'multiline':False]['text':' reparsing. In that case, don't try to validate again. A non-null','line_number':3882,'multiline':False]['text':' newDirectives means we're not in a normal function.','line_number':3883,'multiline':False]['text':' If there is no ScriptSource, then we are doing a non-compiling parse and','line_number':3888,'multiline':False]['text':' so we shouldn't (and can't, without a ScriptSource) compile.','line_number':3889,'multiline':False]['text':' Attempt to validate and compile this asm.js module. On success, the','line_number':3897,'multiline':False]['text':' tokenStream has been advanced to the closing }. On failure, the','line_number':3898,'multiline':False]['text':' tokenStream is in an indeterminate state and we must reparse the','line_number':3899,'multiline':False]['text':' function from the beginning. Reparsing is triggered by marking that a','line_number':3900,'multiline':False]['text':' new directive has been encountered and returning 'false'.','line_number':3901,'multiline':False]['text':'
 * Recognize Directive Prologue members and directives. Assuming |pn| is a
 * candidate for membership in a directive prologue, recognize directives and
 * set |pc_|'s flags accordingly. If |pn| is indeed part of a prologue, set its
 * |prologue| flag.
 *
 * Note that the following is a strict mode function:
 *
 * function foo() {
 *   "blah" // inserted semi colon
 *        "blurgh"
 *   "use\x20loose"
 *   "use strict"
 * }
 *
 * That is, even though "use\x20loose" can never be a directive, now or in the
 * future (because of the hex escape), the Directive Prologue extends through it
 * to the "use strict" statement, which is indeed a directive.
 ','line_number':3919,'multiline':True]['text':' Functions with non-simple parameter lists (destructuring,','line_number':3951,'multiline':False]['text':' default or rest parameters) must not contain a "use strict"','line_number':3952,'multiline':False]['text':' directive.','line_number':3953,'multiline':False]['text':' We're going to be in strict mode. Note that this scope explicitly','line_number':3967,'multiline':False]['text':' had "use strict";','line_number':3968,'multiline':False]['text':' Some strict mode violations can appear before a Use Strict Directive','line_number':3971,'multiline':False]['text':' is applied.  (See the |DeprecatedContent| enum initializers.)  These','line_number':3972,'multiline':False]['text':' violations can manifest in two ways.','line_number':3973,'multiline':False]['text':'','line_number':3974,'multiline':False]['text':' First, the violation can appear *before* the Use Strict Directive.','line_number':3975,'multiline':False]['text':' Numeric literals (and therefore octal literals) can only precede a','line_number':3976,'multiline':False]['text':' Use Strict Directive if this function's parameter list is not simple,','line_number':3977,'multiline':False]['text':' but we reported an error for non-simple parameter lists above, so','line_number':3978,'multiline':False]['text':' octal literals present no issue.  But octal escapes and \8 and \9 can','line_number':3979,'multiline':False]['text':' appear in the directive prologue before a Use Strict Directive:','line_number':3980,'multiline':False]['text':'','line_number':3981,'multiline':False]['text':'   function f()','line_number':3982,'multiline':False]['text':'   {','line_number':3983,'multiline':False]['text':'     "hell\157 world";  // octal escape','line_number':3984,'multiline':False]['text':'     "\8"; "\9";        // NonOctalDecimalEscape','line_number':3985,'multiline':False]['text':'     "use strict";      // retroactively makes all the above errors','line_number':3986,'multiline':False]['text':'   }','line_number':3987,'multiline':False]['text':'','line_number':3988,'multiline':False]['text':' Second, the violation can appear *after* the Use Strict Directive but','line_number':3989,'multiline':False]['text':' *before* the directive is recognized as terminated.  This only','line_number':3990,'multiline':False]['text':' happens when a directive is terminated by ASI, and the next token','line_number':3991,'multiline':False]['text':' contains a violation:','line_number':3992,'multiline':False]['text':'','line_number':3993,'multiline':False]['text':'   function a()','line_number':3994,'multiline':False]['text':'   {','line_number':3995,'multiline':False]['text':'     "use strict"  // ASI','line_number':3996,'multiline':False]['text':'     0755;','line_number':3997,'multiline':False]['text':'   }','line_number':3998,'multiline':False]['text':'   function b()','line_number':3999,'multiline':False]['text':'   {','line_number':4000,'multiline':False]['text':'     "use strict"  // ASI','line_number':4001,'multiline':False]['text':'     "hell\157 world";','line_number':4002,'multiline':False]['text':'   }','line_number':4003,'multiline':False]['text':'   function c()','line_number':4004,'multiline':False]['text':'   {','line_number':4005,'multiline':False]['text':'     "use strict"  // ASI','line_number':4006,'multiline':False]['text':'     "\8";','line_number':4007,'multiline':False]['text':'   }','line_number':4008,'multiline':False]['text':'','line_number':4009,'multiline':False]['text':' We note such violations when tokenizing.  Then, if a violation has','line_number':4010,'multiline':False]['text':' been observed at the time a "use strict" is applied, we report the','line_number':4011,'multiline':False]['text':' error.','line_number':4012,'multiline':False]['text':' Clear flags for deprecated content that might have been seen in an','line_number':4053,'multiline':False]['text':' enclosing context.','line_number':4054,'multiline':False]['text':' Don't overwrite a previously recorded error.','line_number':4201,'multiline':False]['text':' If we report an error later, we'll do it from the position where we set','line_number':4206,'multiline':False]['text':' the state to pending.','line_number':4207,'multiline':False]['text':' Clear pending expression error, because we're definitely not in an','line_number':4248,'multiline':False]['text':' expression context.','line_number':4249,'multiline':False]['text':' Report any pending destructuring error.','line_number':4252,'multiline':False]['text':' Clear pending destructuring error, because we're definitely not','line_number':4259,'multiline':False]['text':' in a destructuring context.','line_number':4260,'multiline':False]['text':' Report any pending expression error.','line_number':4264,'multiline':False]['text':' Handle e.g., |var {p: x} = o| and |var {p: x=0} = o|.','line_number':4416,'multiline':False]['text':' Handle e.g., |var {x, y} = o| as destructuring shorthand','line_number':4444,'multiline':False]['text':' for |var {x: x, y: y} = o|.','line_number':4445,'multiline':False]['text':' Handle e.g., |var {x=1, y=2} = o| as destructuring','line_number':4458,'multiline':False]['text':' shorthand with default values.','line_number':4459,'multiline':False]['text':' If we didn't already match TokenKind::Comma in above case.','line_number':4586,'multiline':False]['text':' An initialized declaration can't appear in a for-of:','line_number':4763,'multiline':False]['text':'','line_number':4764,'multiline':False]['text':'   for (var/let/const x = ... of ...); // BAD','line_number':4765,'multiline':False]['text':' Lexical declarations in for-in loops can't be initialized:','line_number':4772,'multiline':False]['text':'','line_number':4773,'multiline':False]['text':'   for (let/const x = ... in ...); // BAD','line_number':4774,'multiline':False]['text':' This leaves only initialized for-in |var| declarations.  ES6','line_number':4780,'multiline':False]['text':' forbids these; later ES un-forbids in non-strict mode code.','line_number':4781,'multiline':False]['text':' Anything other than possible identifier is an error.','line_number':4806,'multiline':False]['text':' The '=' context after a variable name in a declaration is an opportunity','line_number':4824,'multiline':False]['text':' for ASI, and thus for the next token to start an ExpressionStatement:','line_number':4825,'multiline':False]['text':'','line_number':4826,'multiline':False]['text':'  var foo   // VariableDeclaration','line_number':4827,'multiline':False]['text':'  /bar/g;   // ExpressionStatement','line_number':4828,'multiline':False]['text':'','line_number':4829,'multiline':False]['text':' Therefore get the token here with SlashIsRegExp.','line_number':4830,'multiline':False]['text':' Normal const declarations, and const declarations in for(;;)','line_number':4870,'multiline':False]['text':' heads, must be initialized.','line_number':4871,'multiline':False]['text':' Note the declared name after knowing whether or not we are in a for-of','line_number':4879,'multiline':False]['text':' loop, due to special early error semantics in Annex B.3.5.','line_number':4880,'multiline':False]['text':' = nullptr ','line_number':4892,'multiline':True]['text':' = nullptr ','line_number':4893,'multiline':True]['text':' If we have a for-in/of loop, the above call matches the entirety','line_number':4941,'multiline':False]['text':' of the loop head (up to the closing parenthesis).','line_number':4942,'multiline':False]['text':'
   * Parse body-level lets without a new block object. ES6 specs
   * that an execution environment's initial lexical environment
   * is the VariableEnvironment, i.e., body-level lets are in
   * the same environment record as vars.
   *
   * However, they cannot be parsed exactly as vars, as ES6
   * requires that uninitialized lets throw ReferenceError on use.
   *
   * See 8.1.1.1.6 and the note in 13.2.1.
   ','line_number':4964,'multiline':True]['text':' Handle the forms |import {} from 'a'| and','line_number':5005,'multiline':False]['text':' |import { ..., } from 'a'| (where ... is non empty), by','line_number':5006,'multiline':False]['text':' escaping the loop early if the next token is }.','line_number':5007,'multiline':False]['text':' String export names can't refer to local bindings.','line_number':5047,'multiline':False]['text':' Keywords cannot be bound to themselves, so an import name','line_number':5053,'multiline':False]['text':' that is a keyword is a syntax error if it is not followed','line_number':5054,'multiline':False]['text':' by the keyword 'as'.','line_number':5055,'multiline':False]['text':' See the ImportSpecifier production in ES6 section 15.2.2.','line_number':5056,'multiline':False]['text':' Namespace imports are not indirect bindings but lexical','line_number':5120,'multiline':False]['text':' definitions that hold a module namespace object. They are treated','line_number':5121,'multiline':False]['text':' as const variables which are initialized during the','line_number':5122,'multiline':False]['text':' ModuleInstantiate step.','line_number':5123,'multiline':False]['text':' The namespace import name is currently required to live on the','line_number':5136,'multiline':False]['text':' environment.','line_number':5137,'multiline':False]['text':' Handle the form |import 'a'| by leaving the list empty. This is','line_number':5178,'multiline':False]['text':' equivalent to |import {} from 'a'|.','line_number':5179,'multiline':False]['text':' Handle the form |import a from 'b'|, by adding a single import','line_number':5191,'multiline':False]['text':' specifier to the list, with 'default' as the import name and','line_number':5192,'multiline':False]['text':' 'a' as the binding name. This is equivalent to','line_number':5193,'multiline':False]['text':' |import { default as a } from 'b'|.','line_number':5194,'multiline':False]['text':' Handle the form |export *| by adding a special export batch','line_number':5661,'multiline':False]['text':' specifier to the list.','line_number':5662,'multiline':False]['text':' ES 2017 draft 15.2.3.1.','line_number':5680,'multiline':False]['text':' Handle the forms |export {}| and |export { ..., }| (where ... is non','line_number':5729,'multiline':False]['text':' empty), by escaping the loop early if the next token is }.','line_number':5730,'multiline':False]['text':' Careful!  If |from| follows, even on a new line, it must start a','line_number':5807,'multiline':False]['text':' FromClause:','line_number':5808,'multiline':False]['text':'','line_number':5809,'multiline':False]['text':'   export { x }','line_number':5810,'multiline':False]['text':'   from "foo"; // a single ExportDeclaration','line_number':5811,'multiline':False]['text':'','line_number':5812,'multiline':False]['text':' But if it doesn't, we might have an ASI opportunity in SlashIsRegExp','line_number':5813,'multiline':False]['text':' context:','line_number':5814,'multiline':False]['text':'','line_number':5815,'multiline':False]['text':'   export { x }   // ExportDeclaration, terminated by ASI','line_number':5816,'multiline':False]['text':'   fro\u006D      // ExpressionStatement, the name "from"','line_number':5817,'multiline':False]['text':'','line_number':5818,'multiline':False]['text':' In that case let matchOrInsertSemicolon sort out ASI or any necessary','line_number':5819,'multiline':False]['text':' error.','line_number':5820,'multiline':False]['text':' = SyncFunction ','line_number':5889,'multiline':True]['text':' = SyncFunction ','line_number':5989,'multiline':True]['text':' possibleError = ','line_number':6204,'multiline':True]['text':' Annex B.3.4 says that unbraced FunctionDeclarations under if/else in','line_number':6223,'multiline':False]['text':' non-strict code act as if they were braced: |if (x) function f() {}|','line_number':6224,'multiline':False]['text':' parses as |if (x) { function f() {} }|.','line_number':6225,'multiline':False]['text':'','line_number':6226,'multiline':False]['text':' Careful!  FunctionDeclaration doesn't include generators or async','line_number':6227,'multiline':False]['text':' functions.','line_number':6228,'multiline':False]['text':' Parser::statement would handle this, but as this function handles','line_number':6232,'multiline':False]['text':' every other error case, it seems best to handle this.','line_number':6233,'multiline':False]['text':' An IF node has three kids: condition, then, and optional else. ','line_number':6285,'multiline':True]['text':' The semicolon after do-while is even more optional than most','line_number':6360,'multiline':False]['text':' semicolons in JS.  Web compat required this by 2004:','line_number':6361,'multiline':False]['text':'   http://bugzilla.mozilla.org/show_bug.cgi?id=238945','line_number':6362,'multiline':False]['text':' ES3 and ES5 disagreed, but ES6 conforms to Web reality:','line_number':6363,'multiline':False]['text':'   https://bugs.ecmascript.org/show_bug.cgi?id=157','line_number':6364,'multiline':False]['text':' To parse |do {} while (true) false| correctly, use SlashIsRegExp.','line_number':6365,'multiline':False]['text':' Super-duper easy case: |for (;| is a C-style for-loop with no init','line_number':6421,'multiline':False]['text':' component.','line_number':6422,'multiline':False]['text':' Parsing after |for (var| is also relatively simple (from this method's','line_number':6429,'multiline':False]['text':' point of view).  No block-related work complicates matters, so delegate','line_number':6430,'multiline':False]['text':' to Parser::declaration.','line_number':6431,'multiline':False]['text':' Pass null for block object because |var| declarations don't use one.','line_number':6435,'multiline':False]['text':' Otherwise we have a lexical declaration or an expression.','line_number':6441,'multiline':False]['text':' For-in loop backwards compatibility requires that |let| starting a','line_number':6443,'multiline':False]['text':' for-loop that's not a (new to ES6) for-of loop, in non-strict mode code,','line_number':6444,'multiline':False]['text':' parse as an identifier.  (|let| in for-of is always a declaration.)','line_number':6445,'multiline':False]['text':'','line_number':6446,'multiline':False]['text':' For-of loops can't start with the token sequence "async of", because that','line_number':6447,'multiline':False]['text':' leads to a shift-reduce conflict when parsing |for (async of => {};;)| or','line_number':6448,'multiline':False]['text':' |for (async of [])|.','line_number':6449,'multiline':False]['text':' We could have a {For,Lexical}Declaration, or we could have a','line_number':6457,'multiline':False]['text':' LeftHandSideExpression with lookahead restrictions so it's not','line_number':6458,'multiline':False]['text':' ambiguous with the former.  Check for a continuation of the former','line_number':6459,'multiline':False]['text':' to decide which we have.','line_number':6460,'multiline':False]['text':' Push a temporary ForLoopLexicalHead Statement that allows for','line_number':6493,'multiline':False]['text':' lexical declarations, as they are usually allowed only in braced','line_number':6494,'multiline':False]['text':' statements.','line_number':6495,'multiline':False]['text':' Finally, handle for-loops that start with expressions.  Pass','line_number':6511,'multiline':False]['text':' |InProhibited| so that |in| isn't parsed in a RelationalExpression as a','line_number':6512,'multiline':False]['text':' binary operator.  |in| makes it a for-in loop, *not* an |in| expression.','line_number':6513,'multiline':False]['text':' If we don't encounter 'in'/'of', we have a for(;;) loop.  We've handled','line_number':6526,'multiline':False]['text':' the init expression; the caller handles the rest.','line_number':6527,'multiline':False]['text':' In a for-of loop, 'let' that starts the loop head is a |let| keyword,','line_number':6539,'multiline':False]['text':' per the [lookahead  let] restriction on the LeftHandSideExpression','line_number':6540,'multiline':False]['text':' variant of such loops.  Expressions that start with |let| can't be used','line_number':6541,'multiline':False]['text':' here.','line_number':6542,'multiline':False]['text':'','line_number':6543,'multiline':False]['text':'   var let = {};','line_number':6544,'multiline':False]['text':'   for (let.prop of [1]) // BAD','line_number':6545,'multiline':False]['text':'     break;','line_number':6546,'multiline':False]['text':'','line_number':6547,'multiline':False]['text':' See ES6 13.7.','line_number':6548,'multiline':False]['text':' In a for-of loop, the LeftHandSideExpression isn't allowed to be an','line_number':6554,'multiline':False]['text':' identifier named "async" per the [lookahead  async of] restriction.','line_number':6555,'multiline':False]['text':' Verify the left-hand side expression doesn't have a forbidden form.','line_number':6563,'multiline':False]['text':' |chars| is "arguments" or "eval" here.','line_number':6570,'multiline':False]['text':' Permitted: no additional testing/fixup needed.','line_number':6576,'multiline':False]['text':' Finally, parse the iterated expression, making the for-loop's closing','line_number':6590,'multiline':False]['text':' ')' the next token.','line_number':6591,'multiline':False]['text':' If we come across a top level await here, mark the module as async.','line_number':6615,'multiline':False]['text':' ParseNodeKind::ForHead, ParseNodeKind::ForIn, or','line_number':6635,'multiline':False]['text':' ParseNodeKind::ForOf depending on the loop type.','line_number':6636,'multiline':False]['text':' |x| in either |for (x; ...; ...)| or |for (x in/of ...)|.','line_number':6639,'multiline':False]['text':' The next two variables are used to implement `for (let/const ...)`.','line_number':6642,'multiline':False]['text':'','line_number':6643,'multiline':False]['text':' We generate an implicit block, wrapping the whole loop, to store loop','line_number':6644,'multiline':False]['text':' variables declared this way. Note that if the loop uses `for (var...)`','line_number':6645,'multiline':False]['text':' instead, those variables go on some existing enclosing scope, so no','line_number':6646,'multiline':False]['text':' implicit block scope is created.','line_number':6647,'multiline':False]['text':'','line_number':6648,'multiline':False]['text':' Both variables remain null/none if the loop is any other form.','line_number':6649,'multiline':False]['text':' The static block scope for the implicit block scope.','line_number':6651,'multiline':False]['text':' The expression being iterated over, for for-in/of loops only.  Unused','line_number':6654,'multiline':False]['text':' for for(;;) loops.','line_number':6655,'multiline':False]['text':' Parse the entirety of the loop-head for a for-in/of loop (so the next','line_number':6658,'multiline':False]['text':' token is the closing ')'):','line_number':6659,'multiline':False]['text':'','line_number':6660,'multiline':False]['text':'   for (... in/of ...) ...','line_number':6661,'multiline':False]['text':'                     ^next token','line_number':6662,'multiline':False]['text':'','line_number':6663,'multiline':False]['text':' ...OR, parse up to the first ';' in a C-style for-loop:','line_number':6664,'multiline':False]['text':'','line_number':6665,'multiline':False]['text':'   for (...; ...; ...) ...','line_number':6666,'multiline':False]['text':'           ^next token','line_number':6667,'multiline':False]['text':'','line_number':6668,'multiline':False]['text':' In either case the subsequent token can be consistently accessed using','line_number':6669,'multiline':False]['text':' TokenStream::SlashIsDiv semantics.','line_number':6670,'multiline':False]['text':' Look for an operand: |for (;| means we might have already examined','line_number':6689,'multiline':False]['text':' this semicolon with that modifier.','line_number':6690,'multiline':False]['text':' |target| is the LeftHandSideExpression or declaration to which the','line_number':6741,'multiline':False]['text':' per-iteration value (an arbitrary value exposed by the iteration','line_number':6742,'multiline':False]['text':' protocol, or a string naming a property) is assigned.','line_number':6743,'multiline':False]['text':' Parse the rest of the for-in/of head.','line_number':6746,'multiline':False]['text':' Parser::declaration consumed everything up to the closing ')'.  That','line_number':6753,'multiline':False]['text':' token follows an {Assignment,}Expression and so must be interpreted','line_number':6754,'multiline':False]['text':' as an operand to be consistent with normal expression tokenizing.','line_number':6755,'multiline':False]['text':' The default case has pn_left == nullptr.','line_number':6839,'multiline':False]['text':' Parse an optional operand.','line_number':6990,'multiline':False]['text':'','line_number':6991,'multiline':False]['text':' This is ugly, but we don't want to require a semicolon.','line_number':6992,'multiline':False]['text':' TokenKind::Eol is special; it implements the [no LineTerminator here]','line_number':7038,'multiline':False]['text':' quirk in the grammar.','line_number':7039,'multiline':False]['text':' The rest of these make up the complete set of tokens that can','line_number':7041,'multiline':False]['text':' appear after any of the places where AssignmentExpression is used','line_number':7042,'multiline':False]['text':' throughout the grammar.  Conveniently, none of them can also be the','line_number':7043,'multiline':False]['text':' start an expression.','line_number':7044,'multiline':False]['text':' Annex B.3.6 `for (x = yield in y) ;`','line_number':7052,'multiline':False]['text':' No value.','line_number':7053,'multiline':False]['text':' GeneratorDeclaration is only matched by HoistableDeclaration in','line_number':7125,'multiline':False]['text':' StatementListItem, so generators can't be inside labels.','line_number':7126,'multiline':False]['text':' Per 13.13.1 it's a syntax error if LabelledItem: FunctionDeclaration','line_number':7132,'multiline':False]['text':' is ever matched.  Per Annex B.3.2 that modifies this text, this','line_number':7133,'multiline':False]['text':' applies only to strict mode code.','line_number':7134,'multiline':False]['text':' Push a label struct and parse the statement. ','line_number':7170,'multiline':True]['text':' ECMA-262 Edition 3 says 'throw [no LineTerminator here] Expr'. ','line_number':7186,'multiline':True]['text':'
   * try nodes are ternary.
   * kid1 is the try statement
   * kid2 is the catch node list or null
   * kid3 is the finally statement
   *
   * catch nodes are binary.
   * left is the catch-name/pattern or null
   * right is the catch block
   *
   * catch lvalue nodes are either:
   *   a single identifier
   *   TokenKind::RightBracket for a destructuring left-hand side
   *   TokenKind::RightCurly for a destructuring left-hand side
   *
   * finally nodes are TokenKind::LeftCurly statement lists.
   ','line_number':7219,'multiline':True]['text':'
     * Create a lexical scope node around the whole catch clause,
     * including the head.
     ','line_number':7276,'multiline':True]['text':'
     * Legal catch forms are:
     *   catch (lhs) {
     *   catch {
     * where lhs is a name or a destructuring left-hand side.
     ','line_number':7286,'multiline':True]['text':' ES 13.15.7 CatchClauseEvaluation','line_number':7413,'multiline':False]['text':'','line_number':7414,'multiline':False]['text':' Step 8 means that the body of a catch block always has an additional','line_number':7415,'multiline':False]['text':' lexical scope.','line_number':7416,'multiline':False]['text':' The catch parameter names cannot be redeclared inside the catch','line_number':7422,'multiline':False]['text':' block, so declare the name in the inner scope.','line_number':7423,'multiline':False]['text':' The catch parameter names are not bound in the body scope, so remove','line_number':7441,'multiline':False]['text':' them before generating bindings.','line_number':7442,'multiline':False]['text':' Parsing static class block: static { ... } ','line_number':7507,'multiline':True]['text':' maybeDecl = ','line_number':7541,'multiline':True]['text':' When |super()| is invoked, we search for the nearest scope containing','line_number':7655,'multiline':False]['text':' |.initializers| to initialize the class fields. This set-up precludes','line_number':7656,'multiline':False]['text':' declaring |.initializers| in the class scope, because in some syntactic','line_number':7657,'multiline':False]['text':' contexts |super()| can appear nested in a class, while actually belonging','line_number':7658,'multiline':False]['text':' to an outer class definition.','line_number':7659,'multiline':False]['text':'','line_number':7660,'multiline':False]['text':' Example:','line_number':7661,'multiline':False]['text':' class Outer extends Base {','line_number':7662,'multiline':False]['text':'   field = 1;','line_number':7663,'multiline':False]['text':'   constructor() {','line_number':7664,'multiline':False]['text':'     class Inner {','line_number':7665,'multiline':False]['text':'       field = 2;','line_number':7666,'multiline':False]['text':'','line_number':7667,'multiline':False]['text':'       // The super() call in the computed property name mustn't access','line_number':7668,'multiline':False]['text':'       // Inner's |.initializers| array, but instead Outer's.','line_number':7669,'multiline':False]['text':'       [super()]() {}','line_number':7670,'multiline':False]['text':'     }','line_number':7671,'multiline':False]['text':'   }','line_number':7672,'multiline':False]['text':' }','line_number':7673,'multiline':False]['text':' Calling toString on constructors need to return the source text for','line_number':7687,'multiline':False]['text':' the entire class. The end offset is unknown at this point in','line_number':7688,'multiline':False]['text':' parsing and will be amended when class parsing finishes below.','line_number':7689,'multiline':False]['text':' Private methods are not enabled.','line_number':7701,'multiline':False]['text':' #constructor is an invalid private name.','line_number':7707,'multiline':False]['text':' Private non-static methods are stored in the class body environment.','line_number':7720,'multiline':False]['text':' Private non-static accessors are stamped onto every instance using','line_number':7721,'multiline':False]['text':' initializers. Private static methods are stamped onto the constructor','line_number':7722,'multiline':False]['text':' during class evaluation; see BytecodeEmitter::emitPropertyList.','line_number':7723,'multiline':False]['text':' Synthesize a name for the lexical variable that will store the','line_number':7728,'multiline':False]['text':' accessor body.','line_number':7729,'multiline':False]['text':' Unconditionally create the scope here, because it's always the','line_number':7789,'multiline':False]['text':' constructor.','line_number':7790,'multiline':False]['text':' synthesizeConstructor assigns to classStmt.constructorBox','line_number':7801,'multiline':False]['text':' Note: the *function* has the name of the class, but the *property*','line_number':7809,'multiline':False]['text':' containing the function has the name "constructor"','line_number':7810,'multiline':False]['text':' Amend the toStringEnd offset for the constructor now that we've','line_number':7834,'multiline':False]['text':' finished parsing the class.','line_number':7835,'multiline':False]['text':' Now that we have full set of initializers, update the constructor.','line_number':7842,'multiline':False]['text':' Field initialization need access to `this`.','line_number':7846,'multiline':False]['text':' Class statements must have a bound name','line_number':7879,'multiline':False]['text':' Make sure to put it back, whatever it was','line_number':7884,'multiline':False]['text':' Because the binding definitions keep track of their blockId, we need to','line_number':7888,'multiline':False]['text':' create at least the inner binding later. Keep track of the name's','line_number':7889,'multiline':False]['text':' position in order to provide it for the nodes created later.','line_number':7890,'multiline':False]['text':' Push a ParseContext::ClassStatement to keep track of the constructor','line_number':7895,'multiline':False]['text':' funbox.','line_number':7896,'multiline':False]['text':' A named class creates a new lexical scope with a const binding of the','line_number':7906,'multiline':False]['text':' class name for the "inner name".','line_number':7907,'multiline':False]['text':' We declare `.privateBrand` as ClosedOver because the constructor','line_number':7962,'multiline':False]['text':' always uses it, even a default constructor. We could equivalently','line_number':7963,'multiline':False]['text':' `noteNameUsed` when parsing the constructor, except that at that','line_number':7964,'multiline':False]['text':' time, we don't necessarily know if the class has a private brand.','line_number':7965,'multiline':False]['text':' Pop the class body scope','line_number':8008,'multiline':False]['text':' The inner name is immutable.','line_number':8012,'multiline':False]['text':' Pop the inner scope.','line_number':8028,'multiline':False]['text':' The outer name is mutable.','line_number':8034,'multiline':False]['text':' We're leaving a class definition that was not itself nested within a class','line_number':8051,'multiline':False]['text':' Create the top-level field initializer node.','line_number':8089,'multiline':False]['text':' If we see any inner function, note it on our current context. The bytecode','line_number':8096,'multiline':False]['text':' emitter may eliminate the function later, but we use a conservative','line_number':8097,'multiline':False]['text':' definition for consistency between lazy and full parsing.','line_number':8098,'multiline':False]['text':' When fully parsing a lazy script, we do not fully reparse its inner','line_number':8101,'multiline':False]['text':' functions, which are also lazy. Instead, their free variables and source','line_number':8102,'multiline':False]['text':' extents are recorded and may be skipped.','line_number':8103,'multiline':False]['text':' tryAnnexB = ','line_number':8106,'multiline':True]['text':' Create the FunctionBox and link it to the function object.','line_number':8113,'multiline':False]['text':' Mark this function as being synthesized by the parser. This means special','line_number':8124,'multiline':False]['text':' handling in delazification will be used since we don't have typical','line_number':8125,'multiline':False]['text':' function syntax.','line_number':8126,'multiline':False]['text':' Push a SourceParseContext on to the stack.','line_number':8129,'multiline':False]['text':' newDirectives = ','line_number':8131,'multiline':True]['text':' Create a ListNode for the parameters + body (there are no parameters).','line_number':8155,'multiline':False]['text':' Synthesize the equivalent to `function f(...args)`','line_number':8165,'multiline':False]['text':' disallowDuplicateParams = ','line_number':8170,'multiline':True]['text':' duplicatedParam = ','line_number':8171,'multiline':True]['text':' isSpread = ','line_number':8233,'multiline':True]['text':' Synthesize an initializer function that the constructor can use to stamp a','line_number':8278,'multiline':False]['text':' private method onto an instance object.','line_number':8279,'multiline':False]['text':' Push a SourceParseContext on to the stack.','line_number':8301,'multiline':False]['text':' newDirectives = ','line_number':8303,'multiline':True]['text':' Add empty parameter list.','line_number':8309,'multiline':False]['text':' Note both the stored private method body and it's private name as being','line_number':8319,'multiline':False]['text':' used in the initializer. They will be emitted into the method body in the','line_number':8320,'multiline':False]['text':' BCE.','line_number':8321,'multiline':False]['text':' Unlike field initializers, private method initializers are not created with','line_number':8335,'multiline':False]['text':' a body of synthesized AST nodes. Instead, the body is left empty and the','line_number':8336,'multiline':False]['text':' initializer is synthesized at the bytecode level.','line_number':8337,'multiline':False]['text':' See BytecodeEmitter::emitPrivateMethodInitializer.','line_number':8338,'multiline':False]['text':' Set field-initializer lambda boundary to start at property name and end','line_number':8352,'multiline':False]['text':' after method body.','line_number':8353,'multiline':False]['text':' Both for getting-this-done, and because this will invariably be executed,','line_number':8372,'multiline':False]['text':' syntax parsing should be aborted.','line_number':8373,'multiline':False]['text':' Create the function node for the static class body.','line_number':8390,'multiline':False]['text':' Create the FunctionBox and link it to the function object.','line_number':8396,'multiline':False]['text':' Set start at `static` token.','line_number':8410,'multiline':False]['text':' Push a SourceParseContext on to the stack.','line_number':8414,'multiline':False]['text':' newDirectives = ','line_number':8416,'multiline':True]['text':' Static class blocks are code-generated as if they were static field','line_number':8427,'multiline':False]['text':' initializers, so we bump the staticFields count here, which ensures','line_number':8428,'multiline':False]['text':' .staticInitializers is noted as used.','line_number':8429,'multiline':False]['text':' Create a ListNode for the parameters + body (there are no parameters).','line_number':8452,'multiline':False]['text':' Create the top-level field initializer node.','line_number':8504,'multiline':False]['text':' Create the FunctionBox and link it to the function object.','line_number':8510,'multiline':False]['text':' We can't use setFunctionStartAtCurrentToken because that uses pos().begin,','line_number':8521,'multiline':False]['text':' which is incorrect for fields without initializers (pos() points to the','line_number':8522,'multiline':False]['text':' field identifier)','line_number':8523,'multiline':False]['text':' Push a SourceParseContext on to the stack.','line_number':8526,'multiline':False]['text':' newDirectives = ','line_number':8528,'multiline':True]['text':' Parse the expression for the field initializer.','line_number':8537,'multiline':False]['text':' Update the end position of the parse node.','line_number':8556,'multiline':False]['text':' Create a ListNode for the parameters + body (there are no parameters).','line_number':8560,'multiline':False]['text':' Build `this.field` expression.','line_number':8574,'multiline':False]['text':' See BytecodeEmitter::emitCreateFieldKeys for an explanation of what','line_number':8584,'multiline':False]['text':' .fieldKeys means and its purpose.','line_number':8585,'multiline':False]['text':' It would be nice if we could tweak this here such that only if','line_number':8622,'multiline':False]['text':' HasHeritage::Yes we end up emitting CheckPrivateField, but otherwise we','line_number':8623,'multiline':False]['text':' emit InitElem -- this is an optimization to minimize HasOwn checks','line_number':8624,'multiline':False]['text':' in InitElem for classes without heritage.','line_number':8625,'multiline':False]['text':'','line_number':8626,'multiline':False]['text':' Further tweaking would be to ultimately only do CheckPrivateField for the','line_number':8627,'multiline':False]['text':' -first- field in a derived class, which would suffice to match the','line_number':8628,'multiline':False]['text':' semantic check.','line_number':8629,'multiline':False]['text':' Synthesize an property init.','line_number':8661,'multiline':False]['text':' Set the function's body to the field assignment.','line_number':8685,'multiline':False]['text':' Destructuring continues a let declaration.','line_number':8716,'multiline':False]['text':' A "let" edge case deserves special comment.  Consider this:','line_number':8721,'multiline':False]['text':'','line_number':8722,'multiline':False]['text':'   let     // not an ASI opportunity','line_number':8723,'multiline':False]['text':'   let;','line_number':8724,'multiline':False]['text':'','line_number':8725,'multiline':False]['text':' Static semantics in 13.3.1.1 turn a LexicalDeclaration that binds','line_number':8726,'multiline':False]['text':' "let" into an early error.  Does this retroactively permit ASI so','line_number':8727,'multiline':False]['text':' that we should parse this as two ExpressionStatements?   No.  ASI','line_number':8728,'multiline':False]['text':' resolves during parsing.  Static semantics only apply to the full','line_number':8729,'multiline':False]['text':' parse tree with ASI applied.  No backsies!','line_number':8730,'multiline':False]['text':' Otherwise a let declaration must have a name.','line_number':8732,'multiline':False]['text':' BlockStatement[?Yield, ?Return]','line_number':8766,'multiline':False]['text':' VariableStatement[?Yield]','line_number':8770,'multiline':False]['text':' EmptyStatement','line_number':8774,'multiline':False]['text':' ExpressionStatement[?Yield].','line_number':8778,'multiline':False]['text':' Don't use a ternary operator here due to obscure linker issues','line_number':8781,'multiline':False]['text':' around using static consts in the arms of a ternary.','line_number':8782,'multiline':False]['text':' If we encounter an await in a module, and the module is not marked','line_number':8803,'multiline':False]['text':' as async, mark the module as async.','line_number':8804,'multiline':False]['text':' Avoid getting next token with SlashIsDiv.','line_number':8816,'multiline':False]['text':' |let| here can only be an Identifier, not a declaration.  Give nicer','line_number':8830,'multiline':False]['text':' errors for declaration-looking typos.','line_number':8831,'multiline':False]['text':' Enforce ExpressionStatement's 'let [' lookahead restriction.','line_number':8836,'multiline':False]['text':' 'let {' and 'let foo' aren't completely forbidden, if ASI','line_number':8840,'multiline':False]['text':' causes 'let' to be the entire Statement.  But if they're','line_number':8841,'multiline':False]['text':' same-line, we can aggressively give a better error message.','line_number':8842,'multiline':False]['text':'','line_number':8843,'multiline':False]['text':' Note that this ignores 'yield' as TokenKind::Yield: we'll handle it','line_number':8844,'multiline':False]['text':' correctly but with a worse error message.','line_number':8845,'multiline':False]['text':' Peek only on the same line: ExpressionStatement's lookahead','line_number':8863,'multiline':False]['text':' restriction is phrased as','line_number':8864,'multiline':False]['text':'','line_number':8865,'multiline':False]['text':'   [lookahead  { '{',','line_number':8866,'multiline':False]['text':'                  function,','line_number':8867,'multiline':False]['text':'                  async [no LineTerminator here] function,','line_number':8868,'multiline':False]['text':'                  class,','line_number':8869,'multiline':False]['text':'                  let '[' }]','line_number':8870,'multiline':False]['text':'','line_number':8871,'multiline':False]['text':' meaning that code like this is valid:','line_number':8872,'multiline':False]['text':'','line_number':8873,'multiline':False]['text':'   if (true)','line_number':8874,'multiline':False]['text':'     async       // ASI opportunity','line_number':8875,'multiline':False]['text':'   function clownshoes() {}','line_number':8876,'multiline':False]['text':' Otherwise this |async| begins an ExpressionStatement or is a','line_number':8887,'multiline':False]['text':' label name.','line_number':8888,'multiline':False]['text':' NOTE: It's unfortunately allowed to have a label named 'let' in','line_number':8891,'multiline':False]['text':'       non-strict code.  ','line_number':8892,'multiline':False]['text':' IfStatement[?Yield, ?Return]','line_number':8903,'multiline':False]['text':' BreakableStatement[?Yield, ?Return]','line_number':8907,'multiline':False]['text':'','line_number':8908,'multiline':False]['text':' BreakableStatement[Yield, Return]:','line_number':8909,'multiline':False]['text':'   IterationStatement[?Yield, ?Return]','line_number':8910,'multiline':False]['text':'   SwitchStatement[?Yield, ?Return]','line_number':8911,'multiline':False]['text':' ContinueStatement[?Yield]','line_number':8924,'multiline':False]['text':' BreakStatement[?Yield]','line_number':8928,'multiline':False]['text':' [+Return] ReturnStatement[?Yield]','line_number':8932,'multiline':False]['text':' The Return parameter is only used here, and the effect is easily','line_number':8934,'multiline':False]['text':' detected this way, so don't bother passing around an extra parameter','line_number':8935,'multiline':False]['text':' everywhere.','line_number':8936,'multiline':False]['text':' WithStatement[?Yield, ?Return]','line_number':8943,'multiline':False]['text':' LabelledStatement[?Yield, ?Return]','line_number':8947,'multiline':False]['text':' This is really handled by default and TokenKind::Yield cases above.','line_number':8948,'multiline':False]['text':' ThrowStatement[?Yield]','line_number':8950,'multiline':False]['text':' TryStatement[?Yield, ?Return]','line_number':8954,'multiline':False]['text':' DebuggerStatement','line_number':8958,'multiline':False]['text':' |function| is forbidden by lookahead restriction (unless as child','line_number':8962,'multiline':False]['text':' statement of |if| or |else|, but Parser::consequentOrAlternative','line_number':8963,'multiline':False]['text':' handles that).','line_number':8964,'multiline':False]['text':' |class| is also forbidden by lookahead restriction.','line_number':8969,'multiline':False]['text':' ImportDeclaration (only inside modules)','line_number':8974,'multiline':False]['text':' ExportDeclaration (only inside modules)','line_number':8978,'multiline':False]['text':' Miscellaneous error cases arguably better caught here than elsewhere.','line_number':8982,'multiline':False]['text':' NOTE: default case handled in the ExpressionStatement section.','line_number':8992,'multiline':False]['text':' = false ','line_number':8999,'multiline':True]['text':' BlockStatement[?Yield, ?Return]','line_number':9013,'multiline':False]['text':' VariableStatement[?Yield]','line_number':9017,'multiline':False]['text':' EmptyStatement','line_number':9021,'multiline':False]['text':' ExpressionStatement[?Yield].','line_number':9025,'multiline':False]['text':'','line_number':9026,'multiline':False]['text':' These should probably be handled by a single ExpressionStatement','line_number':9027,'multiline':False]['text':' function in a default, not split up this way.','line_number':9028,'multiline':False]['text':' Don't use a ternary operator here due to obscure linker issues','line_number':9040,'multiline':False]['text':' around using static consts in the arms of a ternary.','line_number':9041,'multiline':False]['text':' If we encounter an await in a module, and the module is not marked','line_number':9062,'multiline':False]['text':' as async, mark the module as async.','line_number':9063,'multiline':False]['text':' Avoid getting next token with SlashIsDiv.','line_number':9075,'multiline':False]['text':' IfStatement[?Yield, ?Return]','line_number':9116,'multiline':False]['text':' BreakableStatement[?Yield, ?Return]','line_number':9120,'multiline':False]['text':'','line_number':9121,'multiline':False]['text':' BreakableStatement[Yield, Return]:','line_number':9122,'multiline':False]['text':'   IterationStatement[?Yield, ?Return]','line_number':9123,'multiline':False]['text':'   SwitchStatement[?Yield, ?Return]','line_number':9124,'multiline':False]['text':' ContinueStatement[?Yield]','line_number':9137,'multiline':False]['text':' BreakStatement[?Yield]','line_number':9141,'multiline':False]['text':' [+Return] ReturnStatement[?Yield]','line_number':9145,'multiline':False]['text':' The Return parameter is only used here, and the effect is easily','line_number':9147,'multiline':False]['text':' detected this way, so don't bother passing around an extra parameter','line_number':9148,'multiline':False]['text':' everywhere.','line_number':9149,'multiline':False]['text':' WithStatement[?Yield, ?Return]','line_number':9156,'multiline':False]['text':' LabelledStatement[?Yield, ?Return]','line_number':9160,'multiline':False]['text':' This is really handled by default and TokenKind::Yield cases above.','line_number':9161,'multiline':False]['text':' ThrowStatement[?Yield]','line_number':9163,'multiline':False]['text':' TryStatement[?Yield, ?Return]','line_number':9167,'multiline':False]['text':' DebuggerStatement','line_number':9171,'multiline':False]['text':' Declaration[Yield]:','line_number':9175,'multiline':False]['text':'   HoistableDeclaration[?Yield, ~Default]','line_number':9177,'multiline':False]['text':'   ClassDeclaration[?Yield, ~Default]','line_number':9181,'multiline':False]['text':'   LexicalDeclaration[In, ?Yield]','line_number':9185,'multiline':False]['text':'     LetOrConst BindingList[?In, ?Yield]','line_number':9186,'multiline':False]['text':' [In] is the default behavior, because for-loops specially parse','line_number':9188,'multiline':False]['text':' their heads to handle |in| in this situation.','line_number':9189,'multiline':False]['text':' ImportDeclaration (only inside modules)','line_number':9192,'multiline':False]['text':' ExportDeclaration (only inside modules)','line_number':9196,'multiline':False]['text':' Miscellaneous error cases arguably better caught here than elsewhere.','line_number':9200,'multiline':False]['text':' NOTE: default case handled in the ExpressionStatement section.','line_number':9210,'multiline':False]['text':' = nullptr ','line_number':9218,'multiline':True]['text':' = PredictUninvoked ','line_number':9219,'multiline':True]['text':' Trailing comma before the closing parenthesis is valid in an arrow','line_number':9240,'multiline':False]['text':' function parameters list: `(a, b, ) => body`. Check if we are','line_number':9241,'multiline':False]['text':' directly under CoverParenthesizedExpressionAndArrowParameterList,','line_number':9242,'multiline':False]['text':' and the next two tokens are closing parenthesis and arrow. If all','line_number':9243,'multiline':False]['text':' are present allow the trailing comma.','line_number':9244,'multiline':False]['text':' put back right paren','line_number':9264,'multiline':False]['text':' Additional calls to assignExpr should not reuse the possibleError','line_number':9269,'multiline':False]['text':' which had been passed into the function. Otherwise we would lose','line_number':9270,'multiline':False]['text':' information needed to determine whether or not we're dealing with','line_number':9271,'multiline':False]['text':' a non-recoverable situation.','line_number':9272,'multiline':False]['text':' Report any pending expression error.','line_number':9281,'multiline':False]['text':' This list must be kept in the same order in several places:','line_number':9308,'multiline':False]['text':'   - The binary operators in ParseNode.h ,','line_number':9309,'multiline':False]['text':'   - the binary operators in TokenKind.h','line_number':9310,'multiline':False]['text':'   - the JSOp code list in BytecodeEmitter.cpp','line_number':9311,'multiline':False]['text':' ParseNodeKind::Coalesce ','line_number':9313,'multiline':True]['text':' ParseNodeKind::Or ','line_number':9314,'multiline':True]['text':' ParseNodeKind::And ','line_number':9315,'multiline':True]['text':' ParseNodeKind::BitOr ','line_number':9316,'multiline':True]['text':' ParseNodeKind::BitXor ','line_number':9317,'multiline':True]['text':' ParseNodeKind::BitAnd ','line_number':9318,'multiline':True]['text':' ParseNodeKind::StrictEq ','line_number':9319,'multiline':True]['text':' ParseNodeKind::Eq ','line_number':9320,'multiline':True]['text':' ParseNodeKind::StrictNe ','line_number':9321,'multiline':True]['text':' ParseNodeKind::Ne ','line_number':9322,'multiline':True]['text':' ParseNodeKind::Lt ','line_number':9323,'multiline':True]['text':' ParseNodeKind::Le ','line_number':9324,'multiline':True]['text':' ParseNodeKind::Gt ','line_number':9325,'multiline':True]['text':' ParseNodeKind::Ge ','line_number':9326,'multiline':True]['text':' ParseNodeKind::InstanceOf ','line_number':9327,'multiline':True]['text':' ParseNodeKind::In ','line_number':9328,'multiline':True]['text':' ParseNodeKind::PrivateIn ','line_number':9329,'multiline':True]['text':' ParseNodeKind::Lsh ','line_number':9330,'multiline':True]['text':' ParseNodeKind::Rsh ','line_number':9331,'multiline':True]['text':' ParseNodeKind::Ursh ','line_number':9332,'multiline':True]['text':' ParseNodeKind::Add ','line_number':9333,'multiline':True]['text':' ParseNodeKind::Sub ','line_number':9334,'multiline':True]['text':' ParseNodeKind::Star ','line_number':9335,'multiline':True]['text':' ParseNodeKind::Div ','line_number':9336,'multiline':True]['text':' ParseNodeKind::Mod ','line_number':9337,'multiline':True]['text':' ParseNodeKind::Pow ','line_number':9338,'multiline':True]['text':' Everything binds tighter than ParseNodeKind::Limit, because we want','line_number':9344,'multiline':False]['text':' to reduce all nodes to a single node when we reach a token that is not','line_number':9345,'multiline':False]['text':' another binary operator.','line_number':9346,'multiline':False]['text':' Shift-reduce parser for the binary operator part of the JS expression','line_number':9365,'multiline':False]['text':' syntax.','line_number':9366,'multiline':False]['text':' Conceptually there's just one stack, a stack of pairs (lhs, op).','line_number':9368,'multiline':False]['text':' It's implemented using two separate arrays, though.','line_number':9369,'multiline':False]['text':' If a binary operator follows, consume it and compute the','line_number':9386,'multiline':False]['text':' corresponding operator.','line_number':9387,'multiline':False]['text':' Ensure that if we have a private name lhs we are legally constructing a','line_number':9393,'multiline':False]['text':' `#x in obj` expessions:','line_number':9394,'multiline':False]['text':' We're definitely not in a destructuring context, so report any','line_number':9405,'multiline':False]['text':' pending expression error now.','line_number':9406,'multiline':False]['text':' Report an error for unary expressions on the LHS of **.','line_number':9413,'multiline':False]['text':' In the case that the `??` is on the left hand side of the','line_number':9423,'multiline':False]['text':' expression: Disallow Mixing of ?? and other logical operators (||','line_number':9424,'multiline':False]['text':' and &&) unless one expression is parenthesized','line_number':9425,'multiline':False]['text':' If we have not detected a mixing error at this point, record that','line_number':9430,'multiline':False]['text':' we have an unparenthesized expression, in case we have one later.','line_number':9431,'multiline':False]['text':' If we have not detected a mixing error at this point, record that','line_number':9440,'multiline':False]['text':' we have an unparenthesized expression, in case we have one later.','line_number':9441,'multiline':False]['text':' if the LHS is a private name, and the operator is In,','line_number':9446,'multiline':False]['text':' ensure we're construcing an ergnomic brand check of','line_number':9447,'multiline':False]['text':' '#x in y', rather than having a higher precedence operator','line_number':9448,'multiline':False]['text':' like + cause a different reduction, such as','line_number':9449,'multiline':False]['text':' 1 + #x in y.','line_number':9450,'multiline':False]['text':' do nothing in other cases','line_number':9463,'multiline':False]['text':' From this point on, destructuring defaults are definitely an error.','line_number':9478,'multiline':False]['text':' If pnk has precedence less than or equal to another operator on the','line_number':9481,'multiline':False]['text':' stack, reduce. This combines nodes on the stack until we form the','line_number':9482,'multiline':False]['text':' actual lhs of pnk.','line_number':9483,'multiline':False]['text':'','line_number':9484,'multiline':False]['text':' The >= in this condition works because it is appendOrCreateList's','line_number':9485,'multiline':False]['text':' job to decide if the operator in question is left- or','line_number':9486,'multiline':False]['text':' right-associative, and build the corresponding tree.','line_number':9487,'multiline':False]['text':' Had the next token been a Div, we would have consumed it. So there's no','line_number':9510,'multiline':False]['text':' ambiguity if we later (after ASI) re-get this token with SlashIsRegExp.','line_number':9511,'multiline':False]['text':' = nullptr ','line_number':9561,'multiline':True]['text':' = PredictUninvoked ','line_number':9562,'multiline':True]['text':' It's very common at this point to have a "detectably simple" expression,','line_number':9568,'multiline':False]['text':' i.e. a name/number/string token followed by one of the following tokens','line_number':9569,'multiline':False]['text':' that obviously isn't part of an expression: , ; : ) ] }','line_number':9570,'multiline':False]['text':'','line_number':9571,'multiline':False]['text':' (In Parsemark this happens 81.4% of the time;  in code with large','line_number':9572,'multiline':False]['text':' numeric arrays, such as some Kraken benchmarks, it happens more often.)','line_number':9573,'multiline':False]['text':'','line_number':9574,'multiline':False]['text':' In such cases, we can avoid the full expression parsing route through','line_number':9575,'multiline':False]['text':' assignExpr(), condExpr(), orExpr(), unaryExpr(), memberExpr(), and','line_number':9576,'multiline':False]['text':' primaryExpr().','line_number':9577,'multiline':False]['text':' This only handles identifiers that *never* have special meaning anywhere','line_number':9588,'multiline':False]['text':' in the language.  Contextual keywords, reserved words in strict mode,','line_number':9589,'multiline':False]['text':' and other hard cases are handled outside this fast path.','line_number':9590,'multiline':False]['text':' Save the tokenizer state in case we find an arrow function and have to','line_number':9641,'multiline':False]['text':' rewind.','line_number':9642,'multiline':False]['text':' Check yield validity here.','line_number':9659,'multiline':False]['text':' |async [no LineTerminator] of| without being followed by => is only','line_number':9671,'multiline':False]['text':' possible in for-await-of loops, e.g. |for await (async of [])|. Pretend','line_number':9672,'multiline':False]['text':' the |async| token was parsed an identifier reference and then proceed','line_number':9673,'multiline':False]['text':' with the rest of this function.','line_number':9674,'multiline':False]['text':' unget the binding identifier','line_number':9676,'multiline':False]['text':' The next token is guaranteed to never be a Div (, because it's an','line_number':9678,'multiline':False]['text':' identifier), so it's okay to re-get the token with SlashIsRegExp.','line_number':9679,'multiline':False]['text':' Use SlashIsRegExp here because the ConditionalExpression parsed above','line_number':9699,'multiline':False]['text':' could be the entirety of this AssignmentExpression, and then ASI','line_number':9700,'multiline':False]['text':' permits this token to be a regular expression.','line_number':9701,'multiline':False]['text':' Rewind to reparse as an arrow function.','line_number':9710,'multiline':False]['text':'','line_number':9711,'multiline':False]['text':' Note: We do not call CompilationState::rewind here because parsing','line_number':9712,'multiline':False]['text':' during delazification will see the same rewind and need the same sequence','line_number':9713,'multiline':False]['text':' of inner functions to skip over.','line_number':9714,'multiline':False]['text':' Instead, we mark inner functions as "ghost".','line_number':9715,'multiline':False]['text':'','line_number':9716,'multiline':False]['text':' See GHOST_FUNCTION in FunctionFlags.h for more details.','line_number':9717,'multiline':False]['text':' The AsyncArrowFunction production are','line_number':9739,'multiline':False]['text':'   async [no LineTerminator here] AsyncArrowBindingIdentifier ...','line_number':9740,'multiline':False]['text':'   async [no LineTerminator here] ArrowFormalParameters ...','line_number':9741,'multiline':False]['text':' Verify the left-hand side expression doesn't have a forbidden form.','line_number':9829,'multiline':False]['text':' |chars| is "arguments" or "eval" here.','line_number':9841,'multiline':False]['text':' Permitted: no additional testing/fixup needed.','line_number':9847,'multiline':False]['text':' We don't have to worry about backward compatibility issues with the new','line_number':9849,'multiline':False]['text':' compound assignment operators, so we always throw here. Also that way we','line_number':9850,'multiline':False]['text':' don't have to worry if |f() &&= expr| should always throw an error or','line_number':9851,'multiline':False]['text':' only if |f()| returns true.','line_number':9852,'multiline':False]['text':' Permitted: no additional testing/fixup needed.','line_number':9909,'multiline':False]['text':' Assignment to function calls is forbidden in ES6.  We're still','line_number':9911,'multiline':False]['text':' somewhat concerned about sites using this in dead code, so forbid it','line_number':9912,'multiline':False]['text':' only in strict mode code.','line_number':9913,'multiline':False]['text':' = nullptr ','line_number':9939,'multiline':True]['text':' = PredictUninvoked ','line_number':9940,'multiline':True]['text':' allowCallSyntax = ','line_number':9949,'multiline':True]['text':' = nullptr ','line_number':10050,'multiline':True]['text':' = PredictUninvoked ','line_number':10051,'multiline':True]['text':' = PrivateNameProhibited ','line_number':10052,'multiline':True]['text':' The |typeof| operator is specially parsed to distinguish its','line_number':10076,'multiline':False]['text':' application to a name, from its application to a non-name','line_number':10077,'multiline':False]['text':' expression:','line_number':10078,'multiline':False]['text':'','line_number':10079,'multiline':False]['text':'   // Looks up the name, doesn't find it and so evaluates to','line_number':10080,'multiline':False]['text':'   // "undefined".','line_number':10081,'multiline':False]['text':'   assertEq(typeof nonExistentName, "undefined");','line_number':10082,'multiline':False]['text':'','line_number':10083,'multiline':False]['text':'   // Evaluates expression, triggering a runtime ReferenceError for','line_number':10084,'multiline':False]['text':'   // the undefined name.','line_number':10085,'multiline':False]['text':'   typeof (1, nonExistentName);','line_number':10086,'multiline':False]['text':' Per spec, deleting most unary expressions is valid -- it simply','line_number':10132,'multiline':False]['text':' returns true -- except for two cases:','line_number':10133,'multiline':False]['text':' 1. `var x; ...; delete x` is a syntax error in strict mode.','line_number':10134,'multiline':False]['text':' 2. Private fields cannot be deleted.','line_number':10135,'multiline':False]['text':' If we encounter an await in a module, mark it as async.','line_number':10152,'multiline':False]['text':' Don't look across a newline boundary for a postfix incop. ','line_number':10186,'multiline':True]['text':' = nullptr ','line_number':10232,'multiline':True]['text':' Check for new expression first. ','line_number':10333,'multiline':True]['text':' Make sure this wasn't a |new.target| in disguise.','line_number':10336,'multiline':False]['text':' Gotten by tryNewTarget','line_number':10344,'multiline':False]['text':' allowCallSyntax = ','line_number':10347,'multiline':True]['text':' possibleError = ','line_number':10348,'multiline':True]['text':' If we have encountered an optional chain, in the form of `new','line_number':10353,'multiline':False]['text':' ClassName?.()` then we need to throw, as this is disallowed by the','line_number':10354,'multiline':False]['text':' spec.','line_number':10355,'multiline':False]['text':' = OptionalKind::NonOptional ','line_number':10516,'multiline':True]['text':' = OptionalKind::NonOptional ','line_number':10540,'multiline':True]['text':' Cannot access private fields on super.','line_number':10544,'multiline':False]['text':' = OptionalKind::NonOptional ','line_number':10565,'multiline':True]['text':' Despite the fact that it's impossible to have |super()| in a','line_number':10591,'multiline':False]['text':' generator, we still inherit the yieldHandling of the','line_number':10592,'multiline':False]['text':' memberExpression, per spec. Curious.','line_number':10593,'multiline':False]['text':' = nullptr ','line_number':10616,'multiline':True]['text':' = OptionalKind::NonOptional ','line_number':10617,'multiline':True]['text':' Use the JSOp::Fun{Apply,Call} optimizations given the right','line_number':10632,'multiline':False]['text':' syntax.','line_number':10633,'multiline':False]['text':' |async (| can be the start of an async arrow','line_number':10642,'multiline':False]['text':' function, so we need to defer reporting possible','line_number':10643,'multiline':False]['text':' errors from destructuring syntax. To give better','line_number':10644,'multiline':False]['text':' error messages, we only allow the AsyncArrowHead','line_number':10645,'multiline':False]['text':' part of the CoverCallExpressionAndAsyncArrowHead','line_number':10646,'multiline':False]['text':' syntax when the initial name is "async".','line_number':10647,'multiline':False]['text':' Select the right Eval op and flag pc_ as having a','line_number':10650,'multiline':False]['text':' direct eval.','line_number':10651,'multiline':False]['text':' In non-strict mode code, direct calls to eval can','line_number':10656,'multiline':False]['text':' add variables to the call object.','line_number':10657,'multiline':False]['text':' If we're in a method, mark the method as requiring','line_number':10662,'multiline':False]['text':' support for 'super', since direct eval code can use','line_number':10663,'multiline':False]['text':' it. (If we're not in a method, that's fine, so','line_number':10664,'multiline':False]['text':' ignore the return value.)','line_number':10665,'multiline':False]['text':' = TokenKind::Limit ','line_number':10714,'multiline':True]['text':' All non-reserved word kinds are folded into TokenKind::Limit in','line_number':10719,'multiline':False]['text':' ReservedWordTokenKind and the following code.','line_number':10720,'multiline':False]['text':' Either TokenKind::Name or TokenKind::PrivateName','line_number':10736,'multiline':False]['text':' = TokenKind::Limit ','line_number':10799,'multiline':True]['text':' ES 2017 draft 12.1.1.','line_number':10823,'multiline':False]['text':'   StringValue of IdentifierName normalizes any Unicode escape sequences','line_number':10824,'multiline':False]['text':'   in IdentifierName hence such escapes cannot be used to write an','line_number':10825,'multiline':False]['text':'   Identifier whose code point sequence is the same as a ReservedWord.','line_number':10826,'multiline':False]['text':'','line_number':10827,'multiline':False]['text':' Use const ParserName* instead of TokenKind to reflect the normalization.','line_number':10828,'multiline':False]['text':' Unless the name contains escapes, we can reuse the current TokenKind','line_number':10830,'multiline':False]['text':' to determine if the name is a restricted identifier.','line_number':10831,'multiline':False]['text':' Create the regexp and check its syntax.','line_number':10921,'multiline':False]['text':' Verify that the Regexp will syntax parse when the time comes to','line_number':10931,'multiline':False]['text':' instantiate it. If we have already done a syntax parse, we can','line_number':10932,'multiline':False]['text':' skip this.','line_number':10933,'multiline':False]['text':' Only check the regexp's syntax, but don't create a regexp object.','line_number':10966,'multiline':False]['text':' The token's charBuffer contains the DecimalIntegerLiteral or','line_number':10994,'multiline':False]['text':' NonDecimalIntegerLiteral production, and as such does not include the','line_number':10995,'multiline':False]['text':' BigIntLiteralSuffix (the trailing "n").  Note that NonDecimalIntegerLiteral','line_number':10996,'multiline':False]['text':' productions start with 0[bBoOxX], indicating binary/octal/hex.','line_number':10997,'multiline':False]['text':' Should the operations below fail, the buffer held by data will','line_number':11021,'multiline':False]['text':' be cleaned up by the CompilationState destructor.','line_number':11022,'multiline':False]['text':' The tokenizer has already checked the syntax of the bigint.','line_number':11029,'multiline':False]['text':' |exprPossibleError| is the PossibleError state within |expr|,','line_number':11040,'multiline':False]['text':' |possibleError| is the surrounding PossibleError state.','line_number':11041,'multiline':False]['text':' Report any pending expression error if we're definitely not in a','line_number':11046,'multiline':False]['text':' destructuring context or the possible destructuring target is a','line_number':11047,'multiline':False]['text':' property accessor.','line_number':11048,'multiline':False]['text':' |expr| may end up as a destructuring assignment target, so we need to','line_number':11053,'multiline':False]['text':' validate it's either a name or can be parsed as a nested destructuring','line_number':11054,'multiline':False]['text':' pattern. Property accessors are also valid assignment targets, but','line_number':11055,'multiline':False]['text':' those are already handled above.','line_number':11056,'multiline':False]['text':' Return early if a pending destructuring error is already present.','line_number':11060,'multiline':False]['text':' Parentheses are forbidden around destructuring *patterns* (but allowed','line_number':11079,'multiline':False]['text':' around names). Use our nicer error message for parenthesized, nested','line_number':11080,'multiline':False]['text':' patterns if nested destructuring patterns are allowed.','line_number':11081,'multiline':False]['text':' GCC 8.0.1 crashes if this is a one-liner.','line_number':11098,'multiline':False]['text':' Return early if a pending destructuring error is already present.','line_number':11103,'multiline':False]['text':' ES2018 draft rev 0719f44aab93215ed9a626b2f45bd34f36916834','line_number':11137,'multiline':False]['text':' 12.15.5 Destructuring Assignment','line_number':11138,'multiline':False]['text':'','line_number':11139,'multiline':False]['text':' AssignmentElement[Yield, Await]:','line_number':11140,'multiline':False]['text':'   DestructuringAssignmentTarget[?Yield, ?Await]','line_number':11141,'multiline':False]['text':'   DestructuringAssignmentTarget[?Yield, ?Await] Initializer[+In,','line_number':11142,'multiline':False]['text':'                                                             ?Yield,','line_number':11143,'multiline':False]['text':'                                                             ?Await]','line_number':11144,'multiline':False]['text':' If |expr| is an assignment element with an initializer expression, its','line_number':11146,'multiline':False]['text':' destructuring assignment target was already validated in assignExpr().','line_number':11147,'multiline':False]['text':' Otherwise we need to check that |expr| is a valid destructuring target.','line_number':11148,'multiline':False]['text':' Report any pending expression error if we're definitely not in a','line_number':11150,'multiline':False]['text':' destructuring context.','line_number':11151,'multiline':False]['text':'
     * Mark empty arrays as non-constant, since we cannot easily
     * determine their type.
     ','line_number':11181,'multiline':True]['text':' PropertyName[Yield, Await]:','line_number':11289,'multiline':False]['text':'   LiteralPropertyName','line_number':11290,'multiline':False]['text':'   ComputedPropertyName[?Yield, ?Await]','line_number':11291,'multiline':False]['text':'','line_number':11292,'multiline':False]['text':' LiteralPropertyName:','line_number':11293,'multiline':False]['text':'   IdentifierName','line_number':11294,'multiline':False]['text':'   StringLiteral','line_number':11295,'multiline':False]['text':'   NumericLiteral','line_number':11296,'multiline':False]['text':' True if `kind` can be the first token of a PropertyName.','line_number':11356,'multiline':False]['text':' We're parsing an object literal, class, or destructuring pattern;','line_number':11370,'multiline':False]['text':' propertyNameContext tells which one. This method parses any of the','line_number':11371,'multiline':False]['text':' following, storing the corresponding PropertyType in `*propType` to tell','line_number':11372,'multiline':False]['text':' the caller what we parsed:','line_number':11373,'multiline':False]['text':'','line_number':11374,'multiline':False]['text':'     async [no LineTerminator here] PropertyName','line_number':11375,'multiline':False]['text':'                            ==> PropertyType::AsyncMethod','line_number':11376,'multiline':False]['text':'     async [no LineTerminator here] * PropertyName','line_number':11377,'multiline':False]['text':'                            ==> PropertyType::AsyncGeneratorMethod','line_number':11378,'multiline':False]['text':'     * PropertyName         ==> PropertyType::GeneratorMethod','line_number':11379,'multiline':False]['text':'     get PropertyName       ==> PropertyType::Getter','line_number':11380,'multiline':False]['text':'     set PropertyName       ==> PropertyType::Setter','line_number':11381,'multiline':False]['text':'     PropertyName :         ==> PropertyType::Normal','line_number':11382,'multiline':False]['text':'     PropertyName           ==> see below','line_number':11383,'multiline':False]['text':'','line_number':11384,'multiline':False]['text':' In the last case, where there's not a `:` token to consume, we peek at','line_number':11385,'multiline':False]['text':' (but don't consume) the next token to decide how to set `*propType`.','line_number':11386,'multiline':False]['text':'','line_number':11387,'multiline':False]['text':'     `,` or `}`             ==> PropertyType::Shorthand','line_number':11388,'multiline':False]['text':'     `(`                    ==> PropertyType::Method','line_number':11389,'multiline':False]['text':'     `=`, not in a class    ==> PropertyType::CoverInitializedName','line_number':11390,'multiline':False]['text':'     '=', in a class        ==> PropertyType::Field','line_number':11391,'multiline':False]['text':'     any token, in a class  ==> PropertyType::Field (ASI)','line_number':11392,'multiline':False]['text':'','line_number':11393,'multiline':False]['text':' The caller must check `*propType` and throw if whatever we parsed isn't','line_number':11394,'multiline':False]['text':' allowed here (for example, a getter in a destructuring pattern).','line_number':11395,'multiline':False]['text':'','line_number':11396,'multiline':False]['text':' This method does *not* match `static` (allowed in classes) or `...`','line_number':11397,'multiline':False]['text':' (allowed in object literals and patterns). The caller must take care of','line_number':11398,'multiline':False]['text':' those before calling this method.','line_number':11399,'multiline':False]['text':' Accept `async` and/or `*`, indicating an async or generator method;','line_number':11409,'multiline':False]['text':' or `get` or `set`, indicating an accessor.','line_number':11410,'multiline':False]['text':' `async` is also a PropertyName by itself (it's a conditional keyword),','line_number':11417,'multiline':False]['text':' so peek at the next token to see if we're really looking at a method.','line_number':11418,'multiline':False]['text':' We have parsed |get| or |set|. Look for an accessor property','line_number':11439,'multiline':False]['text':' name next.','line_number':11440,'multiline':False]['text':' Grab the next token following the property/method name.','line_number':11458,'multiline':False]['text':' (If this isn't a colon, we're going to either put it back or throw.)','line_number':11459,'multiline':False]['text':' Directly report the error when we're definitely not','line_number':11631,'multiline':False]['text':' in a destructuring context.','line_number':11632,'multiline':False]['text':' Otherwise delay error reporting until we've','line_number':11638,'multiline':False]['text':' determined whether or not we're destructuring.','line_number':11639,'multiline':False]['text':' This occurs *only* if we observe PropertyType::Normal!','line_number':11645,'multiline':False]['text':' Only |__proto__: v| mutates [[Prototype]]. Getters,','line_number':11646,'multiline':False]['text':' setters, method/generator definitions, computed','line_number':11647,'multiline':False]['text':' property name versions of all of these, and shorthands','line_number':11648,'multiline':False]['text':' do not.','line_number':11649,'multiline':False]['text':'
         * Support, e.g., |({x, y} = o)| as destructuring shorthand
         * for |({x: x, y: y} = o)|, and |var o = {x, y}| as
         * initializer shorthand for |var o = {x: x, y: y}|.
         ','line_number':11664,'multiline':True]['text':'
         * Support, e.g., |({x=1, y=2} = o)| as destructuring
         * shorthand with default values, as per ES6 12.14.5
         ','line_number':11688,'multiline':True]['text':' "shorthand default" or "CoverInitializedName" syntax is','line_number':11705,'multiline':False]['text':' only valid in the case of destructuring.','line_number':11706,'multiline':False]['text':' Destructuring defaults are definitely not allowed','line_number':11710,'multiline':False]['text':' in this object literal, because of something the','line_number':11711,'multiline':False]['text':' caller knows about the preceding code. For example,','line_number':11712,'multiline':False]['text':' maybe the preceding token is an operator:','line_number':11713,'multiline':False]['text':' |x + {y=z}|.','line_number':11714,'multiline':False]['text':' Here we set a pending error so that later in the parse,','line_number':11719,'multiline':False]['text':' once we've determined whether or not we're','line_number':11720,'multiline':False]['text':' destructuring, the error can be reported or ignored','line_number':11721,'multiline':False]['text':' appropriately.','line_number':11722,'multiline':False]['text':' |chars| is "arguments" or "eval" here.','line_number':11728,'multiline':False]['text':' |new| expects to look for an operand, so we will honor that.','line_number':11879,'multiline':False]['text':' Don't unget the token, since lookahead cannot handle someone calling','line_number':11885,'multiline':False]['text':' getToken() with a different modifier. Callers should inspect','line_number':11886,'multiline':False]['text':' currentToken().','line_number':11887,'multiline':False]['text':' Not valid expression syntax, but this is valid in an arrow function','line_number':11998,'multiline':False]['text':' with no params: `() => body`.','line_number':11999,'multiline':False]['text':' Now just return something that will allow parsing to continue.','line_number':12012,'multiline':False]['text':' It doesn't matter what; when we reach the =>, we will rewind and','line_number':12013,'multiline':False]['text':' reparse the whole arrow function. See Parser::assignExpr.','line_number':12014,'multiline':False]['text':' Pass |possibleError| to support destructuring in arrow parameters.','line_number':12018,'multiline':False]['text':' This isn't valid expression syntax, but it's valid in an arrow','line_number':12094,'multiline':False]['text':' function as a trailing rest param: `(a, b, ...rest) => body`.  Check','line_number':12095,'multiline':False]['text':' if it's directly under','line_number':12096,'multiline':False]['text':' CoverParenthesizedExpressionAndArrowParameterList, and check for a','line_number':12097,'multiline':False]['text':' name, closing parenthesis, and arrow, and allow it only if all are','line_number':12098,'multiline':False]['text':' present.','line_number':12099,'multiline':False]['text':' Validate, but don't store the pattern right now. The whole arrow','line_number':12111,'multiline':False]['text':' function is reparsed in functionFormalParametersAndBody().','line_number':12112,'multiline':False]['text':' This doesn't check that the provided name is allowed, e.g. if','line_number':12118,'multiline':False]['text':' the enclosing code is strict mode code, any of "let", "yield",','line_number':12119,'multiline':False]['text':' or "arguments" should be prohibited.  Argument-parsing code','line_number':12120,'multiline':False]['text':' handles that.','line_number':12121,'multiline':False]['text':' Advance the scanner for proper error location reporting.','line_number':12142,'multiline':False]['text':' put back right paren','line_number':12149,'multiline':False]['text':' Return an arbitrary expression node. See case TokenKind::RightParen','line_number':12151,'multiline':False]['text':' above.','line_number':12152,'multiline':False]['text':' = nullptr ','line_number':12162,'multiline':True]['text':' namespace js::frontend','line_number':12179,'multiline':False]