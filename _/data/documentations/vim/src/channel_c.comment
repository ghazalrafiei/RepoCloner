['text':' vi:set ts=8 sts=4 sw=4 noet:
 *
 * VIM - Vi IMproved	by Bram Moolenaar
 *
 * Do ":help uganda"  in Vim to read copying and usage conditions.
 * Do ":help credits" in Vim to see a list of people who contributed.
 ','line_number':1,'multiline':True]['text':'
 * Implements communication through a socket or any file handle.
 ','line_number':9,'multiline':True]['text':' TRUE when netbeans is running with a GUI.','line_number':17,'multiline':False]['text':' Note: when making changes here also adjust configure.ac.','line_number':22,'multiline':False]['text':' WinSock API is separated from C API, thus we can't use read(), write(),','line_number':24,'multiline':False]['text':' errno...','line_number':25,'multiline':False]['text':' Support for Unix-domain sockets was added in Windows SDK 17061.','line_number':40,'multiline':False]['text':' Whether we are inside channel_parse_messages() or another situation where it','line_number':73,'multiline':False]['text':' is safe to invoke callbacks.','line_number':74,'multiline':False]['text':' If the pipe overflows while the job does not read the data,','line_number':103,'multiline':False]['text':' WriteFile() will block forever. This abandons the write.','line_number':104,'multiline':False]['text':' WriteFile() returns TRUE but did not write anything. This causes','line_number':118,'multiline':False]['text':' a hang, so bail out.','line_number':119,'multiline':False]['text':' chomp \r or \n','line_number':162,'multiline':False]['text':'
 * The list of all allocated channels.
 ','line_number':181,'multiline':True]['text':'
 * Allocate a new channel.  The refcount is set to 1.
 * The channel isn't actually used until it is opened.
 * Returns NULL if out of memory.
 ','line_number':187,'multiline':True]['text':'
 * Called when the refcount of a channel is zero.
 * Return TRUE if "channel" has a callback and the associated job wasn't
 * killed.
 ','line_number':233,'multiline':True]['text':' If the job was killed the channel is not expected to work anymore.','line_number':245,'multiline':False]['text':' If there is a close callback it may still need to be invoked.','line_number':249,'multiline':False]['text':' If reading from or a buffer it's still useful.','line_number':253,'multiline':False]['text':' If there is no callback then nobody can get readahead.  If the fd is','line_number':257,'multiline':False]['text':' closed and there is no readahead then the callback won't be called.','line_number':258,'multiline':False]['text':'
 * Return TRUE if "channel" is closeable (i.e. all readable fds are closed).
 ','line_number':278,'multiline':True]['text':'
 * Close a channel and free all its resources.
 * The "channel" pointer remains valid.
 ','line_number':287,'multiline':True]['text':'
 * Unlink "channel" from the list of channels and free it.
 ','line_number':299,'multiline':True]['text':'
 * Close a channel and free all its resources if there is no further action
 * possible, there is no callback to be invoked or the associated job was
 * killed.
 * Return TRUE if the channel was freed.
 ','line_number':329,'multiline':True]['text':'
 * Decrement the reference count on "channel" and maybe free it when it goes
 * down to zero.  Don't free it if there is a pending action.
 * Returns TRUE when the channel is no longer referenced.
 ','line_number':346,'multiline':True]['text':' This is invoked from the garbage collector, which only runs at a safe','line_number':365,'multiline':False]['text':' point.','line_number':366,'multiline':False]['text':' Free the channel and ordinary items it contains, but don't','line_number':373,'multiline':False]['text':' recurse into Lists, Dictionaries etc.','line_number':374,'multiline':False]['text':' Free the channel struct itself.','line_number':394,'multiline':False]['text':'
 * Lookup the channel from the socket.  Set "partp" to the fd index.
 * Returns NULL when the socket isn't found.
 ','line_number':402,'multiline':True]['text':'
 * Read a command from netbeans.
 ','line_number':441,'multiline':True]['text':' Return FALSE instead in case the event source is to','line_number':462,'multiline':False]['text':' be removed after this function returns.','line_number':463,'multiline':False]['text':' gets stuck in handling events for a not connected channel','line_number':482,'multiline':False]['text':' Tell notifier we are interested in being called when there is input on','line_number':487,'multiline':False]['text':' the editor connection socket.','line_number':488,'multiline':False]['text':' Tell gdk we are interested in being called when there is input on the','line_number':503,'multiline':False]['text':' editor connection socket.','line_number':504,'multiline':False]['text':'
 * Register any of our file descriptors with the GUI event handling system.
 * Called when the GUI has started.
 ','line_number':547,'multiline':True]['text':' FEAT_GUI','line_number':595,'multiline':False]['text':'
 * For Unix we need to call connect() again after connect() failed.
 * On Win32 one time is sufficient.
 ','line_number':597,'multiline':True]['text':' Make connect() non-blocking.','line_number':631,'multiline':False]['text':' Try connecting to the server.','line_number':648,'multiline':False]['text':' The connection could be established.','line_number':653,'multiline':False]['text':' Limit the waittime to 50 msec.  If it doesn't work within this','line_number':677,'multiline':False]['text':' time we close the socket and try creating it again.','line_number':678,'multiline':False]['text':' If connect() didn't finish then try using select() to wait for the','line_number':681,'multiline':False]['text':' connection to be made. For Win32 always use select() to wait.','line_number':682,'multiline':False]['text':' On Win32: select() is expected to work and wait for up to','line_number':718,'multiline':False]['text':' "waitnow" msec for the socket to be open.','line_number':719,'multiline':False]['text':' On Linux-like systems: See socket(7) for the behavior','line_number':729,'multiline':False]['text':' After putting the socket in non-blocking mode, connect() will','line_number':730,'multiline':False]['text':' return EINPROGRESS, select() will not wait (as if writing is','line_number':731,'multiline':False]['text':' possible), need to use getsockopt() to check if the socket is','line_number':732,'multiline':False]['text':' actually able to connect.','line_number':733,'multiline':False]['text':' We detect a failure to connect when either read and write fds','line_number':734,'multiline':False]['text':' are set.  Use getsockopt() to find out what kind of failure.','line_number':735,'multiline':False]['text':' Did not detect an error, connection is established.','line_number':764,'multiline':False]['text':' The port isn't ready but we also didn't get an error.','line_number':776,'multiline':False]['text':' This happens when the server didn't open the socket','line_number':777,'multiline':False]['text':' yet.  Select() may return early, wait until the remaining','line_number':778,'multiline':False]['text':' "waitnow"  and try again.','line_number':779,'multiline':False]['text':' give it one more try','line_number':791,'multiline':False]['text':' we were interrupted, behave as if timed out','line_number':795,'multiline':False]['text':' We timed out.','line_number':799,'multiline':False]['text':'
 * Open a socket channel to the UNIX socket at "path".
 * Returns the channel for success.
 * Returns NULL for failure.
 ','line_number':818,'multiline':True]['text':'
 * Open a socket channel to "hostname":"port".
 * "waittime" is the time in msec to wait for the connection.
 * When negative wait forever.
 * Returns the channel for success.
 * Returns NULL for failure.
 ','line_number':879,'multiline':True]['text':' Get the server internet address and put into addr structure fill in the','line_number':916,'multiline':False]['text':' socket address structure and connect to server.','line_number':917,'multiline':False]['text':' Set port number manually in order to prevent name resolution services','line_number':927,'multiline':False]['text':' from being invoked in the environment where AI_NUMERICSERV is not','line_number':928,'multiline':False]['text':' defined.','line_number':929,'multiline':False]['text':' On Mac and Solaris a zero timeout almost never works.  Waiting for','line_number':977,'multiline':False]['text':' one millisecond already helps a lot.  Later Mac systems (using IPv6)','line_number':978,'multiline':False]['text':' need more time, 15 milliseconds appears to work well.','line_number':979,'multiline':False]['text':' Let's do it for all systems, because we don't know why this is','line_number':980,'multiline':False]['text':' needed.','line_number':981,'multiline':False]['text':' When using host->h_addr_list[0] directly ubsan warns for it to not','line_number':1006,'multiline':False]['text':' be aligned.  First copy the pointer to avoid that.','line_number':1007,'multiline':False]['text':' On Mac and Solaris a zero timeout almost never works.  At least wait one','line_number':1014,'multiline':False]['text':' millisecond.  Let's do it for all systems, because we don't know why','line_number':1015,'multiline':False]['text':' this is needed.','line_number':1016,'multiline':False]['text':'
 * Prepare buffer "buf" for writing channel output to.
 ','line_number':1056,'multiline':True]['text':'
 * Find a buffer matching "name" or create a new one.
 * Returns NULL if there is something very wrong (error already reported).
 ','line_number':1076,'multiline':True]['text':'
 * Set various properties from an "opt" argument.
 ','line_number':1112,'multiline':True]['text':' writing output to a buffer. Default mode is NL.','line_number':1157,'multiline':False]['text':' if the buffer was deleted or unloaded resurrect it','line_number':1190,'multiline':False]['text':' writing err to a buffer. Default mode is NL.','line_number':1203,'multiline':False]['text':' if the buffer was deleted or unloaded resurrect it','line_number':1237,'multiline':False]['text':'
 * Implements ch_open().
 ','line_number':1249,'multiline':True]['text':' ipv6 address','line_number':1287,'multiline':False]['text':' ipv4 address','line_number':1298,'multiline':False]['text':' strip '[' and ']'','line_number':1317,'multiline':False]['text':' parse options','line_number':1325,'multiline':False]['text':' When using a pty the same FD is set on multiple parts, only','line_number':1365,'multiline':False]['text':' close it when the last reference is closed.','line_number':1366,'multiline':False]['text':' channel is closed, may want to end the job if it was the last','line_number':1380,'multiline':False]['text':' Do not end the job when all output channels are closed, wait until','line_number':1392,'multiline':False]['text':' the job ended.','line_number':1393,'multiline':False]['text':'
 * Sets the job the channel is associated with and associated options.
 * This does not keep a refcount, when the job is freed ch_job is cleared.
 ','line_number':1424,'multiline':True]['text':' Special mode: send last-but-one line when appending a line','line_number':1447,'multiline':False]['text':' to the buffer.','line_number':1448,'multiline':False]['text':'
 * Set the callback for "channel"/"part" for the response with "id".
 ','line_number':1465,'multiline':True]['text':' Need to make a copy to be able to append a NL.','line_number':1500,'multiline':False]['text':'
 * Return TRUE if "channel" can be written to.
 * Returns FALSE if the input is closed or the write would block.
 ','line_number':1520,'multiline':True]['text':' pipe was closed','line_number':1530,'multiline':False]['text':' for testing: block every other attempt to write','line_number':1532,'multiline':False]['text':' TODO: Win32 implementation, probably using WaitForMultipleObjects()','line_number':1538,'multiline':False]['text':'
 * Write any buffer lines to the input channel.
 ','line_number':1589,'multiline':True]['text':' no buffer or using appending','line_number':1601,'multiline':False]['text':' buffer was wiped out or unloaded','line_number':1604,'multiline':False]['text':' Send CTRL-D or "eof_chars" to close stdin on MS-Windows.','line_number':1628,'multiline':False]['text':' Writing is done, no longer need the buffer.','line_number':1633,'multiline':False]['text':' Close the pipe/socket, so that the other side gets EOF.','line_number':1637,'multiline':False]['text':'
 * Handle buffer "buf" being freed, remove it from any channels.
 ','line_number':1645,'multiline':True]['text':'
 * Write any lines waiting to be written to "channel".
 ','line_number':1668,'multiline':True]['text':'
 * Write any lines waiting to be written to a channel.
 ','line_number':1687,'multiline':True]['text':'
 * Write appended lines above the last one in "buf" to the channel.
 ','line_number':1699,'multiline':True]['text':' There could be more than one channel for the buffer, loop over all of','line_number':1708,'multiline':False]['text':' them.','line_number':1709,'multiline':False]['text':' pipe was closed','line_number':1719,'multiline':False]['text':'
 * Invoke the "callback" on channel "channel".
 * This does not redraw but sets channel_need_redraw;
 ','line_number':1745,'multiline':True]['text':'
 * Return the first node from "channel"/"part" without removing it.
 * Returns NULL if there is nothing.
 ','line_number':1765,'multiline':True]['text':'
 * Return a pointer to the first NL in "node".
 * Skips over NUL characters.
 * Returns NULL if there is no NL.
 ','line_number':1777,'multiline':True]['text':'
 * Return the first buffer from channel "channel"/"part" and remove it.
 * The caller must free it.
 * Returns NULL if there is nothing.
 ','line_number':1794,'multiline':True]['text':' dispose of the node but keep the buffer','line_number':1810,'multiline':False]['text':'
 * Returns the whole buffer contents concatenated for "channel"/"part".
 * Replaces NUL bytes with NL.
 ','line_number':1821,'multiline':True]['text':' Concatenate everything into one buffer.','line_number':1834,'multiline':False]['text':' Free all buffers','line_number':1848,'multiline':False]['text':' Returning the length, keep NUL characters.','line_number':1857,'multiline':False]['text':' Turn all NUL into NL, so that the result can be used as a string.','line_number':1862,'multiline':False]['text':' crush the escape sequence OSC 0/1/2: ESC ]0;','line_number':1871,'multiline':False]['text':' '\a' becomes a NL','line_number':1877,'multiline':False]['text':' BEL is zero width characters, suppress display mistake','line_number':1880,'multiline':False]['text':' ConPTY (after 10.0.18317) requires advance checking','line_number':1881,'multiline':False]['text':'
 * Consume "len" bytes from the head of "node".
 * Caller must check these bytes are available.
 ','line_number':1893,'multiline':True]['text':'
 * Collapses the first and second buffer for "channel"/"part".
 * Returns FAIL if nothing was done.
 * When "want_nl" is TRUE collapse more buffers until a NL is found.
 * When the channel part mode is "lsp", collapse all the buffers as the http
 * header and the JSON content can be present in multiple buffers.
 ','line_number':1909,'multiline':True]['text':' out of memory','line_number':1944,'multiline':False]['text':' dispose of the collapsed nodes and their buffers','line_number':1959,'multiline':False]['text':'
 * Store "buf[len]" on "channel"/"part".
 * When "prepend" is TRUE put in front, otherwise append at the end.
 * Returns OK or FAIL.
 ','line_number':1974,'multiline':True]['text':' out of memory','line_number':1990,'multiline':False]['text':' A NUL is added at the end, because netbeans code expects that.','line_number':1991,'multiline':False]['text':' Otherwise a NUL may appear inside the text.','line_number':1992,'multiline':False]['text':' out of memory','line_number':1997,'multiline':False]['text':' Drop any CR before a NL.','line_number':2002,'multiline':False]['text':' prepend node to the head of the queue','line_number':2019,'multiline':False]['text':' append node to the tail of the queue','line_number':2030,'multiline':False]['text':'
 * Try to fill the buffer of "reader".
 * Returns FALSE when nothing was added.
 ','line_number':2046,'multiline':True]['text':' Prepend unused text.','line_number':2066,'multiline':False]['text':'
 * Process the HTTP header in a Language Server Protocol (LSP) message.
 *
 * The message format is described in the LSP specification:
 * https://microsoft.github.io/language-server-protocol/specification
 *
 * It has the following two fields:
 *
 *	Content-Length: ...
 *	Content-Type: application/vscode-jsonrpc; charset=utf-8
 *
 * Each field ends with "\r\n". The header ends with an additional "\r\n".
 *
 * Returns OK if a valid header is received and FAIL if some fields in the
 * header are not correct. Returns MAYBE if a partial header is received and
 * need to wait for more data to arrive.
 ','line_number':2085,'multiline':True]['text':' We find the end once, to avoid calling strlen() many times.','line_number':2111,'multiline':False]['text':' Process each line in the header till an empty line is read (header','line_number':2117,'multiline':False]['text':' separator).','line_number':2118,'multiline':False]['text':' partial header','line_number':2124,'multiline':False]['text':' process the content length field (if present)','line_number':2128,'multiline':False]['text':' invalid length, discard the payload','line_number':2135,'multiline':False]['text':' reached the empty line','line_number':2141,'multiline':False]['text':' Content-Length field is not present in the header','line_number':2146,'multiline':False]['text':' if the entire payload is not received, wait for more data to arrive','line_number':2151,'multiline':False]['text':' recalculate the end based on the length read from the header.','line_number':2156,'multiline':False]['text':'
 * Use the read buffer of "channel"/"part" and parse a JSON message that is
 * complete.  The messages are added to the queue.
 * Return TRUE if there is more to read.
 ','line_number':2162,'multiline':True]['text':' When a message is incomplete we wait for a short while for more to','line_number':2190,'multiline':False]['text':' arrive.  After the delay drop the input, otherwise a truncated string','line_number':2191,'multiline':False]['text':' or list will make us hang.','line_number':2192,'multiline':False]['text':' Do not generate error messages, they will be written in a channel log.','line_number':2193,'multiline':False]['text':' Only accept the response when it is a list with at least two','line_number':2203,'multiline':False]['text':' items.','line_number':2204,'multiline':False]['text':' First time encountering incomplete message or after receiving','line_number':2257,'multiline':False]['text':' more (but still incomplete): set a deadline of 100 msec.','line_number':2258,'multiline':False]['text':' Put the unread part back into the channel.','line_number':2313,'multiline':False]['text':'
 * Remove "node" from the queue that it is in.  Does not free it.
 ','line_number':2326,'multiline':True]['text':'
 * Remove "node" from the queue that it is in and free it.
 * Caller should have freed or used node->jq_value.
 ','line_number':2342,'multiline':True]['text':'
 * Add "id" to the list of JSON message IDs we are waiting on.
 ','line_number':2360,'multiline':True]['text':'
 * Remove "id" from the list of JSON message IDs we are waiting on.
 ','line_number':2377,'multiline':True]['text':'
 * Return TRUE if "id" is in the list of JSON message IDs we are waiting on.
 ','line_number':2401,'multiline':True]['text':'
 * Get a message from the JSON queue for channel "channel".
 * When "id" is positive it must match the first number in the list.
 * When "id" is zero or negative jut get the first message.  But not one
 * in the ch_block_ids list.
 * When "without_callback" is TRUE also get messages that were pushed back.
 * Return OK when found and return the value in "rettv".
 * Return FAIL otherwise.
 ','line_number':2416,'multiline':True]['text':' LSP message payload is a JSON-RPC dict.','line_number':2452,'multiline':False]['text':' For RPC requests and responses, the 'id' item will be present.','line_number':2453,'multiline':False]['text':' For notifications, it will not be present.','line_number':2454,'multiline':False]['text':' When looking for a response message from the LSP server,','line_number':2462,'multiline':False]['text':' ignore new LSP request and notification messages. Â LSP','line_number':2463,'multiline':False]['text':' request and notification messages have the "method" field in','line_number':2464,'multiline':False]['text':' the header and the response messages do not have this field.','line_number':2465,'multiline':False]['text':'
 * Put back "rettv" into the JSON queue, there was no callback for it.
 * Takes over the values in "rettv".
 ','line_number':2497,'multiline':True]['text':' last item was pushed back, append to the end','line_number':2509,'multiline':False]['text':' append after the last item that was pushed back','line_number':2512,'multiline':False]['text':' append to the end','line_number':2534,'multiline':False]['text':' append after "item"','line_number':2545,'multiline':False]['text':'
 * Execute a command received over "channel"/"part"
 * "argv[0]" is the command string.
 * "argv[1]" etc. have further arguments, type is VAR_UNKNOWN if missing.
 ','line_number':2558,'multiline':True]['text':' no mapping','line_number':2607,'multiline':False]['text':' Don't pollute the display with errors.','line_number':2643,'multiline':False]['text':' Do generate the errors so that try/catch works.','line_number':2644,'multiline':False]['text':' If evaluation failed or the result can't be encoded','line_number':2666,'multiline':False]['text':' then return the string "ERROR".','line_number':2667,'multiline':False]['text':'
 * Invoke the callback at "cbhead".
 * Does not redraw but sets channel_need_redraw.
 ','line_number':2695,'multiline':True]['text':' Remove the item from the list first, if the callback','line_number':2708,'multiline':False]['text':' invokes ch_close() the list will be cleared.','line_number':2709,'multiline':False]['text':' If the buffer is also used as input insert above the last','line_number':2736,'multiline':False]['text':' line. Don't write these lines.','line_number':2737,'multiline':False]['text':' Append to the buffer','line_number':2744,'multiline':False]['text':' Set curbuf to "buffer", temporarily.','line_number':2750,'multiline':False]['text':' Could not find a window for this buffer, the following might cause','line_number':2754,'multiline':False]['text':' trouble, better bail out.','line_number':2755,'multiline':False]['text':' ignore undo failure, undo is not very useful here','line_number':2760,'multiline':False]['text':' The buffer is empty, replace the first (dummy) line.','line_number':2765,'multiline':False]['text':' reset notion of buffer','line_number':2773,'multiline':False]['text':' If the cursor is at or above the new line, move it one line','line_number':2794,'multiline':False]['text':' down.  If the topline is outdated update it now.','line_number':2795,'multiline':False]['text':' Find channels reading from this buffer and adjust their','line_number':2818,'multiline':False]['text':' next-to-read line number.','line_number':2819,'multiline':False]['text':'
 * Return TRUE if for "channel" / "part" ch_json_head should be used.
 ','line_number':2843,'multiline':True]['text':'
 * Invoke a callback for "channel"/"part" if needed.
 * This does not redraw but sets channel_need_redraw when redraw is needed.
 * Return TRUE when a message was handled, there might be another one.
 ','line_number':2855,'multiline':True]['text':' one time callbackup','line_number':2874,'multiline':False]['text':' this channel is handled elsewhere (netbeans)','line_number':2877,'multiline':False]['text':' Use a message-specific callback, part callback or channel callback','line_number':2880,'multiline':False]['text':' buffer was wiped out or unloaded','line_number':2895,'multiline':False]['text':' Get any json message in the queue.','line_number':2906,'multiline':False]['text':' In the "lsp" mode, the http header and the json payload may','line_number':2910,'multiline':False]['text':' be received in multiple messages. So concatenate all the','line_number':2911,'multiline':False]['text':' received messages.','line_number':2912,'multiline':False]['text':' Parse readahead, return when there is still no message.','line_number':2915,'multiline':False]['text':' ["cmd", arg] or ["cmd", arg, arg] or ["cmd", arg, arg, arg]','line_number':2947,'multiline':False]['text':' nothing to read on RAW or NL channel','line_number':2965,'multiline':False]['text':' If there is no callback or buffer drop the message.','line_number':2970,'multiline':False]['text':' If there is a close callback it may use ch_read() to get the','line_number':2973,'multiline':False]['text':' messages.','line_number':2974,'multiline':False]['text':' See if we have a message ending in NL in the first buffer.  If','line_number':2986,'multiline':False]['text':' not try to concatenate the first and the second buffer.','line_number':2987,'multiline':False]['text':' incomplete message','line_number':2998,'multiline':False]['text':' Convert NUL to NL, the internal representation.','line_number':3003,'multiline':False]['text':' get the whole buffer, drop the NL','line_number':3011,'multiline':False]['text':' get the whole buffer','line_number':3016,'multiline':False]['text':' Copy the message into allocated memory (excluding the NL)','line_number':3022,'multiline':False]['text':' and remove it from the buffer (including the NL).','line_number':3023,'multiline':False]['text':' For a raw channel we don't know where the message ends, just','line_number':3030,'multiline':False]['text':' get everything we have.','line_number':3031,'multiline':False]['text':' Convert NUL to NL, the internal representation.','line_number':3032,'multiline':False]['text':' out of memory (and avoids Coverity warning)','line_number':3037,'multiline':False]['text':' JSON or JS or LSP mode: invoke the one-time callback with the','line_number':3046,'multiline':False]['text':' matching nr','line_number':3047,'multiline':False]['text':' Don't use a LSP server request message with the same sequence number','line_number':3050,'multiline':False]['text':' as the client request message as the response message.','line_number':3051,'multiline':False]['text':' If the 'drop' channel attribute is set to 'never' or if','line_number':3075,'multiline':False]['text':' ch_evalexpr() is waiting for this response message, then don't','line_number':3076,'multiline':False]['text':' drop this message.','line_number':3077,'multiline':False]['text':' message must be read with ch_read()','line_number':3080,'multiline':False]['text':' Change the type to avoid the value being freed.','line_number':3083,'multiline':False]['text':' JSON or JS mode: re-encode the message.','line_number':3098,'multiline':False]['text':' invoke the channel callback','line_number':3117,'multiline':False]['text':'
 * Return TRUE when channel "channel" is open for writing to.
 * Also returns FALSE or invalid "channel".
 ','line_number':3135,'multiline':True]['text':'
 * Return TRUE when channel "channel" is open for reading or writing.
 * Also returns FALSE for invalid "channel".
 ','line_number':3147,'multiline':True]['text':'
 * Return a pointer indicating the readahead.  Can only be compared between
 * calls.  Returns NULL if there is no readahead.
 ','line_number':3160,'multiline':True]['text':' Parse json from readahead, there might be a complete message to','line_number':3172,'multiline':False]['text':' process.','line_number':3173,'multiline':False]['text':'
 * Return TRUE if "channel" has JSON or other typeahead.
 ','line_number':3181,'multiline':True]['text':'
 * Return a string indicating the status of the channel.
 * If "req_part" is not negative check that part.
 ','line_number':3190,'multiline':True]['text':' longest is "sock_timeout"','line_number':3237,'multiline':False]['text':' Unix-domain socket.','line_number':3297,'multiline':False]['text':'
 * Close channel "channel".
 * Trigger the close callback if "invoke_close_cb" is TRUE.
 * Does not clear the buffers.
 ','line_number':3309,'multiline':True]['text':' let the terminal know it is closing to avoid getting stuck','line_number':3333,'multiline':False]['text':' Invoke callbacks and flush buffers before the close callback.','line_number':3336,'multiline':False]['text':' Increment the refcount to avoid the channel being freed','line_number':3345,'multiline':False]['text':' halfway.','line_number':3346,'multiline':False]['text':' Increment the refcount to avoid the channel being freed','line_number':3362,'multiline':False]['text':' halfway.','line_number':3363,'multiline':False]['text':' the callback is only called once','line_number':3373,'multiline':False]['text':' any remaining messages are useless now','line_number':3383,'multiline':False]['text':'
 * Close the "in" part channel "channel".
 ','line_number':3398,'multiline':True]['text':'
 * Clear the read buffer on "channel"/"part".
 ','line_number':3419,'multiline':True]['text':'
 * Clear all the read buffers on "channel".
 ','line_number':3455,'multiline':True]['text':' Sent when the netbeans channel is found closed when reading.','line_number':3484,'multiline':False]['text':' Buffer size for reading incoming messages.','line_number':3487,'multiline':False]['text':'
 * Check if there are remaining data that should be written for "in_part".
 ','line_number':3490,'multiline':True]['text':'
 * Add write fds where we are waiting for writing to be possible.
 ','line_number':3509,'multiline':True]['text':'
 * Add write fds where we are waiting for writing to be possible.
 ','line_number':3533,'multiline':True]['text':'
 * Check for reading from "fd" with "timeout" msec.
 * Return CW_READY when there is something to read.
 * Return CW_NOT_READY when there is nothing to read.
 * Return CW_ERROR when there is an error.
 ','line_number':3567,'multiline':True]['text':' reading from a pipe, not a socket','line_number':3587,'multiline':False]['text':' perhaps write some buffer lines','line_number':3603,'multiline':False]['text':' Wait for a little while.  Very short at first, up to 10 msec','line_number':3609,'multiline':False]['text':' after looping a few times.','line_number':3610,'multiline':False]['text':' Write lines to a pipe when a pipe can be written to.  Need to','line_number':3636,'multiline':False]['text':' set this every time, some buffers may be done.','line_number':3637,'multiline':False]['text':' Do not call emsg(), most likely the other end just exited.','line_number':3687,'multiline':False]['text':' Queue a "DETACH" netbeans message in the command queue in order to','line_number':3692,'multiline':False]['text':' terminate the netbeans session later. Do not end the session here','line_number':3693,'multiline':False]['text':' directly as we may be running in the context of a call to','line_number':3694,'multiline':False]['text':' netbeans_parse_messages():','line_number':3695,'multiline':False]['text':'	netbeans_parse_messages','line_number':3696,'multiline':False]['text':'	    -> autocmd triggered while processing the netbeans cmd','line_number':3697,'multiline':False]['text':'		-> ui_breakcheck','line_number':3698,'multiline':False]['text':'		    -> gui event loop or select loop','line_number':3699,'multiline':False]['text':'			-> channel_read()','line_number':3700,'multiline':False]['text':' Only send "DETACH" for a netbeans channel.','line_number':3701,'multiline':False]['text':' When reading is not possible close this part of the channel.  Don't','line_number':3706,'multiline':False]['text':' close the channel yet, there may be something to read on another part.','line_number':3707,'multiline':False]['text':' When stdout and stderr use the same FD we get the error only on one of','line_number':3708,'multiline':False]['text':' them, also close the other.','line_number':3709,'multiline':False]['text':' Stop listening to GUI events right away.','line_number':3720,'multiline':False]['text':'
 * Read from channel "channel" for as long as there is something to read.
 * "part" is PART_SOCK, PART_OUT or PART_ERR.
 * The data is put in the read queue.  No callbacks are invoked here.
 ','line_number':3734,'multiline':True]['text':' Allocate a buffer to read into.','line_number':3757,'multiline':False]['text':' out of memory!','line_number':3762,'multiline':False]['text':' Keep on reading for as long as there is something to read.','line_number':3765,'multiline':False]['text':' Use select() or poll() to avoid blocking on a message that is exactly','line_number':3766,'multiline':False]['text':' MAXMSGSIZE long.','line_number':3767,'multiline':False]['text':' error or nothing more to read','line_number':3777,'multiline':False]['text':' Store the read message in the queue.','line_number':3779,'multiline':False]['text':' Reading a disconnection (readlen == 0), or an error.','line_number':3784,'multiline':False]['text':' signal the main loop that there is something to read','line_number':3792,'multiline':False]['text':'
 * Read from RAW or NL "channel"/"part".  Blocks until there is something to
 * read or the timeout expires.
 * When "raw" is TRUE don't block waiting on a NL.
 * Does not trigger timers or handle messages.
 * Returns what was read in allocated memory.
 * Returns NULL in case of error or timeout.
 ','line_number':3797,'multiline':True]['text':' got a complete message','line_number':3826,'multiline':False]['text':' If not blocking or nothing more is coming then return what we','line_number':3830,'multiline':False]['text':' have.','line_number':3831,'multiline':False]['text':' Wait for up to the channel timeout.','line_number':3836,'multiline':False]['text':' We have a complete message now.','line_number':3847,'multiline':False]['text':' Convert NUL to NL, the internal representation.','line_number':3859,'multiline':False]['text':' must be a closed channel with missing NL','line_number':3866,'multiline':False]['text':' get the whole buffer','line_number':3871,'multiline':False]['text':' Copy the message into allocated memory and remove it from the','line_number':3877,'multiline':False]['text':' buffer.','line_number':3878,'multiline':False]['text':'
 * Return TRUE if in a blocking wait that might trigger callbacks.
 ','line_number':3890,'multiline':True]['text':'
 * Read one JSON message with ID "id" from "channel"/"part" and store the
 * result in "rettv".
 * When "id" is -1 accept any message;
 * Blocks until the message is received or the timeout is reached.
 * In corner cases this can be called recursively, that is why ch_block_ids is
 * a list.
 ','line_number':3899,'multiline':True]['text':' In the "lsp" mode, the http header and the json payload may be','line_number':3931,'multiline':False]['text':' received in multiple messages. So concatenate all the received','line_number':3932,'multiline':False]['text':' messages.','line_number':3933,'multiline':False]['text':' search for message "id"','line_number':3938,'multiline':False]['text':' Handle any other messages in the queue.  If done some more','line_number':3951,'multiline':False]['text':' messages may have arrived.','line_number':3952,'multiline':False]['text':' channel_parse_messages() may fill the queue with new data to','line_number':3956,'multiline':False]['text':' process.  Only loop when the readahead changed, otherwise we','line_number':3957,'multiline':False]['text':' would busy-loop.','line_number':3958,'multiline':False]['text':' Wait for up to the timeout.  If there was an incomplete message','line_number':3963,'multiline':False]['text':' use the deadline for that.','line_number':3964,'multiline':False]['text':' Something went wrong, channel_parse_json() didn't','line_number':3984,'multiline':False]['text':' discard message.  Cancel waiting.','line_number':3985,'multiline':False]['text':'
 * Get the channel from the argument.
 * Returns NULL if the handle is invalid.
 * When "check_open" is TRUE check that the channel can be used.
 * When "reading" is TRUE "check_open" considers typeahead useful.
 * "part" is used to check typeahead, when PART_COUNT use the default part.
 ','line_number':4014,'multiline':True]['text':'
 * Common for ch_read() and ch_readraw().
 ','line_number':4054,'multiline':True]['text':' return an empty string by default','line_number':4068,'multiline':False]['text':'
 * Check the channels for anything that is ready to be read.
 * The data is put in the read queue.
 * if "only_keep_open" is TRUE only check channels where ch_keep_open is set.
 ','line_number':4143,'multiline':True]['text':' check the socket and pipes','line_number':4160,'multiline':False]['text':' Workaround for Haiku: Since select/poll cannot detect EOF from tty,','line_number':4177,'multiline':False]['text':' should close fds when the job has finished if 'channel' connects to','line_number':4178,'multiline':False]['text':' the pty.','line_number':4179,'multiline':False]['text':'
 * Return TRUE when there is any channel with a keep_open flag.
 ','line_number':4194,'multiline':True]['text':'
 * Set "channel"/"part" to non-blocking.
 * Only works for sockets and pipes.
 ','line_number':4209,'multiline':True]['text':'
 * Write "buf" (NUL terminated string) to "channel"/"part".
 * When "fun" is not NULL an error message might be given.
 * Return FAIL or OK.
 ','line_number':4232,'multiline':True]['text':' first write what was queued','line_number':4279,'multiline':False]['text':' nothing to write, called from channel_select_check()','line_number':4287,'multiline':False]['text':' nothing got written','line_number':4311,'multiline':False]['text':' Wrote all the buf[len] bytes.','line_number':4321,'multiline':False]['text':' Remove the entry from the write queue.','line_number':4324,'multiline':False]['text':' Wrote only buf[res] bytes, can't write more now.','line_number':4333,'multiline':False]['text':' Remove the bytes that were written.','line_number':4338,'multiline':False]['text':' Append the not written bytes of the argument to the write','line_number':4354,'multiline':False]['text':' buffer.  Limit entries to 4000 bytes.','line_number':4355,'multiline':False]['text':' append to the last entry','line_number':4361,'multiline':False]['text':'
 * Common for "ch_sendexpr()" and "ch_sendraw()".
 * Returns the channel if the caller should read the response.
 * Sets "part_read" to the read fd.
 * Otherwise returns NULL.
 ','line_number':4409,'multiline':True]['text':' Set the callback. An empty callback means no callback and not reading','line_number':4439,'multiline':False]['text':' the response. With "ch_evalexpr()" and "ch_evalraw()" a callback is not','line_number':4440,'multiline':False]['text':' allowed.','line_number':4441,'multiline':False]['text':'
 * common for "ch_evalexpr()" and "ch_sendexpr()"
 ','line_number':4458,'multiline':True]['text':' return an empty string by default','line_number':4475,'multiline':False]['text':' return an empty dict by default','line_number':4501,'multiline':False]['text':' only number type is supported for the 'id' item','line_number':4512,'multiline':False]['text':' When evaluating an expression or sending an expression with a','line_number':4523,'multiline':False]['text':' callback, always assign a generated ID','line_number':4524,'multiline':False]['text':' When sending an expression, if the message has an 'id' item,','line_number':4533,'multiline':False]['text':' then use it.','line_number':4534,'multiline':False]['text':' Change the type to avoid the value being freed.','line_number':4567,'multiline':False]['text':' Move the item from the list and then change the type to','line_number':4575,'multiline':False]['text':' avoid the value being freed.','line_number':4576,'multiline':False]['text':' if ch_sendexpr() is used to send a LSP message and a callback','line_number':4586,'multiline':False]['text':' function is specified, then return the generated identifier for the','line_number':4587,'multiline':False]['text':' message.  The user can use this to cancel the request (if needed).','line_number':4588,'multiline':False]['text':'
 * common for "ch_evalraw()" and "ch_sendraw()"
 ','line_number':4594,'multiline':True]['text':' return an empty string by default','line_number':4608,'multiline':False]['text':' msec','line_number':4642,'multiline':False]['text':'
 * Add open channels to the poll struct.
 * Return the adjusted struct index.
 * The type of "fds" is hidden to avoid problems with the function proto.
 ','line_number':4645,'multiline':True]['text':' For unknown reason poll() returns immediately for a','line_number':4668,'multiline':False]['text':' keep-open channel.  Instead of adding it to the fds add','line_number':4669,'multiline':False]['text':' a short timeout and check, like polling.','line_number':4670,'multiline':False]['text':'
 * The type of "fds" is hidden to avoid problems with the function proto.
 ','line_number':4692,'multiline':True]['text':' polling a keep-open channel','line_number':4719,'multiline':False]['text':' UNIX && !HAVE_SELECT','line_number':4735,'multiline':False]['text':'
 * The "fd_set" type is hidden to avoid problems with the function proto.
 ','line_number':4739,'multiline':True]['text':' For unknown reason select() returns immediately for a','line_number':4766,'multiline':False]['text':' keep-open channel.  Instead of adding it to the rfds add','line_number':4767,'multiline':False]['text':' a short timeout and check, like polling.','line_number':4768,'multiline':False]['text':'
 * The "fd_set" type is hidden to avoid problems with the function proto.
 ','line_number':4792,'multiline':True]['text':' polling a keep-open channel','line_number':4819,'multiline':False]['text':' Clear the flag first, ch_fd may change in channel_write_input().','line_number':4828,'multiline':False]['text':' Workaround for Haiku: Since select/poll cannot detect EOF from tty,','line_number':4835,'multiline':False]['text':' should close fds when the job has finished if 'channel' connects to','line_number':4836,'multiline':False]['text':' the pty.','line_number':4837,'multiline':False]['text':' !MSWIN && HAVE_SELECT','line_number':4851,'multiline':False]['text':'
 * Execute queued up commands.
 * Invoked from the main loop when it's safe to execute received commands,
 * and during a blocking wait for ch_evalexpr().
 * Return TRUE when something was done.
 ','line_number':4853,'multiline':True]['text':' The code below may invoke callbacks, which might call us back.','line_number':4871,'multiline':False]['text':' In a recursive call channels will not be closed.','line_number':4872,'multiline':False]['text':' Only do this message when another message was given, otherwise we get','line_number':4880,'multiline':False]['text':' lots of them.','line_number':4881,'multiline':False]['text':' now we should also give the message for SafeState','line_number':4885,'multiline':False]['text':' channel may have been freed, start over','line_number':4896,'multiline':False]['text':' free the channel and then start over','line_number':4906,'multiline':False]['text':' channel is no longer useful, free it','line_number':4913,'multiline':False]['text':' Increase the refcount, in case the handler causes the channel','line_number':4924,'multiline':False]['text':' to be unreferenced or closed.','line_number':4925,'multiline':False]['text':' Limit the time we loop here to 100 msec, otherwise','line_number':4932,'multiline':False]['text':' Vim becomes unresponsive when the callback takes','line_number':4933,'multiline':False]['text':' more than a bit of time.','line_number':4934,'multiline':False]['text':' channel was freed or something was done, start over','line_number':4939,'multiline':False]['text':'
 * Return TRUE if any channel has readahead.  That means we should not block on
 * waiting for input.
 ','line_number':4966,'multiline':True]['text':'
 * Mark references to lists used in channels.
 ','line_number':4991,'multiline':True]['text':'
 * Return the "part" to write to for "channel".
 ','line_number':5012,'multiline':True]['text':'
 * Return the default "part" to read from for "channel".
 ','line_number':5023,'multiline':True]['text':'
 * Return the mode of "channel"/"part"
 * If "channel" is invalid returns CH_MODE_JSON.
 ','line_number':5034,'multiline':True]['text':'
 * Return the timeout of "channel"/"part"
 ','line_number':5046,'multiline':True]['text':'
 * "ch_canread()" function
 ','line_number':5055,'multiline':True]['text':'
 * "ch_close()" function
 ','line_number':5074,'multiline':True]['text':'
 * "ch_close()" function
 ','line_number':5093,'multiline':True]['text':'
 * "ch_getbufnr()" function
 ','line_number':5109,'multiline':True]['text':'
 * "ch_getjob()" function
 ','line_number':5143,'multiline':True]['text':'
 * "ch_info()" function
 ','line_number':5164,'multiline':True]['text':'
 * "ch_open()" function
 ','line_number':5180,'multiline':True]['text':'
 * "ch_read()" function
 ','line_number':5192,'multiline':True]['text':'
 * "ch_readblob()" function
 ','line_number':5201,'multiline':True]['text':'
 * "ch_readraw()" function
 ','line_number':5210,'multiline':True]['text':'
 * "ch_evalexpr()" function
 ','line_number':5219,'multiline':True]['text':'
 * "ch_sendexpr()" function
 ','line_number':5228,'multiline':True]['text':'
 * "ch_evalraw()" function
 ','line_number':5237,'multiline':True]['text':'
 * "ch_sendraw()" function
 ','line_number':5246,'multiline':True]['text':'
 * "ch_setoptions()" function
 ','line_number':5255,'multiline':True]['text':'
 * "ch_status()" function
 ','line_number':5279,'multiline':True]['text':' return an empty string by default','line_number':5289,'multiline':False]['text':'
 * Get a string with information about the channel in "varp" in "buf".
 * "buf" must be at least NUMBUFLEN long.
 ','line_number':5311,'multiline':True]['text':' FEAT_JOB_CHANNEL','line_number':5329,'multiline':False]